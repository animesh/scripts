```{r libs}
#https://github.com/brandonyph/Survival-Analysis-demo/blob/main/Survival_Analysis_demo.R
#BiocManager::install("TCGAbiolinks",force = TRUE)
library("TCGAbiolinks")
library("limma")
#BiocManager::install("edgeR",force = TRUE)
library("edgeR")
#install.packages("glmnet")
library("glmnet")
#install.packages("factoextra")
library("factoextra")
library("FactoMineR")
library("caret")
library("SummarizedExperiment")
library("gplots")
library("survival")
library("survminer")
library("RColorBrewer")
#BiocManager::install("gProfileR",force = TRUE)
library("gProfileR")
#BiocManager::install("genefilter",force = TRUE)
library("genefilter")
```
```{r MMRF}
#install.packages("devtools")
#devtools::install_github(c("RDocTaskForce/testextra","RDocTaskForce/parsetools","halpo/purrrogress"))
#install.packages(c("BiocManager","shiny","markdown","knitr","sweave","xtable","DT","httpuv","sourcetools"))
#BiocManager::install(c("EDASeq","genefilter","sva","limma","GenomicFeatures","GenomeInfoDb","GenomicRanges","SummarizedExperiment","EnsDb.Hsapiens.v79","S4Vectors","biomaRt","BiocStyle","edgeR","IRanges","TCGAbiolinks"))
#devtools::install_github("marziasettino/MMRFBiolinks")
#download and process
#library(SummarizedExperiment)
#library(dplyr)
#library(DT)
#library(ggplot2)
#library(TCGAbiolinks)
#library(MMRFBiolinks)
#MMRFclin <- MMRFGDC_QueryClinic(type = "clinical")
#listSamples <- MMRFclin$bcr_patient_barcode
#query <- GDCquery(project = "MMRF-COMMPASS",data.category = "Transcriptome Profiling",data.type = "Gene Expression Quantification",experimental.strategy = "RNA-Seq",workflow.type="HTSeq - FPKM",barcode = listSamples)
#GDCdownload(query, method = "api", files.per.chunk = 10)
#MMRnaseqSE <- MMRFGDC_prepare(query,save = TRUE ,save.filename = "GDCdata.rda",directory = "GDCdata",summarizedExperiment = TRUE)
#MMRFdataPrepro <- TCGAanalyze_Preprocessing(MMRnaseqSE)
#save(file="MMRFdataPrepro.rds",MMRFdataPrepro)
#save(file="MMRFclin.rds",MMRFclin)
#savehistory("R.history")
load("L:/promec/Animesh/Aida/MMRFBiolinks/plotKM/MMRFclin.rds")
plot(MMRFclin$treatments[[1]])#"treatment_outcome"])
#download.file("https://studntnu-my.sharepoint.com/:u:/g/personal/animeshs_ntnu_no/EfQcUVcV4m5IlA7YY9h6zFsBJwZhomsv-0r5uIgnd8Wt0g?e=UZC0vP","MMRFdataPrepro.rds")
load("L:/promec/Animesh/Aida/MMRFBiolinks/plotKM/MMRFdataPrepro.rds")
plot(MMRFdataPrepro[[1]])#"treatment_outcome"])
#https://stackoverflow.com/a/26089312/1137129
blKM<-TCGAbiolinks::TCGAanalyze_SurvivalKM#<-TCGAanalyze_SurvivalKM
body(blKM)[[25]][[4]]<-substitute({
  cat(paste0((ngenes - i), "."))
  mRNAselected <- as.matrix(rownames(dataNormal))[i]
  mRNAselected_values <- dataCancer[rownames(dataCancer) == 
                                      mRNAselected, ]
  mRNAselected_values_normal <- dataNormal[rownames(dataNormal) == 
                                             mRNAselected, ]
  if (all(mRNAselected_values == 0)) 
    next
  tabSurv_Matrix[i, "mRNA"] <- mRNAselected
  mRNAselected_values_ordered <- sort(mRNAselected_values, 
                                      decreasing = TRUE)
  mRNAselected_values_ordered_top <- as.numeric(quantile(as.numeric(mRNAselected_values_ordered), 
                                                         ThreshTop)[1])
  mRNAselected_values_ordered_down <- as.numeric(quantile(as.numeric(mRNAselected_values_ordered), 
                                                          ThreshDown)[1])
  mRNAselected_values_newvector <- mRNAselected_values
  if (!is.na(mRNAselected_values_ordered_top)) {
    numberOfSamples <- length(mRNAselected_values_ordered)
    lastelementTOP <- max(which(mRNAselected_values_ordered > 
                                  mRNAselected_values_ordered_top))
    firstelementDOWN <- min(which(mRNAselected_values_ordered <= 
                                    mRNAselected_values_ordered_down))
    samples_top_mRNA_selected <- names(mRNAselected_values_ordered[1:lastelementTOP])
    samples_down_mRNA_selected <- names(mRNAselected_values_ordered[firstelementDOWN:numberOfSamples])
    samples_UNCHANGED_mRNA_selected <- names(mRNAselected_values_newvector[which((mRNAselected_values_newvector) > 
                                                                                   mRNAselected_values_ordered_down & mRNAselected_values_newvector < 
                                                                                   mRNAselected_values_ordered_top)])
    cfu_onlyTOP <- cfu_complete[cfu_complete[, "bcr_patient_barcode"] %in% 
                                  samples_top_mRNA_selected, ]
    cfu_onlyDOWN <- cfu_complete[cfu_complete[, "bcr_patient_barcode"] %in% 
                                   samples_down_mRNA_selected, ]
    cfu_onlyUNCHANGED <- cfu_complete[cfu_complete[, "bcr_patient_barcode"] %in% 
                                        samples_UNCHANGED_mRNA_selected, ]
    cfu_ordered <- NULL
    cfu_ordered <- rbind(cfu_onlyTOP, cfu_onlyDOWN)
    cfu <- cfu_ordered
    ttime <- as.numeric(cfu[, "days_to_death"])
    sum(status <- ttime > 0)
    deads_complete <- sum(status <- ttime > 0)
    ttime_only_top <- cfu_onlyTOP[, "days_to_death"]
    deads_top <- sum(ttime_only_top > 0)
    if (dim(cfu_onlyDOWN)[1] >= 1) {
      ttime_only_down <- cfu_onlyDOWN[, "days_to_death"]
      deads_down <- sum(ttime_only_down > 0)
    }
    else {
      deads_down <- 0
    }
    tabSurv_Matrix[i, "Cancer Deaths"] <- deads_complete
    tabSurv_Matrix[i, "Cancer Deaths with Top"] <- deads_top
    tabSurv_Matrix[i, "Cancer Deaths with Down"] <- deads_down
    tabSurv_Matrix[i, "Mean Normal"] <- mean(as.numeric(mRNAselected_values_normal))
    dataCancer_onlyTop_sample <- dataCancer[, samples_top_mRNA_selected, 
                                            drop = FALSE]
    dataCancer_onlyTop_sample_mRNASelected <- dataCancer_onlyTop_sample[rownames(dataCancer_onlyTop_sample) == 
                                                                          mRNAselected, ]
    dataCancer_onlyDown_sample <- dataCancer[, samples_down_mRNA_selected, 
                                             drop = FALSE]
    dataCancer_onlyDown_sample_mRNASelected <- dataCancer_onlyDown_sample[rownames(dataCancer_onlyDown_sample) == 
                                                                            mRNAselected, ]
    tabSurv_Matrix[i, "Mean Tumor Top"] <- mean(as.numeric(dataCancer_onlyTop_sample_mRNASelected))
    tabSurv_Matrix[i, "Mean Tumor Down"] <- mean(as.numeric(dataCancer_onlyDown_sample_mRNASelected))
    ttime[!status] <- as.numeric(cfu[!status, "days_to_last_follow_up"])
    ttime[which(ttime == -Inf)] <- 0
    ttime <- survival::Surv(ttime, status)
    rownames(ttime) <- rownames(cfu)
    legendHigh <- paste(mRNAselected, "High")
    legendLow <- paste(mRNAselected, "Low")
    tabSurv_pvalue <- tryCatch({
      tabSurv <- survival::survdiff(ttime ~ c(rep("top", 
                                                  nrow(cfu_onlyTOP)), rep("down", nrow(cfu_onlyDOWN))))
      tabSurv_chis <- unlist(tabSurv)$chisq
      tabSurv_pvalue <- as.numeric(1 - pchisq(abs(tabSurv$chisq), 
                                              df = 1))
    }, error = function(e) {
      return(Inf)
    })
    tabSurv_Matrix[i, "pvalue"] <- tabSurv_pvalue
    if (Survresult == TRUE) {
      titlePlot <- paste("Kaplan-Meier Survival analysis, pvalue=", 
                         tabSurv_pvalue)
      plot(survival::survfit(ttime ~ c(rep("low", 
                                           nrow(cfu_onlyTOP)), rep("high", nrow(cfu_onlyDOWN)))), 
           col = c("green", "red"), main = titlePlot, 
           xlab = "Days", ylab = "Survival")
      legend("bottomleft",legend = c(legendLow, legendHigh), 
             col = c("green", "red"), text.col = c("green","red"), 
             pch = 15)
      print(tabSurv)
    }
  }
})
#https://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function
#newDef <- deparse(TCGAbiolinks::TCGAanalyze_SurvivalKM)
#newDef[grep("                legend",newDef)]<- "                legend(100, 1, legend = c(legendLow, legendHigh), "
#blKM <- eval(parse(text=newDef))
blKM(MMRFclin,MMRFdataPrepro,Genelist = "ENSG00000196976",Survresult = T,ThreshTop=0.66,ThreshDown=0.33)
blKM(MMRFclin,MMRFdataPrepro,Genelist = "ENSG00000196976",Survresult = T,ThreshTop=0.76,ThreshDown=0.33)
pData<-read.csv("L:/promec/Animesh/Aida/MMRFBiolinks/plotKM/ENSG00000196976.KM.txt",sep="\t")
gENSG<-"ENSG00000196449"
pData<-t(MMRFdataPrepro[gENSG, , drop = FALSE])
colnames(pData)<-gENSG
hist(pData)
qVal=quantile(pData,probs = seq(0, 1, 0.01))#qVal[67]#qVal[34]
max(pData)#qVal[101]
min(pData)#qVal[1]
sum(pData>qVal[77])
qqqqqqqqqqqsum(pData<qVal[34])
table(pData$C..Censor[pData$ENSG00000196449>qVal[77]])
table(pData$C..Censor[pData$ENSG00000196449<qVal[34]])
table(pData$C..Censor[pData$ENSG00000196449>qVal[78]])
table(pData$C..Censor[pData$ENSG00000196449<qVal[34]])
plot(table(pData$C..Censor[pData$ENSG00000196449>qVal[77]]))
plot(table(pData$C..Censor[pData$ENSG00000196449<qVal[34]]))
plot(pData$C..Follow,pData$C..Days)
plot(pData$ENSG00000196449,pData$C..Days)
plot(pData$ENSG00000196449,pData$C..Follow)
plot(pData$ENSG00000196449,pData$C..Follow,col=factor(ceiling(pData$C..Days/100)))
plot(pData$ENSG00000196449,pData$C..Follow,col=factor(!is.na(pData$C..Days)))
```
```{r TCGAbiolinks::TCGAanalyze_SurvivalKM}
blKM(MMRFclin,MMRFdataPrepro,Genelist = "ENSG00000196976",Survresult = T,ThreshTop=0.76,ThreshDown=0.33)
    library("survival")
    clinical_patient=MMRFclin
    dataGE=MMRFdataPrepro
    Genelist="ENSG00000196976"
    Survresult=T
    ThreshTop= 0.76
    ThreshDown= 0.33 
    p.cut=0.05
    group1="Normal"
    group2="Cancer"
    Genelist <- intersect(rownames(dataGE), Genelist)
    dataCancer <- dataGE[Genelist, group2, drop = FALSE]
    dataNormal <- dataGE[Genelist, group1, drop = FALSE]
    dataCancer <- dataGE[Genelist, , drop = FALSE]
    dataNormal <- dataGE[Genelist, , drop = FALSE]
    colnames(dataCancer) <- substr(colnames(dataCancer), 1, 12)
    cfu <- clinical_patient[clinical_patient[, "bcr_patient_barcode"] %in% 
        substr(colnames(dataCancer), 1, 12), ]
    if ("days_to_last_followup" %in% colnames(cfu)) 
        colnames(cfu)[grep("days_to_last_followup", colnames(cfu))] <- "days_to_last_follow_up"
    cfu <- as.data.frame(subset(cfu, select = c("bcr_patient_barcode", 
        "days_to_death", "days_to_last_follow_up", 
        "vital_status")))
    if (length(grep("alive", cfu$vital_status, ignore.case = TRUE)) > 
        0) 
        cfu[grep("alive", cfu$vital_status, ignore.case = TRUE), 
            "days_to_death"] <- "-Inf"
    if (length(grep("dead", cfu$vital_status, ignore.case = TRUE)) > 
        0) 
        cfu[grep("dead", cfu$vital_status, ignore.case = TRUE), 
            "days_to_last_follow_up"] <- "-Inf"
    cfu <- cfu[!(is.na(cfu[, "days_to_last_follow_up"])), 
        ]
    cfu <- cfu[!(is.na(cfu[, "days_to_death"])), ]
    followUpLevel <- FALSE
    tabSurv_Matrix <- matrix(0, nrow(as.matrix(rownames(dataNormal))), 
        8)
    colnames(tabSurv_Matrix) <- c("mRNA", "pvalue", 
        "Cancer Deaths", "Cancer Deaths with Top", 
        "Cancer Deaths with Down", "Mean Tumor Top", 
        "Mean Tumor Down", "Mean Normal")
    tabSurv_Matrix <- as.data.frame(tabSurv_Matrix)
    cfu$days_to_death <- as.numeric(as.character(cfu$days_to_death))
    cfu$days_to_last_follow_up <- as.numeric(as.character(cfu$days_to_last_follow_up))
    rownames(cfu) <- cfu[, "bcr_patient_barcode"]
    cfu <- cfu[!(is.na(cfu[, "days_to_last_follow_up"])), 
        ]
    cfu <- cfu[!(is.na(cfu[, "days_to_death"])), ]
    cfu_complete <- cfu
    ngenes <- nrow(as.matrix(rownames(dataNormal)))
    for (i in 1:nrow(as.matrix(rownames(dataNormal)))) {
      i=1
        cat(paste0((ngenes - i), "."))
        mRNAselected <- as.matrix(rownames(dataNormal))[i]
        mRNAselected_values <- dataCancer[rownames(dataCancer) == 
            mRNAselected, ]
        mRNAselected_values_normal <- dataNormal[rownames(dataNormal) == 
            mRNAselected, ]
        if (all(mRNAselected_values == 0)) 
            next
        tabSurv_Matrix[i, "mRNA"] <- mRNAselected
        mRNAselected_values_ordered <- sort(mRNAselected_values, 
            decreasing = TRUE)
        mRNAselected_values_ordered_top <- as.numeric(quantile(as.numeric(mRNAselected_values_ordered), 
            ThreshTop)[1])
        mRNAselected_values_ordered_down <- as.numeric(quantile(as.numeric(mRNAselected_values_ordered), 
            ThreshDown)[1])
        mRNAselected_values_newvector <- mRNAselected_values
        if (!is.na(mRNAselected_values_ordered_top)) {
            numberOfSamples <- length(mRNAselected_values_ordered)
            lastelementTOP <- max(which(mRNAselected_values_ordered > 
                mRNAselected_values_ordered_top))
            firstelementDOWN <- min(which(mRNAselected_values_ordered <= 
                mRNAselected_values_ordered_down))
            samples_top_mRNA_selected <- names(mRNAselected_values_ordered[1:lastelementTOP])
            samples_down_mRNA_selected <- names(mRNAselected_values_ordered[firstelementDOWN:numberOfSamples])
            samples_UNCHANGED_mRNA_selected <- names(mRNAselected_values_newvector[which((mRNAselected_values_newvector) > 
                mRNAselected_values_ordered_down & mRNAselected_values_newvector < 
                mRNAselected_values_ordered_top)])
            cfu_onlyTOP <- cfu_complete[cfu_complete[, "bcr_patient_barcode"] %in% 
                samples_top_mRNA_selected, ]
            cfu_onlyDOWN <- cfu_complete[cfu_complete[, "bcr_patient_barcode"] %in% 
                samples_down_mRNA_selected, ]
            cfu_onlyUNCHANGED <- cfu_complete[cfu_complete[, 
                "bcr_patient_barcode"] %in% samples_UNCHANGED_mRNA_selected, 
                ]
            cfu_ordered <- NULL
            cfu_ordered <- rbind(cfu_onlyTOP, cfu_onlyDOWN)
            cfu <- cfu_ordered
            ttime <- as.numeric(cfu[, "days_to_death"])
            sum(status <- ttime > 0)
            deads_complete <- sum(status <- ttime > 0)
            ttime_only_top <- cfu_onlyTOP[, "days_to_death"]
            deads_top <- sum(ttime_only_top > 0)
            if (dim(cfu_onlyDOWN)[1] >= 1) {
                ttime_only_down <- cfu_onlyDOWN[, "days_to_death"]
                deads_down <- sum(ttime_only_down > 0)
            }
            else {
                deads_down <- 0
            }
            tabSurv_Matrix[i, "Cancer Deaths"] <- deads_complete
            tabSurv_Matrix[i, "Cancer Deaths with Top"] <- deads_top
            tabSurv_Matrix[i, "Cancer Deaths with Down"] <- deads_down
            tabSurv_Matrix[i, "Mean Normal"] <- mean(as.numeric(mRNAselected_values_normal))
            dataCancer_onlyTop_sample <- dataCancer[, samples_top_mRNA_selected, 
                drop = FALSE]
            dataCancer_onlyTop_sample_mRNASelected <- dataCancer_onlyTop_sample[rownames(dataCancer_onlyTop_sample) == 
                mRNAselected, ]
            dataCancer_onlyDown_sample <- dataCancer[, samples_down_mRNA_selected, 
                drop = FALSE]
            dataCancer_onlyDown_sample_mRNASelected <- dataCancer_onlyDown_sample[rownames(dataCancer_onlyDown_sample) == 
                mRNAselected, ]
            tabSurv_Matrix[i, "Mean Tumor Top"] <- mean(as.numeric(dataCancer_onlyTop_sample_mRNASelected))
            tabSurv_Matrix[i, "Mean Tumor Down"] <- mean(as.numeric(dataCancer_onlyDown_sample_mRNASelected))
            ttime[!status] <- as.numeric(cfu[!status, "days_to_last_follow_up"])
            ttime[which(ttime == -Inf)] <- 0
            ttime <- survival::Surv(ttime, status)
            rownames(ttime) <- rownames(cfu)
            legendHigh <- paste(mRNAselected, "High")
            legendLow <- paste(mRNAselected, "Low")
            tabSurv_pvalue <- tryCatch({
                tabSurv <- survival::survdiff(ttime ~ c(rep("top", 
                  nrow(cfu_onlyTOP)), rep("down", nrow(cfu_onlyDOWN))))
                tabSurv_chis <- unlist(tabSurv)$chisq
                tabSurv_pvalue <- as.numeric(1 - pchisq(abs(tabSurv$chisq), 
                  df = 1))
            }, error = function(e) {
                return(Inf)
            })
            tabSurv_Matrix[i, "pvalue"] <- tabSurv_pvalue
            if (Survresult == TRUE) {
                titlePlot <- paste("Kaplan-Meier Survival analysis, pvalue=", 
                  tabSurv_pvalue)
                plot(survival::survfit(ttime ~ c(rep("low", 
                  nrow(cfu_onlyTOP)), rep("high", nrow(cfu_onlyDOWN)))), 
                  col = c("green", "red"), main = titlePlot, 
                  xlab = "Days", ylab = "Survival")
                legend("bottomleft", legend = c(legendLow, 
                  legendHigh), col = c("green", "red"), 
                  text.col = c("green", "red"), pch = 15)
                print(tabSurv)
            }
        }
    }
    tabSurv_Matrix[tabSurv_Matrix == "-Inf"] <- 0
    tabSurvKM <- tabSurv_Matrix
    tabSurvKM <- tabSurvKM[tabSurvKM$mRNA != 0, ]
    tabSurvKM <- tabSurvKM[tabSurvKM$pvalue < p.cut, ]
    tabSurvKM <- tabSurvKM[!duplicated(tabSurvKM$mRNA), ]
    rownames(tabSurvKM) <- tabSurvKM$mRNA
    tabSurvKM <- tabSurvKM[, -1]
    tabSurvKM <- tabSurvKM[order(tabSurvKM$pvalue, decreasing = FALSE), 
        ]
    colnames(tabSurvKM) <- gsub("Cancer", "Group2", 
        colnames(tabSurvKM))
    colnames(tabSurvKM) <- gsub("Tumor", "Group2", 
        colnames(tabSurvKM))
    colnames(tabSurvKM) <- gsub("Normal", "Group1", 
        colnames(tabSurvKM))
    return(tabSurvKM)
```

```{r TCGA}
GDCprojects = getGDCprojects()
head(GDCprojects[c("project_id", "name")])
TCGAbiolinks:::getProjectSummary("TCGA-PRAD")
query_TCGA = GDCquery(
  project = "TCGA-PRAD",
  data.category = "Transcriptome Profiling", # parameter enforced by GDCquery
  experimental.strategy = "RNA-Seq",
  workflow.type = "HTSeq - Counts")
prad_res = getResults(query_TCGA)
plot(prad_res$version)
prad_res$sample_type <- as.factor(prad_res$sample_type)
plot(prad_res$sample_type)
query_TCGA = GDCquery(
  project = "TCGA-PRAD",
  data.category = "Transcriptome Profiling", # parameter enforced by GDCquery
  experimental.strategy = "RNA-Seq",
  workflow.type = "HTSeq - Counts",
  sample.type = c("Primary Tumor", "Solid Tissue Normal"))
GDCdownload(query = query_TCGA)
tcga_data = GDCprepare(query_TCGA)
colnames(colData(tcga_data))
dim(tcga_data)
colnames(colData(tcga_data))
##Note that both clinical and expression data are present in this object
table(tcga_data@colData$vital_status)
table(tcga_data@colData$tumor_state)
table(tcga_data@colData$definition)
table(tcga_data@colData$tissue_or_organ_of_origin)
table(tcga_data@colData$primary_gleason_grade)
table(tcga_data@colData$psecondary_gleason_grade)
#table(tcga_data@colData$gender)
table(tcga_data@colData$race)
dim(assay(tcga_data))     # gene expression matrices
head(assay(tcga_data)[,1:10]) # expression of first 6 genes and first 10 samples
head(rowData(tcga_data))     # ensembl id and gene id of the first 6 genes.
saveRDS(object = tcga_data,file = "tcga_data.RDS",compress = FALSE)
```

```{r data}
tcga_data = readRDS(file = "tcga_data.RDS")
limma_pipeline = function(
  tcga_data,
  condition_variable,
  reference_group=NULL){
  
  design_factor = colData(tcga_data)[, condition_variable, drop=T]
  
  group = factor(design_factor)
  if(!is.null(reference_group)){group = relevel(group, ref=reference_group)}
  
  design = model.matrix(~ group)
  
  dge = DGEList(counts=assay(tcga_data),
                samples=colData(tcga_data),
                genes=as.data.frame(rowData(tcga_data)))
  
  # filtering
  keep = filterByExpr(dge,design)
  dge = dge[keep,,keep.lib.sizes=FALSE]
  rm(keep)
  
  # Normalization (TMM followed by voom)
  dge = calcNormFactors(dge)
  v = voom(dge, design, plot=TRUE)
  
  # Fit model to data given design
  fit = lmFit(v, design)
  fit = eBayes(fit)
  
  # Show top genes
  topGenes = topTable(fit, coef=ncol(design), number=100, sort.by="p")
  
  return(
    list(
      voomObj=v, # normalized data
      fit=fit, # fitted model and statistics
      topGenes=topGenes # the 100 most differentially expressed genes
    )
  )
}
limma_res = limma_pipeline(
  tcga_data=tcga_data,
  condition_variable="definition",
  reference_group="Solid Tissue Normal"
)
#race_limma_res = limma_pipeline(
 # tcga_data=tcga_data,
  #condition_variable="race",
  #reference_group="white"
#)
saveRDS(object = limma_res,
        file = "limma_res.RDS",
        compress = FALSE)
#----------the data can be loaded and begin from here--------
limma_res = readRDS(file = "limma_res.RDS")
#----------Visualization------------------------------------
plot_PCA = function(voomObj, condition_variable){
  group = factor(voomObj$targets[, condition_variable])
  pca = prcomp(t(voomObj$E))
  # Take PC1 and PC2 for the plot
  plot(pca$x[,1:2],col=group, pch=19)
  # include a legend for points
  legend("bottomleft", inset=.01, levels(group), pch=19, col=1:length(levels(group)))
  return(pca)
}
res_pca = plot_PCA(limma_res$voomObj, "definition")
#---------Survival analysis (Simple)---------------------------
#Question: Does race influence survival in prostate cancer patients?
# extract clinical data
clinical = tcga_data@colData

dim(clinical)

# we are only interested in the "Primary solid Tumor" cases for survival
clin_df = clinical[clinical$definition == "Primary solid Tumor",
                   c("patient",
                     "vital_status", #whether the patient is alive or dead
                     "days_to_death", #the number of days passed from initial diagnosis to the death
                     "days_to_last_follow_up", #the number of days passed from initial diagnosis to last visit
                     "race")]

# create a new boolean variable that has TRUE for dead patients
# and FALSE for live patients
clin_df$deceased = clin_df$vital_status == "Dead"

# create an "overall survival" variable that is equal to days_to_death
# for dead patients, and to days_to_last_follow_up for patients who
# are still alive
clin_df$overall_survival = ifelse(clin_df$deceased,
                                  clin_df$days_to_death,
                                  clin_df$days_to_last_follow_up)

# show first 6 samples
head(clin_df)
table(clin_df$race)

#Let's see if different races have had different prognosis
Surv(clin_df$overall_survival, clin_df$deceased)

Surv(clin_df$overall_survival, clin_df$deceased) ~ clin_df$race
# fit a survival model
fit = survfit(Surv(overall_survival, deceased) ~ race, data=clin_df)

print(fit)

# we produce a Kaplan Meier plot
ggsurvplot(fit, data=clin_df, pval = T)

ggsurvplot(fit, data=clin_df, pval=T, risk.table=T, risk.table.col="strata")

#---------Survival analysis (gene expression and survival)-----------
#Question: does gene expression of gene XYZ affect survival in prostate cancer patients?

#-----Classification---training and validation----
# Transpose and make it into a matrix object
d_mat = as.matrix(t(limma_res$voomObj$E))

# As before, we want this to be a factor
d_resp = as.factor(limma_res$voomObj$targets$definition)

# Divide data into training and testing set

# Set (random-number-generator) seed so that results are consistent between runs
set.seed(42)
train_ids = createDataPartition(d_resp, p=0.75, list=FALSE)

x_train = d_mat[train_ids, ]
x_test  = d_mat[-train_ids, ]

y_train = d_resp[train_ids]
y_test  = d_resp[-train_ids]

# Train model on training dataset using cross-validation
res = cv.glmnet(
  x = x_train,
  y = y_train,
  alpha = 0.5,
  family = "binomial"
)


# Test/Make prediction on test dataset
y_pred = predict(res, newx=x_test, type="class", s="lambda.min")

confusion_matrix = table(y_pred, y_test)

# Evaluation statistics
print(confusion_matrix)

print(paste0("Sensitivity: ",sensitivity(confusion_matrix)))

print(paste0("Specificity: ",specificity(confusion_matrix)))

print(paste0("Precision: ",precision(confusion_matrix)))

# Getting genes that contribute for the prediction
res_coef = coef(res, s="lambda.min") # the "coef" function returns a sparse matrix
dim(res_coef)

head(res_coef) # in a sparse matrix the "." represents the value of zero

# get coefficients with non-zero values
res_coef = res_coef[res_coef[,1] != 0,]
# note how performing this operation changed the type of the variable
head(res_coef)

# remove first coefficient as this is the intercept, a variable of the model itself
res_coef = res_coef[-1]

relevant_genes = names(res_coef) # get names of the (non-zero) variables.
length(relevant_genes) # number of selected genes

head(relevant_genes) # few select genes
head(limma_res$voomObj$genes)
relevant_gene_names = limma_res$voomObj$genes[relevant_genes,"external_gene_name"]

head(relevant_gene_names) # few select genes (with readable names now)

#check the common genes between limma and Elastic Net results
print(intersect(limma_res$topGenes$ensembl_gene_id, relevant_genes))
#only two XD

##draw hierarchical clusterin
# define the color palette for the plot
hmcol = colorRampPalette(rev(brewer.pal(9, "RdBu")))(256)

# perform complete linkage clustering
clust = function(x) hclust(x, method="complete")
# use the inverse of correlation as distance.
dist = function(x) as.dist((1-cor(t(x)))/2)

# Show green color for genes that also show up in DE analysis
colorLimmaGenes = ifelse(
  # Given a vector of boolean values
  (relevant_genes %in% limma_res$topGenes$ensembl_gene_id),
  "green", # if true, return green for that value
  "white" # if false, return white for that value
)

# As you've seen a good looking heatmap involves a lot of parameters
gene_heatmap = heatmap.2(
  t(d_mat[,relevant_genes]),
  scale="row",          # scale the values for each gene (row)
  density.info="none",  # turns off density plot inside color legend
  trace="none",         # turns off trace lines inside the heat map
  col=hmcol,            # define the color map
  labRow=relevant_gene_names, # use gene names instead of ensembl annotation
  RowSideColors=colorLimmaGenes,
  labCol=FALSE,         # Not showing column labels
  ColSideColors=as.character(as.numeric(d_resp)), # Show colors for each response class
  dendrogram="both",    # Show dendrograms for both axis
  hclust = clust,       # Define hierarchical clustering method
  distfun = dist,       # Using correlation coefficient for distance function
  cexRow=.6,            # Resize row labels
  margins=c(1,5)        # Define margin spaces
)


#----Gene expression and survival
# let's extract the table of differential expression we got earlier
expr_df = limma_res$topGenes

# print the first row, to see the gene name, the logFC value and the p-value
print(expr_df[1, ])

# get the ensembl gene id of the first row
gene_id = expr_df[1, "ensembl_gene_id"]

# also get the common gene name of the first row
gene_name = expr_df[1, "external_gene_name"]

# we now have selected a gene.
# visualize the gene expression distribution on the diseased samples (in black)
# versus the healthy samples (in red)

expr_diseased = d_mat[rownames(clin_df), gene_id]
expr_healthy = d_mat[setdiff(rownames(d_mat), rownames(clin_df)), gene_id]

boxplot(expr_diseased, expr_healthy,
        names=c("Diseased", "Healthy"), main="Distribution of gene expression")        

# get the expression values for the selected gene
clin_df$gene_value = d_mat[rownames(clin_df), gene_id]


# find the median value of the gene and print it
median_value = median(clin_df$gene_value)
print(median_value)

# divide patients in two groups, up and down regulated.
# if the patient expression is greater or equal to them median we put it
# among the "up-regulated", otherwise among the "down-regulated"
clin_df$gene = ifelse(clin_df$gene_value >= median_value, "UP", "DOWN")


# create a new boolean variable that has TRUE for dead patients
# and FALSE for live patients
clin_df$deceased = clin_df$vital_status == "Dead"

# create an "overall survival" variable that is equal to days_to_death
# for dead patients, and to days_to_last_follow_up for patients who
# are still alive
clin_df$overall_survival = ifelse(clin_df$deceased,
                                  clin_df$days_to_death,
                                  clin_df$days_to_last_follow_up)

# we can fit a survival model, like we did in the previous section
fit = survfit(Surv(overall_survival, deceased) ~ gene, data=clin_df)

# we can extract the survival p-value and print it
pval = surv_pvalue(fit, data=clin_df)$pval
print(pval)

# and finally, we produce a Kaplan-Meier plot
ggsurvplot(fit, data=clin_df, pval=T, risk.table=T, title=paste(gene_name))
###those pval more than 0.05, the gene does not appear to make a differnce for prognosis


##################################
table(clin_df$paper_Reviewed_Gleason_category)
table(clin_df$gene_value)
colnames(clin_df)

sfit = survfit(Surv(overall_survival, paper_Reviewed_Gleason_category == ">=8") ~ gene, data=clin_df)
print(sfit)
ggsurvplot(sfit, data=clin_df, pval=T, risk.table=T, title="paper_Reviewed_Gleason_category")
sfit <- coxph(Surv(overall_survival, paper_Reviewed_Gleason == "4+5") ~ gene, data=clin_df)
sfit
ggsurvplot(sfit, data=clin_df, pval=T, risk.table=T, title=paste(gene_name))

cor(clin_df$paper_Reviewed_Gleason_category,clin_df$gene_value, method = "pearson")
inpF <-"L:/Animesh/Zahoor/CoMMpass_IA8b.txt"
dataG <- read.delim(inpF,row.names=1,sep="\t",header = T)
#attach(data)
summary(dataG)
factorS=names(data)[grep("MMRF", names(data))]
plot(sqrt(as.matrix(dataG)))
devtools::install_github("rstudio/rstudioapi")
library('rstudioapi')
rstudioapi::getThemeInfo()
library(devtools)
install_github('jdrudolph/perseusr')
BiocInstaller::biocLite("checkmate")
library(WGCNA)
allowWGCNAThreads()
memory.limit(size = 256000000)
```

```{r clust}
biocLite("multiClust")
biocLite("dendextend")
library("dendextend")
library("multiClust")
?multiClust
```

```{r coxph}
inpF <-"L:/Animesh/Zahoor/CoMMpass_IA8b.txt"
dataG <- read.delim(inpF,row.names=1,sep="\t",header = T)
summary(dataG)
factorS = names(data)[grep("MMRF", names(data))]
library(survival)
?coxph
inpC <- "L:/Animesh/Zahoor/Compass_Survival.txt"
dataC <- read.delim(inpC, row.names = 1, sep = "\t", header = T)
dataNorm = log2(dataG[, grep("MMRF", names(dataG))] + 1)
summary(dataNorm$MMRF_1021)
hist(dataNorm$MMRF_1021)
factor(dataC$censpfs)
summary(factor(dataC$censpfs))
factorC = rownames(data)[grep("MMRF", names(data))]
resEfsByDis <- coxph(Surv(dataC$ttcpfs, dataC$censpfs) ~ ., data.frame(t(dataNorm)))
```

```{r condition}
expRt <- rep(0:10, each=5)
facR <- factor(expRt) 
Subject <- rep(1:5,time=11)
expR <- rnorm(55, mean=40, sd=5)
df <- data.frame(Subject, expR, expRt)
pairwise.t.test(expR, expRt,p.adj = "none")
#https://stackoverflow.com/questions/27834627/how-to-produce-an-anova-matrix-with-r
```


```{r condition}
library(survival)
#library(cmprsk)
inpC <-"L:/Animesh/Zahoor/Compass_Survival.txt"
dataC <- read.delim(inpC,row.names=1,sep="\t",header = T)
factor(dataC$censpfs)
summary(factor(dataC$censpfs))
factorC=rownames(data)[grep("MMRF", names(data))]
#plot(data)
resEfsByDis <- coxph(Surv(dataC$ttcpfs, dataC$censpfs) ~ . , data.frame(t(dataNorm)))
                       type      = "kaplan-meier",
                       error     = "greenwood",
                       conf.type = "log-log")
install.packages('rms')
library(rms)
rms::survplot(resEfsByDis)
summary(resEfsByDis)
#https://rpubs.com/kaz_yos/cmprsk2
resEfsCoxByDis <- coxph(formula = Surv(dataC$ttcpfs, dataC$censpfs != 1) ~ data=dataC,ties    = c("efron","breslow","exact")[1])
summary(resEfsCoxByDis)
```

```{r condition}
factors=strsplit(names(data)[grep("MMRF", names(data))],"[._]")
factorS=sapply(factors, '[[', 5)
factorS=gsub('[[:digit:]]+', '', factorS)
factorC=sapply(factors, '[[', 7) 
```

```{r TT}
#plot(log2(data[,grep("Ratio.H.L.normalized.", names(data))]))
dataNorm=log2(dataG[,grep("Ratio.H.L.normalized.", names(data))])
dataNorm=log2(dataG[,grep("MMRF", names(dataG))]+1)
summary(dataNorm$MMRF_1021)
hist(dataNorm$MMRF_1021)
#summary(anova(lm(as.numeric(dataNorm[2,])~factorC*factorS)))
#aov((as.numeric(dataNorm[2,])~factorC*factorS))
#TukeyHSD(aov((as.numeric(dataNorm[2,])~factorC*factorS)))
tc=1
tcold=tc
tc=apply(dataNorm,1,function(x){
#tc=apply(dataNorm, 1, function(x) 
  tryCatch(TukeyHSD(aov(x~factorC*factorS),"factorC:factorS", ordered = TRUE),error=function(x){return(rep(1,15))})})
wval=t(sapply(names(tc),function(x){tryCatch(tc[[x]]$`factorC:factorS`[46:60],error=function(x){return(rep(1,15))})}))
tc$`E5RIU6;A0A087WZZ9;A0A024QZP7;P06493;P06493-2;K7ELV5;Q00526;F8VXD2;F8VYH9;F8VZZ0;F8VTV8;F8VWX7;F8VZ51;K7EJ83;H0YAZ9;Q9BVE2;E7EUK8;E5RGN0;A0A087X209;A0A087WZU2;F5H6Z0;P11802-2;P11802;Q96Q40-2;Q96Q40-4;Q96Q40-3;O94921-3;Q96Q40-5;Q96Q40;O94921-2;O94921;Q07002;Q07002-2;Q00536;Q00536-3;Q07002-3;Q00537-2;Q00537;Q00536-2;Q14004-2;Q14004`
dataNorm[grep("F7A",row.names(data)),]
#try(TukeyHSD(aov((x~factorC*factorS)))))
tcold$`A0A087WNP6;Q4VAA2-2;Q4VAA2;A0A087WRM0;F8WGL9;A0A087WS49`
plot(tc$`A0A087WNP6;Q4VAA2-2;Q4VAA2;A0A087WRM0;F8WGL9;A0A087WS49`)
?aov
```

```{r ANOVA}
#https://stats.stackexchange.com/questions/89021/how-to-get-only-desirable-comparisons-from-post-hoc
#plot(log2(data[,grep("Ratio.H.L.normalized.", names(data))]))
dataNorm=log2(data[,grep("Ratio.H.L.normalized.", names(data))])
summary(dataNorm)
#summary(anova(lm(as.numeric(dataNorm[2,])~factorC*factorS)))
#aov((as.numeric(dataNorm[2,])~factorC*factorS))
#TukeyHSD(aov((as.numeric(dataNorm[2,])~factorC*factorS)))
tc=1
tcold=tc
tc=apply(dataNorm,1,function(x){
#tc=apply(dataNorm, 1, function(x) 
  tryCatch(TukeyHSD(aov(x~factorC*factorS),"factorC:factorS", ordered = TRUE),error=function(x){return(rep(1,15))})})
wval=t(sapply(names(tc),function(x){tryCatch(tc[[x]]$`factorC:factorS`[46:60],error=function(x){return(rep(1,15))})}))
tc$`E5RIU6;A0A087WZZ9;A0A024QZP7;P06493;P06493-2;K7ELV5;Q00526;F8VXD2;F8VYH9;F8VZZ0;F8VTV8;F8VWX7;F8VZ51;K7EJ83;H0YAZ9;Q9BVE2;E7EUK8;E5RGN0;A0A087X209;A0A087WZU2;F5H6Z0;P11802-2;P11802;Q96Q40-2;Q96Q40-4;Q96Q40-3;O94921-3;Q96Q40-5;Q96Q40;O94921-2;O94921;Q07002;Q07002-2;Q00536;Q00536-3;Q07002-3;Q00537-2;Q00537;Q00536-2;Q14004-2;Q14004`
dataNorm[grep("F7A",row.names(data)),]
#try(TukeyHSD(aov((x~factorC*factorS)))))
tcold$`A0A087WNP6;Q4VAA2-2;Q4VAA2;A0A087WRM0;F8WGL9;A0A087WS49`
plot(tc$`A0A087WNP6;Q4VAA2-2;Q4VAA2;A0A087WRM0;F8WGL9;A0A087WS49`)
```


```{r write-output}
write.table(wval,outF,sep="\t")
tc
write.table(t(tc),sep = "\t")
outF = paste0(inpF,"anovaTukey.txt")
class(tc)
names(tc)
do.call(rbind, lapply(names(tc), function(x) data.frame(c(ID=x, tc$x$`factorC:factorS`))))
lapply(names(tc), function(x) write.table(t(t(tcold[[x]]$`factorC:factorS`)[4,]),outF,sep = "\t"))
write.table(t(sapply(tc, 
                     function(x){tryCatch(x$`factorC:factorS`)})),sep="\t")
#function(x){tryCatch(x$`factorC:factorS`,error=function(x){return(NULL)})})),outF,sep="\t")
write.table(t(t(tc$x$`factorC:factorS`)[4,]),sep = "\t")
write.table(t(t(tc$`A0A087WNP6;Q4VAA2-2;Q4VAA2;A0A087WRM0;F8WGL9;A0A087WS49`$`factorC:factorS`)[4,]),sep = "\t")
dump(tc, file=outF)
```

```{r prot}
source("https://bioconductor.org/biocLite.R")
biocLite("PGA")
library("PGA")
biocLite("XML")
biocLite("colorspace")
install.packages("Rcpp")
library("PGA")
dat_file <- system.file("extdata/input", "mascot.dat",package = "PGA")
parserGear(file = dat_file, db = dbfile, decoyPrefix = "#REV#",xmx = 1,thread = 8,outdir = "parser_outdir_mascot")

```

```{r ir}
i=0.9
n=1
y1<-0
y2<-0

for(x1 in seq(0.1, 10, 0.5)){
  for(x2 in seq(0.1, 10, 0.5)){
    y1<-c(((1-i)*n+x1)/((1-i)*n+x2),y1)
    y2<-c(x1/x2,y2)
  }
}
plot(log2(y1),log2(y2))
plot((y1),(y2))

```


```{r MSstats}
source("http://www.bioconductor.org/biocLite.R")
biocLite('GOpro')
library(GOpro)
biocLite('GOSim')
library(GOSim)
genes=c("207","208","596","901","780","3169","9518","2852","26353","8614","7494")
getGOInfo(genes)
biocLite("RTopper")
library(RTopper)
biocLite("PGA")
biocLite("rTANDEM")
biocLite("BSgenome.Hsapiens.UCSC.hg19")
vcffile <- system.file("extdata/input", "PGA.vcf",package="PGA")
bedfile <- system.file("extdata/input", "junctions.bed",package="PGA")
gtffile <- system.file("extdata/input", "transcripts.gtf",package="PGA")
annotation <- system.file("extdata", "annotation",package="PGA")
outfile_path<-"db/"
outfile_name<-"test"
library(BSgenome.Hsapiens.UCSC.hg19)
dbfile <- dbCreator(gtfFile=gtffile,vcfFile=vcffile,bedFile=bedfile,
                    annotation_path=annotation,outfile_name=outfile_name,
                    genome=Hsapiens,outdir=outfile_path)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jdk1.8.0_45\\jre\\')
parserGear("F:/promec/Gygi/b1906_293T_proteinID_01A_QE3_122212.pep.xml", db = dbfile, decoyPrefix="#REV#",xmx = 1,thread = 8,outdir = "parser_outdir")
```

```{r MSstats}
#https://bioconductor.org/packages/3.3/bioc/vignettes/MSstats/inst/doc/MSstats-manual.pdf
library('MSstats')
QuantData<-dataProcess(SRMRawData)
head(QuantData$ProcessedData)
## based on multiple comparisons (T1 vs T3; T1 vs T7; T1 vs T9)
comparison1<-matrix(c(-1,0,1,0,0,0,0,0,0,0),nrow=1)
comparison2<-matrix(c(-1,0,0,0,0,0,1,0,0,0),nrow=1)
comparison3<-matrix(c(-1,0,0,0,0,0,0,0,1,0),nrow=1)
comparison<-rbind(comparison1,comparison2, comparison3)
row.names(comparison)<-c("T3-T1","T7-T1","T9-T1")
testResultMultiComparisons<-groupComparison(contrast.matrix=comparison,data=QuantData)
## Calculate sample size for future experiments:
#(1) Minimal number of biological replicates per condition
designSampleSize(data=testResultMultiComparisons$fittedmodel,numSample=TRUE,
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
#(2) Power calculation
designSampleSize(data=testResultMultiComparisons$fittedmodel,numSample=2,
desiredFC=c(1.25,1.75),FDR=0.05,power=TRUE)```
```

```{r SAM}
#https://github.com/MikeJSeo/SAM
install.packages(c("samr", "matrixStats", "GSA", "shiny", "shinyFiles", "openxlsx"))
source("http://bioconductor.org/biocLite.R")
biocLite("impute")
library(shiny)
library(shinyFiles)
runGitHub("SAM", "MikeJSeo")
```



```{r pkgs}
install.packages('BEST') #http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3489534/
library('BEST') #https://sourceforge.net/projects/mcmc-jags
install.packages('mice') #http://www.helsinki.fi/~rosenstr/papers/ImputationNotes.pdf
library('mice') #http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/
install.packages('RColorBrewer')
library(RColorBrewer)
source("http://bioconductor.org/biocLite.R")
biocLite("preprocessCore")
library('preprocessCore')
#install.packages("gplots")
# library(gplots) 
#library(ggplot2)
```

```{r JAGS}
y1 <- c(5.77, 5.33, 4.59, 4.33, 3.66, 4.48)
y2 <- c(3.88, 3.55, 3.29, 2.59, 2.33, 3.59)
priors <- list(muM = 6, muSD = 2)
out <- BESTmcmc(y1, y2, priors=priors, parallel=FALSE) # where def prior sigmaMode = sd(y), sigmaSD = sd(y)*5, nuMean = 30, nuSD = 30), y = c(y1, y2).
plot(out)
plot(y1,y2)
summary(t.test(y1,y2))
hist(y2)
hist(datasel)
```

```{r Cluster}
colscl <- colorRampPalette(c("darkblue", "chocolate"), space = "rgb")(100)
heatmap(na.omit(as.matrix(data)),col=colscl)
```

```{r ColumnSel}
datasel<-data[, grep("^Tumor_*", colnames(data))]
summary(datasel)
t.test(datasel)
datanonan=na.omit(as.matrix(datasel))
summary(datanonan)
heatmap(na.omit(as.matrix(datasel)),col=colscl)
```

```{r NA}
#impute(data, method = "mixed",randna = fData(naset)$randna,mar = "knn", mnar = "min")
md.pattern(datasel)
dataimp <- mice(datasel,m=length(colnames(datasel))/2,maxit=length(colnames(datasel)),meth='pmm',seed=1)
dataimp <- complete(dataimp,length(colnames(datasel))/2)
heatmap(as.matrix(dataimp),col=colscl)
```

```{r Scale}
datascale=t(scale(t(dataimp))) # takes away the polynomial in YFP data
heatmap(as.matrix(datascale),col=colscl)
```

```{r DistCor}
dataasmat<-data.matrix(datascale)
cor(data)
dissimilarityc <- 1 - cor(dataasmat,method = "s")
distancec <- as.dist(dissimilarityc)
col.clus <- hclust(distancec, "aver")
dissimilarityr <- 1 - cor(t(dataasmat),method = "s")
distancer <- as.dist(dissimilarityr)
row.clus <- hclust(distancer, "aver")
heatmap(as.matrix(datascale),col=colscl)
cr <- rainbow(nrow(dataasmat))
cc <- rainbow(ncol(dataasmat))
heatmap((na.omit(dataasmat)), RowSideColors = cr, ColSideColors = cc,Rowv = as.dendrogram(row.clus), Colv = as.dendrogram(col.clus),cexRow=1.5,cexCol=1.5 )
```

```{r face}
#http://www.r-bloggers.com/analyze-face-emotions-with-r/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29

library("httr")
library("XML")
library("stringr")
library("ggplot2")

img.url     = 'https://i.imgur.com/Njtw8tx.jpg'
URL.emoface = 'https://api.projectoxford.ai/emotion/v1.0/recognize'
emotionKEY = '25eac991d0c8474fb501d704c6454b05'
mybody = list(url = img.url)
faceEMO = POST(
  url = URL.emoface,
  content_type('application/json'), add_headers(.headers = c('Ocp-Apim-Subscription-Key' = emotionKEY)),
  body = mybody,
  encode = 'json'
)
faceEMO
trump = httr::content(faceEMO)[[1]]
trump
o<-as.data.frame(as.matrix(trump$scores))
o$V1 <- lapply(strsplit(as.character(o$V1 ), "e"), "[", 1)
o$V1<-as.numeric(o$V1)
colnames(o)[1] <- "Level"
o$Emotion<- rownames(o)
ggplot(data=o, aes(x=Emotion, y=Level)) +
  geom_bar(stat="identity")

img.url = 'https://www.whitehouse.gov/sites/whitehouse.gov/files/images/first-family/44_barack_trump[1].jpg'
faceURL = "https://api.projectoxford.ai/face/v1.0/detect?returnFaceId=true&returnFaceLandmarks=true&returnFaceAttributes=age"
mybody = list(url = img.url)
faceKEY = '6b86f25e09e84291b2bcba8d61d6297e'
faceResponse = POST(
  url = faceURL, 
  content_type('application/json'), add_headers(.headers = c('Ocp-Apim-Subscription-Key' = faceKEY)),
  body = mybody,
  encode = 'json'
)

# Show request results (if Status=200, request is okay)
faceResponse

# Reuqest results from face analysis
trumpR = httr::content(faceResponse)[[1]]

# Define results in data frame
OR<-as.data.frame(as.matrix(trumpR$faceLandmarks))

# Make some transformation to data frame
OR$V2 <- lapply(strsplit(as.character(OR$V1), "\\="), "[", 2)
OR$V2 <- lapply(strsplit(as.character(OR$V2), "\\,"), "[", 1)
colnames(OR)[2] <- "X"
OR$X<-as.numeric(OR$X)

OR$V3 <- lapply(strsplit(as.character(OR$V1), "\\y = "), "[", 2)
OR$V3 <- lapply(strsplit(as.character(OR$V3), "\\)"), "[", 1)
colnames(OR)[3] <- "Y"
OR$Y<-as.numeric(OR$Y)

OR$V1<-NULL
```

```{r Quantile}
dataasmat<-normalize.quantiles(dataasmat)
rn<-rownames(dataasmat)
cn<-colnames(dataasmat)
colnames(dataasmat)<-cn
rownames(dataasmat)<-rn
```

```{r AdjPval}
p.adjust(10^(-data$X.log10P),method = c("hochberg"), n = length(data$X.log10P))
p.adjust(data$pv,method = c("hochberg"), n = length(data$pv))
```

```{r, echo=FALSE}
p <- ggplot(data)
print(p)
#heatmap2(data)
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
---
title: "batch-effect-analysis"
author: "Ani"
date: "Monday, Feb 15, 2016"
output: html_document
---
<http://rmarkdown.rstudio.com>.

=======
```{r interpolate}
data<-read.table("c:/Users/animeshs/Downloads/Sunshine hours.txt",sep='\t',header=T)
summary(data$SONNENSCHEINDAUER)
dp=approx(data$SONNENSCHEINDAUER)
summary(dp)
plot(dp$SONNENSCHEINDAUER,data$SONNENSCHEINDAUER)
install.packages('zoo')
library('zoo')
dp<-rollmean(data,1)
dp<-na.approx(data)
summary(dp)
write.table(dp,"c:/Users/animeshs/Downloads/SunshineDP.txt",sep='\t')
```

```{r iPondData}
iPond=read.delim("f:/promec/Elite/Karine/170216_IP/dePep/Log2LFQproteinGroupsBHtTests2wayANOVA.txt",row.names = 48,header=T)
#[,190:213]
label=t(read.delim("Y:/felles/PROTEOMICS and XRAY/Ani/Kristian/Groups.txt",row.names = 1,header=T))
```

```{r corr3ction}
hist(iPond$M..Two.way.ANOVA.p.value.Interaction)
hist(p.adjust(iPond$M..Two.way.ANOVA.p.value.Interaction,method = "BH"))
hist((p.adjust(iPond$M..Two.way.ANOVA.p.value.Cond,method = "BH")))
hist(log2(p.adjust(iPond$M..Two.way.ANOVA.p.value.Treatment,method = "BH")))
write.table(p.adjust(iPond$M..Two.way.ANOVA.p.value.Interaction,method = "BH"), "f:/promec/Elite/Karine/170216_IP/dePep/Log2LFQproteinGroupsBHtTests2wayANOVAbhInt.txt", sep="\t")
write.table(p.adjust(iPond$M..Two.way.ANOVA.p.value.Treatment,method = "BH"), "f:/promec/Elite/Karine/170216_IP/dePep/Log2LFQproteinGroupsBHtTests2wayANOVAbhTr.txt", sep="\t")
write.table(p.adjust(iPond$M..Two.way.ANOVA.p.value.Cond,method = "BH"), "f:/promec/Elite/Karine/170216_IP/dePep/Log2LFQproteinGroupsBHtTests2wayANOVAbhCond.txt", sep="\t")

```


```{r data}
#data <- read.delim("Y:/felles/PROTEOMICS and XRAY/Articles in prep/AID/ID/AIDberitPD21SequestScoreTtestRcomp.txt",sep="\t",row.names=1, header = T) #AIDome
#data <- read.delim("F:/promec/Results/Ani/Mirta/DataActinNormalizedHeatMapCtrlwPCNA.txt",row.names=19,sep="\t",header = T) #BER
#data <- read.delim("F:/promec/Davi/Mei/2016-05_PancreaticCancer/QE/lfq2pep/LFQvalues.txt",row.names=90,sep="\t",header = T)
#data <- read.delim("Y:/felles/PROTEOMICS and XRAY/Ani/iPOND/batch1and2lfqaimpnovaTtest90C15P.txt",fill=T, row.names=86, sep = "\t",header = T)
#df <- read.delim("https://gist.githubusercontent.com/anonymous/0bc36ec5f46757de7c2c/raw/517ef70ab6a68e600f57308e045c2b4669a7abfc/example.txt", header=TRUE, row.names=1, sep="\t")
#df<-df[df$Potential.contaminant!='+',] 
data <- read.delim("Y:/felles/PROTEOMICS and XRAY/Ani/iPOND/batch1and2lfqaimpnovaTtest90C15Pr.txt",sep = "\t",header = T)


summary(data)
t.test(data[1,3:5],data[1,6:8],data[1,9:11])
t.test(data[1,3:5],data[1,6:8])

```

```{r lmfit}
source("https://bioconductor.org/biocLite.R")
biocLite("golubEsets")
library(golubEsets)
data()
data(golubTrain)
golubTrain
golub<-data.frame(golubTrain@exprs)
labelgb <- factor(c(rep("ALL",27),rep("AML",11)))
names(golub) <- labelgb
golub2<-log2(golub)
plot(golub2)
biocLite('limma')
library('limma')
fit3 = lmFit(golub2)
e3 = eBayes(fit3)
tab3<-topTable(e3, number=nrow(golub))
head(tab3)
fit3@.Data[[9]]
fit4 = lmFit(golub2, design)
```


```{r shuffle}
ecoli <- read.delim("Y:/felles/PROTEOMICS and XRAY/Ani/Christina/Strainssamples.txt", header=TRUE, na.strings='', sep="\t")
for  (cnt in 1:6){
  cnt
}
  ecoli_shuffle <- ecoli_shuffle[sample(nrow(ecoli)),]
write.csv(file="Y:/felles/PROTEOMICS and XRAY/Ani/Christina/Strainssamples_shuffled_rn.csv",x=ecoli_shuffle,row.names = F)
```
```{r rawread}
library("MSnbase")
```


```{r prot}
install.packages("PTXQC")
library("PTXQC")
help(package = "PTXQC")
vignette("PTXQC-InputData", package = "PTXQC")
txt_folder = "F:/promec/Elite/LARS/2016/desember/Lymphoma/Results"
r = createReport(txt_folder)
cat(paste0("\nReport generated as '", r$report_file, "'\n\n"))

```

```{r prot}
require(PTXQC)

## the next require() is needed to prevent a spurious error in certain R versions (mighyou be a bug in R or a package)
## error message is:
##    Error in Scales$new : could not find function "loadMethod"
require(methods)

## specify a path to a MaxQuant txt folder
## Note: This folder needs to be complete (see 'vignette("PTXQC-InputData", package = "PTXQC")')
if (1) {
  ## we will use an example dataset from PRIDE (dataset 2 of the PTXQC publication)
  local_zip = tempfile(fileext=".zip")
  download.file("ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2015/11/PXD003133/txt_20min.zip", destfile = local_zip)
  unzip(local_zip, exdir = tempdir()) ## extracts content
  txt_folder = paste0(tempdir(),"/txt_20min")
} else {
  ## if you have local MaxQuant output, just use it
  txt_folder = "c:/Proteomics/MouseLiver/combined/txt"
}

r = createReport(txt_folder)

cat(paste0("\nReport generated as '", r$report_file, "'\n\n"))

```


```{r prot}
source("https://bioconductor.org/biocLite.R")
biocLite("PGA")
library("PGA")
biocLite("XML")
biocLite("colorspace")
install.packages("Rcpp")
library("PGA")
dat_file <- system.file("extdata/input", "mascot.dat",package = "PGA")
parserGear(file = dat_file, db = dbfile, decoyPrefix = "#REV#",xmx = 1,thread = 8,outdir = "parser_outdir_mascot")

```

```{r ir}
i=0.9
n=1
y1<-0
y2<-0

for(x1 in seq(0.1, 10, 0.5)){
  for(x2 in seq(0.1, 10, 0.5)){
    y1<-c(((1-i)*n+x1)/((1-i)*n+x2),y1)
    y2<-c(x1/x2,y2)
  }
}
plot(log2(y1),log2(y2))
plot((y1),(y2))

```


```{r MSstats}
source("http://www.bioconductor.org/biocLite.R")
biocLite('GOpro')
library(GOpro)
biocLite('GOSim')
library(GOSim)
genes=c("207","208","596","901","780","3169","9518","2852","26353","8614","7494")
getGOInfo(genes)
biocLite("RTopper")
library(RTopper)
biocLite("PGA")
biocLite("rTANDEM")
biocLite("BSgenome.Hsapiens.UCSC.hg19")
vcffile <- system.file("extdata/input", "PGA.vcf",package="PGA")
bedfile <- system.file("extdata/input", "junctions.bed",package="PGA")
gtffile <- system.file("extdata/input", "transcripts.gtf",package="PGA")
annotation <- system.file("extdata", "annotation",package="PGA")
outfile_path<-"db/"
outfile_name<-"test"
library(BSgenome.Hsapiens.UCSC.hg19)
dbfile <- dbCreator(gtfFile=gtffile,vcfFile=vcffile,bedFile=bedfile,
                    annotation_path=annotation,outfile_name=outfile_name,
                    genome=Hsapiens,outdir=outfile_path)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jdk1.8.0_45\\jre\\')
parserGear("F:/promec/Gygi/b1906_293T_proteinID_01A_QE3_122212.pep.xml", db = dbfile, decoyPrefix="#REV#",xmx = 1,thread = 8,outdir = "parser_outdir")
```

```{r MSstats}
#https://bioconductor.org/packages/3.3/bioc/vignettes/MSstats/inst/doc/MSstats-manual.pdf
library('MSstats')
QuantData<-dataProcess(SRMRawData)
head(QuantData$ProcessedData)
## based on multiple comparisons (T1 vs T3; T1 vs T7; T1 vs T9)
comparison1<-matrix(c(-1,0,1,0,0,0,0,0,0,0),nrow=1)
comparison2<-matrix(c(-1,0,0,0,0,0,1,0,0,0),nrow=1)
comparison3<-matrix(c(-1,0,0,0,0,0,0,0,1,0),nrow=1)
comparison<-rbind(comparison1,comparison2, comparison3)
row.names(comparison)<-c("T3-T1","T7-T1","T9-T1")
testResultMultiComparisons<-groupComparison(contrast.matrix=comparison,data=QuantData)
## Calculate sample size for future experiments:
#(1) Minimal number of biological replicates per condition
designSampleSize(data=testResultMultiComparisons$fittedmodel,numSample=TRUE,
desiredFC=c(1.25,1.75),FDR=0.05,power=0.8)
#(2) Power calculation
designSampleSize(data=testResultMultiComparisons$fittedmodel,numSample=2,
desiredFC=c(1.25,1.75),FDR=0.05,power=TRUE)```
```

```{r SAM}
#https://github.com/MikeJSeo/SAM
install.packages(c("samr", "matrixStats", "GSA", "shiny", "shinyFiles", "openxlsx"))
source("http://bioconductor.org/biocLite.R")
biocLite("impute")
library(shiny)
library(shinyFiles)
runGitHub("SAM", "MikeJSeo")
```



```{r pkgs}
install.packages('BEST') #http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3489534/
library('BEST') #https://sourceforge.net/projects/mcmc-jags
install.packages('mice') #http://www.helsinki.fi/~rosenstr/papers/ImputationNotes.pdf
library('mice') #http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/
install.packages('RColorBrewer')
library(RColorBrewer)
source("http://bioconductor.org/biocLite.R")
biocLite("preprocessCore")
library('preprocessCore')
#install.packages("gplots")
# library(gplots) 
#library(ggplot2)
```

```{r JAGS}
y1 <- c(5.77, 5.33, 4.59, 4.33, 3.66, 4.48)
y2 <- c(3.88, 3.55, 3.29, 2.59, 2.33, 3.59)
priors <- list(muM = 6, muSD = 2)
out <- BESTmcmc(y1, y2, priors=priors, parallel=FALSE) # where def prior sigmaMode = sd(y), sigmaSD = sd(y)*5, nuMean = 30, nuSD = 30), y = c(y1, y2).
plot(out)
plot(y1,y2)
summary(t.test(y1,y2))
hist(y2)
hist(datasel)
```

```{r Cluster}
colscl <- colorRampPalette(c("darkblue", "chocolate"), space = "rgb")(100)
heatmap(na.omit(as.matrix(data)),col=colscl)
```

```{r ColumnSel}
datasel<-data[, grep("^Tumor_*", colnames(data))]
summary(datasel)
t.test(datasel)
datanonan=na.omit(as.matrix(datasel))
summary(datanonan)
heatmap(na.omit(as.matrix(datasel)),col=colscl)
```

```{r NA}
#impute(data, method = "mixed",randna = fData(naset)$randna,mar = "knn", mnar = "min")
md.pattern(datasel)
dataimp <- mice(datasel,m=length(colnames(datasel))/2,maxit=length(colnames(datasel)),meth='pmm',seed=1)
dataimp <- complete(dataimp,length(colnames(datasel))/2)
heatmap(as.matrix(dataimp),col=colscl)
```

```{r Scale}
datascale=t(scale(t(dataimp))) # takes away the polynomial in YFP data
heatmap(as.matrix(datascale),col=colscl)
```

```{r DistCor}
dataasmat<-data.matrix(datascale)
cor(data)
dissimilarityc <- 1 - cor(dataasmat,method = "s")
distancec <- as.dist(dissimilarityc)
col.clus <- hclust(distancec, "aver")
dissimilarityr <- 1 - cor(t(dataasmat),method = "s")
distancer <- as.dist(dissimilarityr)
row.clus <- hclust(distancer, "aver")
heatmap(as.matrix(datascale),col=colscl)
cr <- rainbow(nrow(dataasmat))
cc <- rainbow(ncol(dataasmat))
heatmap((na.omit(dataasmat)), RowSideColors = cr, ColSideColors = cc,Rowv = as.dendrogram(row.clus), Colv = as.dendrogram(col.clus),cexRow=1.5,cexCol=1.5 )
```

```{r face}
#http://www.r-bloggers.com/analyze-face-emotions-with-r/?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+RBloggers+%28R+bloggers%29

library("httr")
library("XML")
library("stringr")
library("ggplot2")

img.url     = 'https://i.imgur.com/Njtw8tx.jpg'
URL.emoface = 'https://api.projectoxford.ai/emotion/v1.0/recognize'
emotionKEY = '25eac991d0c8474fb501d704c6454b05'
mybody = list(url = img.url)
faceEMO = POST(
  url = URL.emoface,
  content_type('application/json'), add_headers(.headers = c('Ocp-Apim-Subscription-Key' = emotionKEY)),
  body = mybody,
  encode = 'json'
)
faceEMO
trump = httr::content(faceEMO)[[1]]
trump
o<-as.data.frame(as.matrix(trump$scores))
o$V1 <- lapply(strsplit(as.character(o$V1 ), "e"), "[", 1)
o$V1<-as.numeric(o$V1)
colnames(o)[1] <- "Level"
o$Emotion<- rownames(o)
ggplot(data=o, aes(x=Emotion, y=Level)) +
  geom_bar(stat="identity")

img.url = 'https://www.whitehouse.gov/sites/whitehouse.gov/files/images/first-family/44_barack_trump[1].jpg'
faceURL = "https://api.projectoxford.ai/face/v1.0/detect?returnFaceId=true&returnFaceLandmarks=true&returnFaceAttributes=age"
mybody = list(url = img.url)
faceKEY = '6b86f25e09e84291b2bcba8d61d6297e'
faceResponse = POST(
  url = faceURL, 
  content_type('application/json'), add_headers(.headers = c('Ocp-Apim-Subscription-Key' = faceKEY)),
  body = mybody,
  encode = 'json'
)

# Show request results (if Status=200, request is okay)
faceResponse

# Reuqest results from face analysis
trumpR = httr::content(faceResponse)[[1]]

# Define results in data frame
OR<-as.data.frame(as.matrix(trumpR$faceLandmarks))

# Make some transformation to data frame
OR$V2 <- lapply(strsplit(as.character(OR$V1), "\\="), "[", 2)
OR$V2 <- lapply(strsplit(as.character(OR$V2), "\\,"), "[", 1)
colnames(OR)[2] <- "X"
OR$X<-as.numeric(OR$X)

OR$V3 <- lapply(strsplit(as.character(OR$V1), "\\y = "), "[", 2)
OR$V3 <- lapply(strsplit(as.character(OR$V3), "\\)"), "[", 1)
colnames(OR)[3] <- "Y"
OR$Y<-as.numeric(OR$Y)

OR$V1<-NULL
```

```{r Quantile}
dataasmat<-normalize.quantiles(dataasmat)
rn<-rownames(dataasmat)
cn<-colnames(dataasmat)
colnames(dataasmat)<-cn
rownames(dataasmat)<-rn
```

```{r AdjPval}
p.adjust(10^(-data$X.log10P),method = c("hochberg"), n = length(data$X.log10P))
p.adjust(data$pv,method = c("hochberg"), n = length(data$pv))
```

```{r, echo=FALSE}
p <- ggplot(data)
print(p)
#heatmap2(data)
```


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
---
title: "batch-effect-analysis"
author: "Ani"
date: "Monday, Feb 15, 2016"
output: html_document
---
<http://rmarkdown.rstudio.com>.

>>>>>>> ebfc112f27001e13d78ab738e1c0e1a49f30d70e

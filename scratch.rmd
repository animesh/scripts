```{r setup, echo = FALSE}
#lib
libPaths="C:/Users/animeshs/GD/libR"
libPaths="L:/promec/Animesh/R/win-library/4.0"
.libPaths(c(libPaths, .libPaths()))
#C:\Program Files\Microsoft\R Open\R-4.0.2\bin\Rscript.exe
#F:\GD\tools\aovPerseusR\proteinGroupsANOVA.r
#Abundances \(Normalized\): F(.*): Sample
#install.packages("readxl")
#install.packages("remotes")
#remotes::install_version("rlang","0.4.10", repos = "http://cran.us.r-project.org")
#install.packages("RcppEigen")
#PATH="${RTOOLS40_HOME}\usr\bin;${PATH}"
#writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
## "C:\\rtools40\\usr\\bin\\make.exe"
#remotes::install_version("xfun","0.19", repos = "http://cran.us.r-project.org")
#plot
#renv::deactivate()
#plot
par(mfrow=c(1,2))
#setwd("L:/GD/scripts")
getwd()
#grep "pathview" *.rmd | awk -F ':' '{print $1}' | sort | uniq -c
#rm(list = ls())
#detach("package:pathview", unload=TRUE)
#https://mran.microsoft.com/documents/rro/multithread#mt-setget
#setMKLthreads(<value>)
#https://htmlpreview.github.io/?https://github.com/lixzhang/R-MRO-MRS/blob/master/Introduction_to_MRO_and_MRS.html
getMKLthreads()
# Initialization
set.seed (1)
m <- 10000
n <-  5000
A <- matrix (runif (m*n),m,n)
plot(A)
# Matrix multiply
system.time (B <- crossprod(A))
plot(B)
```
```{r 4.1}
#https://towardsdatascience.com/ten-awesome-recent-developments-in-r-6bfad46299a0
mtcars |> lapply(\(x) mean(x) > 20)
```

```{r sumGO}
#https://bioconductor.org/packages/release/bioc/vignettes/GOsummaries/inst/doc/GOsummaries-basics.pdf
#BiocManager::install("GOsummaries")
genes1 = c("203485_at", "209469_at", "209470_s_at", "203999_at")
genes2 = c("201890_at", "202503_s_at", "204170_s_at", "201291_s_at")
gl = list(List = list(genes1, genes1)) # Two lists per component
gs = GOsummaries::gosummaries(gl)
plot(gs, fontsize = 8, filename = "figure2.pdf")
```

```{r multiEnrich}
#https://bioconductor.org/packages/release/bioc/vignettes/multiGSEA/inst/doc/multiGSEA.html#tab:resultTable
BiocManager::install("multiGSEA")
library( "org.Hs.eg.db")
library( multiGSEA)
library( magrittr)
data( transcriptome)
data( proteome)
data( metabolome)
omics_data <- initOmicsDataStructure( layer = c("transcriptome", 
                                                "proteome",
                                                "metabolome"))
omics_data$transcriptome <- rankFeatures( transcriptome$logFC, 
                                          transcriptome$pValue)
names( omics_data$transcriptome) <- transcriptome$Symbol
omics_data$proteome <- rankFeatures(proteome$logFC, proteome$pValue)
names( omics_data$proteome) <- proteome$Symbol
omics_data$metabolome <- rankFeatures(metabolome$logFC, metabolome$pValue)
names( omics_data$metabolome) <- metabolome$HMDB
names( omics_data$metabolome) <- gsub( "HMDB", "HMDB00", 
                                       names( omics_data$metabolome))
omics_short <- lapply( names( omics_data), function( name){ 
                        head( omics_data[[name]])
                      })
names( omics_short) <- names( omics_data)
omics_short
databases <- c( "kegg", "reactome")
layers <- names( omics_data)
pathways <- getMultiOmicsFeatures( dbs = databases, layer = layers,
                                   returnTranscriptome = "SYMBOL",
                                   returnProteome = "SYMBOL",
                                   returnMetabolome = "HMDB",
                                   useLocal = FALSE)
pathways_short <- lapply( names( pathways), function( name){
                          head( pathways[[name]], 2)
                        })
names( pathways_short) <- names( pathways)
pathways_short
enrichment_scores <- multiGSEA( pathways, omics_data)
df <- extractPvalues( enrichmentScores = enrichment_scores,
                      pathwayNames = names( pathways[[1]]))
df$combined_pval <- combinePvalues( df)
df$combined_padj <- p.adjust( df$combined_pval, method = "BH")
df <- cbind( data.frame( pathway = names( pathways[[1]])), df)
```

```{r mlr}
#https://mlr3.mlr-org.com/
#install.packages("mlr3verse")
library(mlr3)
install.packages("palmerpenguins")
# create learning task
task_penguins <- TaskClassif$new(id = "penguins", backend = palmerpenguins::penguins, target = "species")
learner <- lrn("classif.rpart", cp = .01)
# train/test split
train_set <- sample(task_penguins$nrow, 0.8 * task_penguins$nrow)
test_set <- setdiff(seq_len(task_penguins$nrow), train_set)

# train the model
learner$train(task_penguins, row_ids = train_set)

# predict data
prediction <- learner$predict(task_penguins, row_ids = test_set)

# calculate performance
prediction$confusion
measure <- msr("classif.acc")
prediction$score(measure)
## classif.acc 
##   0.9130435
Resample
# automatic resampling
resampling <- rsmp("cv", folds = 3L)
rr <- resample(task_penguins, learner, resampling)
rr$score(measure)
##                 task  task_id                   learner    learner_id
## 1: <TaskClassif[46]> penguins <LearnerClassifRpart[34]> classif.rpart
## 2: <TaskClassif[46]> penguins <LearnerClassifRpart[34]> classif.rpart
## 3: <TaskClassif[46]> penguins <LearnerClassifRpart[34]> classif.rpart
##            resampling resampling_id iteration              prediction
## 1: <ResamplingCV[19]>            cv         1 <PredictionClassif[19]>
## 2: <ResamplingCV[19]>            cv         2 <PredictionClassif[19]>
## 3: <ResamplingCV[19]>            cv         3 <PredictionClassif[19]>
##    classif.acc
## 1:   0.8956522
## 2:   0.9130435
## 3:   0.9473684
rr$aggregate(measure)
```

```{r einsum}
#https://const-ae.github.io/einsum/index.html
#install.packages("einsum")
devtools::install_github("const-ae/einsum")
```
```{r}
devtools::install_github("prafols/rMSIproc")
```

```{r table}
install.packages("DT")
library(DT)
datatable(iris)
```

```{r PublicDataResources}
#https://waldronlab.io/PublicDataResources/
r BiocStyle::Biocpkg("GEOquery"): Access to the NCBI Gene Expression Omnibus (GEO), a public repository of gene expression (primarily microarray) data.
r BiocStyle::Biocpkg("GenomicDataCommons"): Access to the NIH / NCI Genomic Data Commons RESTful service.
r BiocStyle::Githubpkg("seandavi/SRAdbV2"): A compilation of metadata from the NCBI Sequence Read Archive, the largest public repository of sequencing data from the next generation of sequencing platforms, and tools
r BiocStyle::Biocpkg("curatedTCGAData"): Curated data from The Cancer Genome Atlas (TCGA) as MultiAssayExperiment Objects
r BiocStyle::Biocpkg("curatedMetagenomicData"): Curated metagenomic data of the human microbiome
r BiocStyle::Biocpkg("HMP16SData"): Curated metagenomic data of the human microbiome
r BiocStyle::Biocpkg("PharmacoGx"): Curated large-scale preclinical pharmacogenomic data and basic analysis tools
```


```{r scrap}
library(purrr)

mtcars %>%
  split(.$cyl) %>% # from base R
  map(~ lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared")
#>         4         6         8 
#> 0.5086326 0.4645102 0.4229655
library(purrrogress)
## basic example code

fun <- function(...){
    # this does nothing but take time.
    Sys.sleep(0.1)
    invisible(NULL)
}
invisible(map(1:100, with_progress(fun)))
```

```{r jobs}
#https://github.com/lindeloev/job
#remotes::install_github("lindeloev/job")
#install.packages("brms")
library(brms)
data = mtcars[mtcars$hp > 100, ]
plot(data)
model = mpg ~ hp * wt
fit = brm(model, data)
fit = add_criterion(fit, "loo")
print(summary(fit))  # Show a summary in the job
the_test = hypothesis(fit, "hp > 0")
# Send long-running code to a job
job::job(brm_result = {
  fit = brm(model, data)
  fit = add_criterion(fit, "loo")
  print(summary(fit))  # Show a summary in the job
  the_test = hypothesis(fit, "hp > 0")
})
cat("Console.")
```

```{r nonparamBayes}
#https://www.biogeography.org/news/news/bayesian-nonparametric-regression-workshop/
’embarcadero’, ‘blockCV’ and ‘modEvA’
```
```{r biomeX}
#https://github.com/compbiomed/animalcules
BiocManager::install(version = "3.12")
BiocManager::install("compbiomed/animalcules")
```

```{r expectedReturns}
#https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2965224#03262021-111
#The entry function is stk.exp.ret(ret, hld, k, tol = 1e-8). Here ret is an N×d matrix ηis of alpha expected returns, where the most recent date corresponds to s = 1; hld is a 3-dimensional N × M × d array PiAs of stock positions; k is the input (see below) number of principal components K used in modeling the matrix Ξeijs; tol is used in dealing with rounding errors (to wit, to distinguish null eigenvalues). Internally the function stk.exp.ret() calls the function calc.spec.var(), which internally calls the function calc.erank(). For K = 0 or K ≥ d − 2 the code sets K = 0, i.e., no principal components are used. For K < 0 the code sets K using eRank (truncated to an integer – it is straightforward to change it to rounding). For 0 < K < d − 2 the code uses this input value for the number of principal components. Internally the function calc.spec.var() also calls the function qrm.calc.eigen.eff() given in Appendix C of [Kakushadze and Yu, 2017b], which provides a much more efficient method (not based on power iterations) for computing eigenpairs than the internal R function (which is based on power iterations [Mises and ollaczek-Geiringer, 1929]).31 The function stk.exp.ret() returns the vector Ei = Ei,s=1 of the stock expected returns for the most recent date s = 1. The code only uses data with s > 1 to compute the regression weights out-of-sample.
calc.erank <- function (x, excl.first)
{
take <- x > 0
x <- x[take]
if(excl.first)
x <- x[-1]
p <- x / sum(x)
h <- - sum(p * log(p))
er <- exp(h)
if(excl.first)
er <- er + 1
return(er)
}
calc.spec.var <- function (x, k, do.trunc = T)
{
m <- ncol(x) - 1
if(k == 0 | k >= m)
30 The R Project for Statistical Computing, www.r-project.org.
31 For large N using the internal R function eigen() here would be computationally prohibitive.
16
return(apply(x, 1, var))
x.e <- qrm.calc.eigen.eff(x)
x.val <- x.e$values
x.vec <- x.e$vectors
if(k < 0)
{
k <- calc.erank(x.val, excl.first = F)
if(do.trunc)
k <- trunc(k)
else
k <- round(k)
}
if(length(take <- (k+1):m) == 1)
return(x.vec[, take]^2 * x.val[take])
return(colSums(t(x.vec[, take])^2 * x.val[take]))
}
stk.exp.ret <- function (ret, hld, k, tol = 1e-8)
{
n <- nrow(ret)
d <- ncol(ret)
res <- matrix(NA, n, d - 1)
for(s in 2:d)
res[, s - 1] <- residuals(lm(ret[, s] ∼ -1 + hld[, , s]))
v <- 1 / calc.spec.var(res, k)
x <- t(hld[, , 1]) %*% (v * hld[, , 1])
x.e <- eigen(x)
x.val <- x.e$values
x.vec <- x.e$vectors
take <- x.val > tol * x.val[1]
x.val <- x.val[take]
x.vec <- x.vec[, take]
stk <- colSums(hld[, , 1] * v * ret[, 1])
stk <- colSums(x.vec * stk) / x.val
stk <- colSums(t(x.vec) * stk)
return(stk)
}
```

```{r splitProtOpt}
#https://www.nature.com/articles/s41589-020-00729-8#MOESM4
#Logistic regression analysis:
#We used logistic regression as a linear classification tool to relate experimentally determined phenotypes to the Rosetta computed energy landscape. During this type of analysis, hyperplanes in feature space are defined and used to separate observations belonging to different classes. All data preparation and logistic regression analyses were performed using R version 3.6.1. Stratified sampling and logistic regression using the linear discriminant analysis method (see commands below) were conducted with the dplyr and carat packages. 
#Data stratification:
#Stratified sampling reduces the likelihood of randomly sampling the same region of the energy landscape when selecting data to form calibration sets; sampling across the range of ????G values increases the probability of sampling members of each phenotype, which is necessary for determining the energy partitions. The comprehensive Rosetta computed ????GTotal vs ????GInterfacial energy landscape of all single (285) and double or paired mutants (37,905) was generated and divided into 4 evenly populated strata (I, II, III, and IV). To generate the strata, the data were first partitioned using the median ????GTotal, and then these subgroups were further partitioned by their median ????GInterfacial. The strata boundaries were drawn from this ~38,000-member set because these would be the only data available at this stage if we were applying SPORT to a new split protein system. The 193 experimentally characterized TEVp variants were mapped to these strata for the retrospective stratified bootstrap sampling analysis.
#Commands:
library(caret)
library(dplyr)
#LDA of our actual calibration set
cal <- read.csv("actual_calibration_set.csv", header=T)
new <- read.csv("stratified_after_calibration_set.csv", header=T)
train <- cal
test <- new
train_ddg <- cbind(train$ddG_total, train$ddG_interfacial)
train_pheno <- as.factor(as.character(train$phenotype))
test_ddg <- cbind(test$ddG_total, test$ddG_interfacial)
test_pheno <- factor(test$phenotype, levels=levels(train_pheno))
lda_model <- train(x=train_ddg, y=train_pheno, method="lda", metric="Accuracy")
lda_pred <- predict(lda_model, test_ddg)confusionMatrix(lda_pred, as.factor(test_pheno))

#Retrospective LDA using stratified bootstrap sampling of characterized variants
data <- read.csv("stratified_all_tested_data.csv", header=T)
for(size in 1:7) #since there are 4 strata, we are sampling 4, 8, ., 28 variants
{  
  for(samp_set in 1:10)
  {			set.seed(size*samp_set+100)
    strat_samp <- as.data.frame(data %>% group_by(strata) %>% sample_n(size) %>% ungroup)
    train <- data[strat_samp[,1],]
    test <- data[-strat_samp[,1],]
    train_ddg <- cbind(train$ddG_total, train$ddG_interfacial)
    train_pheno <- as.factor(as.character(train$phenotype))
    test_ddg <- cbind(test$ddG_total, test$ddG_interfacial)
    test_pheno <- factor(test$phenotype, levels=levels(train_pheno))lda_model <- train(x=train_ddg, y=train_pheno, method="lda", metric="Accuracy")
    lda_pred <- predict(lda_model, test_ddg)
    cm <- confusionMatrix(lda_pred, as.factor(test_pheno))
    temp_byclass <- as.table(cm$byClass)
    temp_overall <- as.table(cm$overall)
    if(samp_set==1)
    {
      byclass <- temp_byclass
      overall <- temp_overall
    } else
    {
      byclass <- rbind(byclass, temp_byclass)
      overall <- rbind(overall, temp_overall)
    }
  }
  notInd <- subset(byclass, row.names(byclass)=="Class: not inducible")
  Ind <- subset(byclass, row.names(byclass)=="Class: inducible")
  Dead <- subset(byclass, row.names(byclass)=="Class: dead")
  all_overall <- overall[1:2,]
  row.names(all_overall) <- c('mean','sd')
  all_notInd <- byclass[1:2,]
  row.names(all_notInd) <- c('mean','sd')
  all_Ind <- all_notInd
  all_Dead <- all_Ind
  for(param in 1:length(overall[1,]))
  {
    all_overall[1,param] <- mean(overall[1:length(overall[,1]),param], na.rm = TRUE)
    all_overall[2,param] <- sd(overall[1:length(overall[,1]),param], na.rm = TRUE)
  }
  for(param in 1:length(byclass[1,]))
  {
    all_notInd[1,param] <- mean(notInd[1:length(notInd[,1]),param], na.rm = TRUE)
    all_notInd[2,param] <- sd(notInd[1:length(notInd[,1]),param], na.rm = TRUE)
    all_Ind[1,param] <- mean(Ind[1:length(Ind[,1]),param], na.rm = TRUE)
    all_Ind[2,param] <- sd(Ind[1:length(Ind[,1]),param], na.rm = TRUE)
    all_Dead[1,param] <- mean(Dead[1:length(Dead[,1]),param], na.rm = TRUE)
    all_Dead[2,param] <- sd(Dead[1:length(Dead[,1]),param], na.rm = TRUE)
  }	
  if(size==1)
  {
    mean_overall <- all_overall[1,]
    sd_overall <- all_overall[2,]
    mean_notInd <- all_notInd[1,]
    sd_notInd <- all_notInd[2,]
    mean_Ind <- all_Ind[1,]
    sd_Ind <- all_Ind[2,]
    mean_Dead <- all_Dead[1,]
    sd_Dead <- all_Dead[2,]
  } else
  {
    mean_overall <- rbind(mean_overall,all_overall[1,])
    sd_overall <- rbind(sd_overall,all_overall[2,])
    mean_notInd <- rbind(mean_notInd,all_notInd[1,])
    sd_notInd <- rbind(sd_notInd,all_notInd[2,])
    mean_Ind <- rbind(mean_Ind,all_Ind[1,])
    sd_Ind <- rbind(sd_Ind,all_Ind[2,])
    mean_Dead <- rbind(mean_Dead,all_Dead[1,])
    sd_Dead <- rbind(sd_Dead,all_Dead[2,])
  }
}

```

```{r spaceLocSS}
#https://bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/MouseCoronalVisiumAnalysis.html
#BiocManager::install("SpatialExperiment")
barcodesFile <- system.file(file.path("extdata", "10x_visium",
                            "barcodes.tsv"), package="SpatialExperiment")
barcodesEx <- read.csv(barcodesFile, sep="\t", 
                     header=FALSE, col.names=c("Cell_ID"))
featuresFile <- system.file(file.path("extdata", "10x_visium",
                            "features.tsv"), package="SpatialExperiment")
featuresEx <- read.csv(featuresFile, sep="\t", 
                     header=FALSE, col.names=c("Feature_ID", "Feature_name", 
                                               "Feature_type"))

countsFile <- system.file(file.path("extdata", "10x_visium",
                            "matrix.mtx"), package="SpatialExperiment")
countsEx <- Matrix::readMM(file=countsFile)
posFile <- system.file(file.path("extdata", "10x_visium",
                        "tissue_positions_list.tsv"), 
                        package="SpatialExperiment")
tissPosEx <- read.csv(posFile, 
                        sep="\t", header=FALSE, 
                        col.names=c("Cell_ID", "in_tissue", 
                                    "array_row", "array_col",
                                    "pxl_col_in_fullres", "pxl_row_in_fullres"))
imageFilePath <- list.files(system.file(file.path("extdata", "10x_visium", 
                              "images"), package="SpatialExperiment"), 
                            full.names=TRUE)
scaleFile <- system.file(file.path("extdata", "10x_visium",
                        "scalefactors_json.json"), 
                        package="SpatialExperiment")
scalefactors <- rjson::fromJSON(file=scaleFile)
ve <- SpatialExperiment::VisiumExperiment(rowData=featuresEx, colData=barcodesEx, 
                            assays=c(counts=countsEx), 
                            spatialCoords=tissPosEx,
                            scaleFactors=scalefactors)
SpatialExperiment::spatialCoords(ve)
SpatialExperiment::imagePaths(ve) <- imageFilePath
SpatialExperiment::scaleFactors(ve)
sum(SpatialExperiment::isInTissue(ve))
ve[isInTissue(ve)]
```

```{r pearsonResiduals}
#https://gist.github.com/hypercompetent/51a3c428745e1c06d826d76c3671797c
pearson_residuals <- function(counts, theta = 100) {
  counts_sum0 <- as(matrix(Matrix::colSums(counts),nrow=1),"dgCMatrix")
  counts_sum1 <- as(matrix(Matrix::rowSums(counts),ncol=1),"dgCMatrix")
  counts_sum <- sum(counts@x)
  
  #get residuals
  mu <- (counts_sum1 %*% counts_sum0) / counts_sum
  z <- (counts - mu) / sqrt(mu + mu^2/theta)
  
  #clip to sqrt(n)
  n <- ncol(counts)
  z[z > sqrt(n)] <- sqrt(n)
  z[z < -sqrt(n)] <- -sqrt(n)
  
  z
}

sparse_pearson_residuals <- function(counts, theta = 100) {
  counts_sum0 <- Matrix::colSums(counts)
  counts_sum1 <- Matrix::rowSums(counts)
  counts_sum <- sum(counts@x)
  
  #get residuals sparsely
  mu <- Matrix::sparseMatrix(x = counts_sum1[counts@i + 1] * rep(counts_sum0, diff(counts@p)) / counts_sum,
                             i = counts@i,
                             p = counts@p,
                             dims = dim(counts),
                             index1 = FALSE)
  
  z <- counts - mu
  mu2 <- sqrt(mu + mu^2/theta)
  z@x <- z@x / mu2@x
  
  # clip to sqrt(n)
  n <- ncol(counts)
  z@x[z@x > sqrt(n)] <- sqrt(n)
  z@x[z@x < -sqrt(n)] <- -sqrt(n)
  
  z
}
```

```{r sIncome}
# Data https://lindeloev.net/new-pnas-paper-income-is-a-poor-way-to-improve-well-being/
N = 33391  # Number of participants
incomes = exp(seq(log(15000), log(480000), length.out = N))  # x-axis of Figure 1
trend_wb = seq(-0.2, 0.25, length.out = N)  # Linear, read off Figure 1
trend_ls = seq(-0.3, 0.4, length.out = N)   # Linear, read off Figure 1
z_wb = rnorm(N, trend_wb)  # z-score is standard normal
z_ls = rnorm(N, trend_ls)  # z-score is standard normal
# Merge the data in long format
df = data.frame(
  incomes,
  z = c(rnorm(N, z_wb), rnorm(N, z_ls)),
  outcome = c(rep("Experienced Well-Being", N), rep("Life Satisfaction", N))
)
ggplot2::ggplot(df, ggplot2::aes(x = incomes, y = z)) +
  ggplot2::geom_point(alpha = 0.1, size = 0.3) + 
  ggplot2::geom_line(ggplot2::aes(y = c(trend_wb, trend_ls), color = outcome), lwd = 2) + 
  ggplot2::geom_vline(xintercept = 75000, lty = 2, lwd = 1, color = "#555555") + 
  ggplot2::facet_wrap(~outcome) + 
  #scale_x_continuous(trans = "log", breaks = c(15, 30, 60, 120, 240, 480) * 1000) + 
  ggplot2::scale_x_continuous(breaks = c(15, 30, 60, 120, 240, 480) * 1000, labels = scales::label_number_auto()) + 
  ggplot2::labs(x = "Houshold income", y = "z-scored well-being") + 
  ggplot2::theme_bw(13) + 
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
#r-values reported in the paper (r = 0.17 and r = 0.09) and that this correspond to 4% and 1.5% variance explained, respectively:
summary(lm(z_ls ~ log(incomes)))
summary(lm(z_wb ~ log(incomes)))
nonlow_incomes = incomes[incomes > 30000]
lm(z_ls ~ log(nonlow_incomes))
```

```{r val0}
#https://www.r-bloggers.com/2021/01/plot-predicted-values-for-presences-vs-absences/
library(modEvA)
# load sample models:
data(rotif.mods)
# choose a particular model to play with:
mod <- rotif.mods$models[[1]]
# make some predPlots:
predPlot(model = mod)
predPlot(model = mod, thresh = 0.5)
# you can also use 'predPlot' with vectors of observed and predicted values instead of a model object:
myobs <- mod$y
mypred <- mod$fitted.values
predPlot(obs = myobs, pred = mypred)
```

```{r zeroMod}
#https://notstatschat.rbind.io/2020/09/24/moar-survey-regression-models/
library(svyVGAM)
library(pscl)
data(nhanes_sxq)
des = svydesign(id=~SDMVPSU,strat=~SDMVSTRA,weights=~WTINT2YR, nest=TRUE, data=nhanes_sxq)
unwt = zeroinfl(malepartners~RIDAGEYR+factor(RIDRETH1)+DMDEDUC|RIDAGEYR+factor(RIDRETH1)+DMDEDUC, data=nhanes_sxq)
summary(unwt)
```

```{r regulon}
#https://github.com/saezlab/dorothea/tree/non-academic
devtools::install_github("saezlab/dorothea_R", ref = "non-academic")
BiocManager::install("dorothea")
```
```{r mulEnrichSum}
#https://github.com/bzhanglab/sumer
# install.packages("devtools")
devtools::install_github("bzhanglab/sumer")
```

```{r libloc, echo = FALSE}
.libPaths( c( .libPaths(), "~/libR") )
#grep "pathview" *.rmd | awk -F ':' '{print $1}' | sort | uniq -c
#usethis::edit_r_environ()
#https://community.rstudio.com/t/help-regarding-package-installation-renviron-rprofile-r-libs-r-libs-site-and-r-libs-user-oh-my/13888/8
#R_LIBS_USER in your ~/.Renviron. One <name>=<value> per line.
+#specifiers: %p (expands to the architecture, e.g. x86_64-pc-linux-gnu) and %v (expands to major and minor R version, e.g. 3.5) - see 
?R_LIBS_USER
#R_LIBS_USER=~/R/%p-library/%v
#location of ~/.Renviron
normalizePath("~/.Renviron", mustWork = FALSE)
[1] "/home/hb/.Renviron"
R_LIBS_USER="C:/Users/Greg/Software/R/%p-library/%v
Sys.getenv('R_LIBS_USER')
#Importantly, if this folder does not exist, then R will silently ignore it, despite properly parsing and expanding R_LIBS_USER, e.g.
dir.exists(Sys.getenv('R_LIBS_USER'))
.libPaths()[1]
dir.create(Sys.getenv('R_LIBS_USER'), recursive = TRUE)
dir.exists(Sys.getenv('R_LIBS_USER'))
#[1] TRUE
#Then restart R, and you'll get:
.libPaths()[1]"
update.packages(ask = FALSE,repos='https://cloud.r-project.org/')
install.packages(c("rjson","data.table"))
```

```{r countNorm}
#https://academic.oup.com/gigascience/article/8/9/giz107/5572529#163672242
rnaseq <- read.csv("rnaseq-x.csv", row.names=1)
rnaseq.annot <- read.csv("rnaseq-y.csv", row.names=1)
masshl <- read.csv("masshl-x.csv", row.names=1)
masshl.annot <- read.csv("masshl-y.csv", row.names=1)
inRNAandMS <- masshl.annot$Time
masshl <- masshl[,inRNAandMS]
masshl.annot <- masshl.annot[inRNAandMS,]
install.packages("zCompositions")
install.packages("propr")
#install.packages(“BiocManager")
BiocManager::install("ALDEx2")
library(zCompositions)
library(ALDEx2)
library(propr)
rnaseq <- t(rnaseq)
masshl <- t(masshl)
rnaseq.no0 <- zCompositions::cmultRepl(rnaseq, output = "p-counts")
masshl.no0 <- zCompositions::cmultRepl(masshl, output = "p-counts")
# Let's use Nfkb sub-units as alr reference

ref <- grep(“Nfkb", colnames(rnaseq))

 

# ALDEx2 expects:

# ‘reads': integer counts with columns as samples

# ‘conditions': the experimental outcome

# ‘denom': the log-ratio transform reference

library(ALDEx2)

conditions <- factor(rnaseq.annot$Treatment,

 levels = c(“MOCK", "LPS"))

tt <- aldex(reads = t(ceiling(rnaseq)),

 conditions = conditions,

 denom = ref)

 

# ALDEx2 outputs a data.frame:

# ‘we.eBH': the FDR-adjusted p-value

# ‘effect': the effect size

# Below, we get the names of genes

# with relatively more abundance

# in the LPS group

tt.bh05 <- tt[tt$we.eBH < .05,]

up <- rownames(tt.bh05[tt.bh05$effect > 0,])
# propr expects:

# ‘counts': the data matrix with rows as samples

# ‘metric': the proportionality metric to calculate

# ‘ivar': the log-ratio transform reference

library(propr)

pr <- propr(counts = rnaseq.no0,

 metric = “rho",

 ivar = “clr")
# We can select a good cutoff for ‘rho'

# by permuting the FDR at various cutoffs

# Below, we use [0, .05, ..., .95, 1]

pr <- updateCutoffs(pr, cutoff = seq(0, 1, .05))

pr@fdr

 

# Let's visualize using a strict cutoff

getNetwork(pr, cutoff = 0.9, col1 = up)

getResults(pr, cutoff = 0.9)
# propd expects:

# ‘counts': the data matrix with rows as samples

# ‘group': the class labels

library(propr)

pd <- propd(counts = rnaseq.no0,

 group = rnaseq.annot$Treatment)

 

# Calculate an exact p-value

pd <- updateF(pd)

getResults(pd)

Advanced
# Get LPS-treated cells only

rna <- rnaseq.no0[rnaseq.annot$Treatment == “LPS'',]

pro <- masshl.no0[masshl.annot$Treatment == “LPS'',]

 

# Join as single matrix

merge <- rbind(rna, pro)

group <- c(rep(“RNA'', 14), rep(“Protein'', 14))

 

# Run propd analysis

pd.ms <- propd(merge, group)

```


```{r propensity_score_estimation}
#https://en.wikipedia.org/wiki/Propensity_score_matching
#https://en.wikipedia.org/wiki/Inverse_probability_weighting
#https://sejdemyr.github.io/r-tutorials/statistics/tutorial8.html
#https://biol607.github.io/lab/12_gzlm.html#5_beta_regression
#data https://github.com/sejdemyr/ecls
#install.packages("betareg")
#library(betareg)
#sodium_beta <- betareg::betareg(Porportion_Sodium_Intake ~ Supplement + Instructor,data = sodium)
library(MatchIt)
library(dplyr)
library(ggplot2)
setwd("path/to/dir")
ecls <- read.csv("ecls.csv")
# Pre-analysis using non-matched data
ecls %>%
  group_by(catholic) %>%
  summarise(n_students = n(),
            mean_math = mean(c5r2mtsc_std),
            std_error = sd(c5r2mtsc_std) / sqrt(n_students))
ecls %>%
  mutate(test = (c5r2mtsc - mean(c5r2mtsc)) / sd(c5r2mtsc)) %>% #this is how the math score is standardized
  group_by(catholic) %>%
  summarise(mean_math = mean(test))
with(ecls, t.test(c5r2mtsc_std ~ catholic))
# Difference-in-means: pre-treatment covariates
ecls_cov <- c('race_white', 'p5hmage', 'w3income', 'p5numpla', 'w3momed_hsb')
ecls %>%
  group_by(catholic) %>%
  select(one_of(ecls_cov)) %>%
  summarise_all(funs(mean(., na.rm = T)))
lapply(ecls_cov, function(v) {
  t.test(ecls[, v] ~ ecls[, 'catholic'])
})
# Propensity score estimation
ecls <- ecls %>% mutate(w3income_1k = w3income / 1000)
m_ps <- glm(catholic ~ race_white + w3income_1k + p5hmage + p5numpla + w3momed_hsb,
            family = binomial(), data = ecls)
summary(m_ps)
prs_df <- data.frame(pr_score = predict(m_ps, type = "response"),
                     catholic = m_ps$model$catholic)
labs <- paste("Actual school type attended:", c("Catholic", "Public"))
prs_df %>%
  mutate(catholic = ifelse(catholic == 1, labs[1], labs[2])) %>%
  ggplot(aes(x = pr_score)) +
  geom_histogram(color = "white") +
  facet_wrap(~catholic) +
  xlab("Probability of going to Catholic school") +
  theme_bw()
# Executing a matching algorithm
ecls_nomiss <- ecls %>%  # MatchIt does not allow missing values
  select(c5r2mtsc_std, catholic, one_of(ecls_cov)) %>%
  na.omit()
mod_match <- matchit(catholic ~ race_white + w3income + p5hmage + p5numpla + w3momed_hsb,
                     method = "nearest", data = ecls_nomiss)
dta_m <- match.data(mod_match)
dim(dta_m)
fn_bal <- function(dta, variable) {
  dta$variable <- dta[, variable]
  dta$catholic <- as.factor(dta$catholic)
  ggplot(dta, aes(x = distance, y = variable, color = catholic)) +
    geom_point(alpha = 0.2, size = 1.5) +
    geom_smooth(method = "loess", se = F) +
    xlab("Propensity score") +
    ylab(variable) +
    theme_bw()
}
# Checking balance
library(gridExtra)
grid.arrange(
   fn_bal(dta_m, "w3income"),
   fn_bal(dta_m, "p5numpla") + theme(legend.position = "none"),
   fn_bal(dta_m, "p5hmage"),
   fn_bal(dta_m, "w3momed_hsb") + theme(legend.position = "none"),
   fn_bal(dta_m, "race_white"),
   nrow = 3, widths = c(1, 0.85)
)
dta_m %>%
    group_by(catholic) %>%
    summarise_all(funs(mean))
# Estimating treatment effects
with(dta_m, t.test(c5r2mtsc_std ~ catholic))
lm_treat1 <- lm(c5r2mtsc_std ~ catholic, data = dta_m)
summary(lm_treat1)
lm_treat2 <- lm(c5r2mtsc_std ~ catholic + race_white + p5hmage +
                  I(w3income / 10^3) + p5numpla + w3momed_hsb, data = dta_m)
summary(lm_treat2)
```

```{r metagenome}
#https://github.com/zdk123/SpiecEasi
library(devtools)
install_github("zdk123/SpiecEasi")
library(SpiecEasi)
set.seed(10010)
graph <- make_graph('cluster', d, e)
Prec  <- graph2prec(graph)
Cor   <- cov2cor(prec2cov(Prec))
X <- synth_comm_from_counts(amgut1.filt.cs, mar=2, distr='zinegbin', Sigma=Cor, n=n)
library(igraph)
## set size of vertex proportional to clr-mean
vsize    <- rowMeans(clr(amgut1.filt, 1))+6
am.coord <- layout.fruchterman.reingold(ig.mb)

se.mb.amgut <- spiec.easi(amgut1.filt, method='mb', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))
se.gl.amgut <- spiec.easi(amgut1.filt, method='glasso', lambda.min.ratio=1e-2,
                          nlambda=20, pulsar.params=list(rep.num=50))
sparcc.amgut <- sparcc(amgut1.filt)
## Define arbitrary threshold for SparCC correlation matrix for the graph
sparcc.graph <- abs(sparcc.amgut$Cor) >= 0.3
diag(sparcc.graph) <- 0
library(Matrix)
sparcc.graph <- Matrix(sparcc.graph, sparse=TRUE)
## Create igraph objects
ig.mb     <- adj2igraph(getRefit(se.mb.amgut))
ig.gl     <- adj2igraph(getRefit(se.gl.amgut))
ig.sparcc <- adj2igraph(sparcc.graph)

par(mfrow=c(1,3))
plot(ig.mb, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="MB")
plot(ig.gl, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="glasso")
plot(ig.sparcc, layout=am.coord, vertex.size=vsize, vertex.label=NA, main="sparcc")
```

```{r c++stats}
#https://github.com/SebKrantz/collapse
#install.packages("collapse")
library(collapse)
data("iris")            # iris dataset in base R
v <- iris$Sepal.Length  # Vector
d <- num_vars(iris)     # Saving numeric variables (could also be a matrix, statistical functions are S3 generic)
g <- iris$Species       # Grouping variable (could also be a list of variables)
## Advanced Statistical Programming -----------------------------------------------------------------------------
# Simple (column-wise) statistics...
fmedian(v) 
```

```{r mixtools}
#https://cran.r-project.org/web/packages/mixtools/vignettes/mixtools.pdf
install.packages("mixtools")
library(mixtools)
data(faithful)
attach(faithful)
hist(waiting, main="eruptions", xlab="Minutes", ylab="", cex.main=1.5, cex.lab=1.5, cex.axis=1.4)
wait1 <- normalmixEM(waiting, lambda = .5, mu = c(55, 80), sigma = 5)
plot(wait1, density=TRUE, cex.axis=1.4, cex.lab=1.4, cex.main=1.8, main2="mixmod", xlab2="Minutes")
```

```{r GSVA}
#https://www.bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.pdf
BiocManager::install("GSVA")
```

```{r andrews}
#https://stackoverflow.com/questions/19891728/plotting-andrews-curves-of-subsets-of-a-data-frame-on-the-same-plot
install.packages("andrews")
data(iris)
andrews::andrews(iris[1:4],type=1, clr=3)#, step=100, ymax=10, main=NULL, sub=NULL)
```

```{r enrichplot}
#https://yulab-smu.top/biomedical-knowledge-mining-book/
BiocManager::install("enrichplot")
```

```{r circ}
#https://jokergoo.github.io/circlize_examples/example/otu.html
load("example/abandance.RData")
load("example/otu.RData")

species = intersect(colnames(abandance), otu[[2]])
abandance = abandance[, species]

cate = rownames(abandance)[c(1:10)]

library(RColorBrewer)
col1 = brewer.pal(5, "Set1")
names(col1) = species
col2 = brewer.pal(length(cate), "Set3")
names(col2) = cate

df = NULL
for(type in cate) {
    for(s in species) {
        l = otu[[2]] == s
        n = sum(l)
        n = 1
        dd = data.frame(type = rep(type, n), species = rep(s, n), vaule1 = abandance[type, s], value2 = sum(otu[l, type]))
        df = rbind(df, dd)
    }
}

df[[1]] = as.character(df[[1]])
df[[2]] = as.character(df[[2]])

sector = NULL
sector_xlim = NULL
for(t in unique(df[[1]])) {
    sector = c(sector, t)
    sector_xlim = rbind(sector_xlim, c(0, sum(df[df[[1]] == t, 3])))
}
for(t in unique(df[[2]])) {
    sector = c(sector, t)
    sector_xlim = rbind(sector_xlim, c(0, sum(df[df[[2]] == t, 4])))
}

library(circlize)



circos.par(cell.padding = c(0, 0, 0, 0), start.degree = 270, gap.degree = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1, 10))
circos.initialize(factors = factor(sector, levels = sector), xlim = sector_xlim,
    sector.width = c(sector_xlim[1:10,2]/sum(sector_xlim[1:10,2]), 1*sector_xlim[11:15,2]/sum(sector_xlim[11:15,2])))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    sector.index = get.cell.meta.data("sector.index")
    if(sector.index %in% sector[11:15]) {
        xlim = get.cell.meta.data("xlim")
        ylim = get.cell.meta.data("ylim")
        l = otu[[2]] == sector.index
        x = seq(0, by = 3, length = sum(l))
        x = x + mean(xlim) - mean(x)
        circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = col1[sector.index], border = NA)
        circos.text(x, rep(0, sum(l)), otu[l, 1], col = "white", facing = "clockwise", niceFacing = TRUE, adj = c(-0.1, 0.5), cex = 0.6)

    }
}, bg.border = NA, track.height = 0.08)
circos.trackPlotRegion(ylim = c(1, 10), panel.fun = function(x, y) {
    sector.index = get.cell.meta.data("sector.index")
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    if(sector.index %in% sector[11:15]) {
        l = otu[[2]] == sector.index
        df = otu[l, sector[1:10]]
        x = seq(0, by = 3, length = sum(l))
        x = x + mean(xlim) - mean(x)
        for(i in seq_len(nrow(df))) {
            circos.lines(c(x[i], x[i]), c(1, ncol(df)), lwd = 0.5)
        }
        for(j in seq_len(ncol(df))) {
            circos.lines(c(x[1], x[nrow(df)]), c(j, j), lwd = 0.5)
        }
        for(i in seq_len(nrow(df))) {
            for(j in seq_len(ncol(df))) {
                circos.points(x[i], j, pch = 16, cex = df[i,j]/20)
            }
        }
        if(sector.index %in% sector[11:15]) {
            circos.text(rep(x[1], ncol(df)), seq_len(ncol(df)), colnames(df), cex = 0.6, facing = "bending.inside", niceFacing = TRUE, adj = c(1.1, 0.5))
        }
    }
}, bg.border = NA, track.height = 0.2)

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    sector.index = get.cell.meta.data("sector.index")
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.text(mean(xlim), mean(ylim), sector.index, cex = 0.7, facing = "bending.inside", niceFacing = TRUE)
}, track.height = 0.05, bg.border = NA)

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.axis(h = "top", labels.cex = 0.4)
}, track.height = 0.02, bg.col = c(col2, col1), track.margin = c(0, 0.01))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
}, track.height = 0.02, track.margin = c(0, 0.01))

accum_species = sapply(species, function(x) get.cell.meta.data("xrange", sector.index = x)); names(accum_species) = species
accum_cate = sapply(cate, function(x) get.cell.meta.data("xrange", sector.index = x)); names(accum_cate) = cate
for(i in seq_len(nrow(df))) {
    circos.link(df[i,1], c(accum_cate[df[i,1]], accum_cate[df[i,1]] - df[i, 3]),
                df[i,2], c(accum_species[df[i,2]], accum_species[df[i,2]] - df[i, 4]),
                col = paste0(col1[df[i,2]], "80"), border = NA)

    circos.rect(accum_cate[df[i,1]], 0, accum_cate[df[i,1]] - df[i, 3], 1, sector.index = df[i,1], col = col1[df[i,2]])
    circos.rect(accum_species[df[i,2]], 0, accum_species[df[i,2]] - df[i, 4], 1, sector.index = df[i,2], col = col2[df[i,1]])

    accum_cate[df[i,1]] = accum_cate[df[i,1]] - df[i, 3]
    accum_species[df[i,2]] = accum_species[df[i,2]] - df[i, 4]
}
circos.clear()

```

```{r NA}
#Integrated Proteogenomic Characterization across Major Histological Types of Pediatric Brain Cancer https://www.cell.com/cell/fulltext/S0092-8674(20)31451-3#secsectitle0020
#data https://github.com/AlexsLemonade/OpenPBTA-analysis
#https://github.com/WangLab-MSSM/DreamAI#installation
require("cluster")
require("survival")
#install.packages("randomForest")
require("randomForest")
#install.packages("missForest")
require("missForest")
#install.packages("glmnet")
require("glmnet")
require("Rcpp")
require("foreach")
require("itertools")
require("iterators")
require("Matrix")
require("devtools")
#BiocManager::install("impute")
require("impute")
require("remotes")
install_github("WangLab-MSSM/DreamAI/Code")
require("DreamAI")
DreamAI(data, k = 10, maxiter_MF = 10, ntree = 100,
  maxnodes = NULL, maxiter_ADMIN = 30, tol = 10^(-2),
  gamma_ADMIN = NA, gamma = 50, CV = FALSE,
  fillmethod = "row_mean", maxiter_RegImpute = 10,
  conv_nrmse = 1e-06, iter_SpectroFM = 40, method = c("KNN",
  "MissForest", "ADMIN", "Birnn", "SpectroFM", "RegImpute"),
  out = c("Ensemble"))
```

```{r cellMark}
#https://github.com/LTLA/SingleR
#BiocManager::install("SingleR", version = "devel")
BiocManager::install("SingleR")
```


```{r med-DB}
#https://github.com/MIT-LCP/mimic-code
#https://github.com/MIT-LCP/mimic-code/blob/master/tutorials/explore-items.Rmd
#downloads (http://dryad2.lib.ncsu.edu/).

```

```{r phylogen}
#https://github.com/KlausVigo/phangorn/blob/master/vignettes/IntertwiningTreesAndNetworks.Rmd
install.packages("phangorn", dependencies=TRUE)
library(phangorn)    # load the phangorn library
library(magrittr)
fdir <- system.file("extdata/trees", package = "phangorn")
##DNA Matrix, maybe not needed 
woodmouse <- read.phyDat(file.path(fdir, "woodmouse.fasta"),format="fasta") 
## RAxML best-known tree with bipartition support (from previous analysis)
raxml.tree <- read.tree(file.path(fdir,"RAxML_bipartitions.woodmouse"))
## RAxML bootstrap trees (from previous analysis)
raxml.bootstrap <- read.tree(file.path(fdir,"RAxML_bootstrap.woodmouse"))
## MrBayes consensus tree (50% majority rule) (from previous analysis)
mrbayes.tree <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.con"))
## MrBayes sample runs 1 and 2 (from previous analysis)
run1 <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.run1.t"))
run2 <- read.nexus(file.path(fdir,"woodmouse.mrbayes.nex.run2.t"))
## How many trees are in the MrBayes tree sample?
run1
run2
## Combining the two runs and removing 25% burn-in
mrbayes.trees <- c(run1[251:1001],run2[251:1001])
## NeigbourNet Nexus file generated by SplitsTree (from previous analysis)
Nnet <- read.nexus.networx(file.path(fdir,"woodmouse.nxs"))
par(mfrow=c(1,2), mar=c(1,1,1,1)) # Setting plot parameters
### Plotting trees with support values:
##  RAxML
plot(raxml.tree)
nodelabels(raxml.tree$node.label, adj = c(1, 0), frame = "none")
##  MrBayes
plot(mrbayes.tree)
nodelabels(mrbayes.tree$node.label, adj = c(1, 0), frame = "none")
par(mfrow=c(1,1)) # Setting plot parameters
# NeighbourNet
plot(Nnet,"2D")
```

```{r scry-Pearson_residuals}
#https://www.biorxiv.org/content/10.1101/2020.12.01.405886v1.full
#https://bioconductor.org/packages/release/bioc/vignettes/scry/inst/doc/scry.html
#BiocManager::install("scry")
library(ggplot2); theme_set(theme_bw())
#BiocManager::install("DuoClustering2018")
library(DuoClustering2018)
require(scry)
sce<-sce_full_Zhengmix4eq()
sce<-devianceFeatureSelection(sce, assay="counts", sorted=TRUE)
#BiocManager::install("SummarizedExperiment")
library(SummarizedExperiment)
plot(rowData(sce)$binomial_deviance, type="l", xlab="ranked genes",ylab="binomial deviance", main="Feature Selection with Deviance")
abline(v=2000, lty=2, col="red")
sce2<-sce[1:1000, ]
set.seed(101)
sce2<-GLMPCA(sce2, 2, assay="counts")
fit<-metadata(sce2)$glmpca
pd<-cbind(as.data.frame(colData(sce2)), fit$factors)
ggplot(pd, aes(x=dim1, y=dim2, colour=phenoid)) + geom_point(size=.8) + ggtitle("GLM-PCA applied to high deviance genes")
#faster
sce<-nullResiduals(sce, assay="counts", type="deviance")
sce<-nullResiduals(sce, assay="counts", type="pearson")
sce2<-sce[1:1000, ] #use only the high deviance genes
pca<-function(Y, L=2, center=TRUE, scale=TRUE){
    #assumes features=rows, observations=cols
    res<-prcomp(as.matrix(t(Y)), center=center, scale.=scale, rank.=L)
    factors<-as.data.frame(res$x)
    colnames(factors)<-paste0("dim", 1:L)
    factors
}
pca_d<-pca(assay(sce2, "binomial_deviance_residuals"))
pca_d$resid_type<-"deviance_residuals"
pca_p<-pca(assay(sce2, "binomial_pearson_residuals"))
pca_p$resid_type<-"pearson_residuals"
cm<-as.data.frame(colData(sce2))
pd<-rbind(cbind(cm, pca_d), cbind(cm, pca_p))
ggplot(pd, aes(x=dim1, y=dim2, colour=phenoid)) + geom_point() +
  facet_wrap(~resid_type, scales="free", nrow=2) +
  ggtitle("PCA applied to null residuals of high deviance genes")
```

```{r wordmap}
#https://r-tastic.co.uk/post/amazon-reviews-word-cloud/
install.packages("pacman", repos = "http://cran.us.r-project.org")
pacman::p_load(XML, dplyr, stringr, rvest, xml2) # web-scraping
pacman::p_load(tm, rvest, SnowballC, wordcloud) # wordcloud-building
# define a function removing all white space
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
# define product code and the url
prod_code = "1846558239"
url <- paste0("https://www.amazon.co.uk/dp/", prod_code)
doc <- xml2::read_html(url)
#obtain the text in the node, remove "\n" from the text, and remove white space
prod <- html_nodes(doc, "#productTitle") %>% html_text() %>% gsub("\n", "", .) %>% trim()
prod
# THE KEY: Source function to parse Amazon html pages for data
source("https://raw.githubusercontent.com/rjsaito/Just-R-Things/master/Text%20Mining/amazonscraper.R")
pages <- 1
reviews_all <- NULL
for(page_num in 1:pages){
  url2 <- paste0("http://www.amazon.co.uk/product-reviews/",prod_code,"/?pageNumber=", page_num)
  doc2 <- read_html(url2)
  reviews <- amazon_scraper(doc2, reviewer = F, delay = 2)
  reviews_all <- rbind(reviews_all, reviews)
}
#### creating corpus
m <- list(content = "comments")
myReader <- readTabular(mapping = m)

final_reviews <- data.frame(comments = reviews_all$comments)
ds <- DataframeSource(final_reviews)

## create corpus with all the reviews
sapiens_corpus <- VCorpus(ds)

## remove punctuation
sapiens_corpus = tm_map(sapiens_corpus, removePunctuation)

## remove numbers
sapiens_corpus = tm_map(sapiens_corpus, removeNumbers)

## LowerCase
sapiens_corpus = tm_map(sapiens_corpus, tolower)
## remove stopwords and other words
myWords=c("format", "paperback", "kindle", "edit", "hardcov", "book", "read", "will", "just", "can", "much")

sapiens_corpus <- tm_map(sapiens_corpus, removeWords, c(stopwords("english"), myWords))

## treat pre-processed documents as text documents
sapiens_corpus <- tm_map(sapiens_corpus, PlainTextDocument)

## turn into doc matrix
sapiens_dtm <- DocumentTermMatrix(sapiens_corpus)
freq <- sort(colSums(as.matrix(sapiens_dtm)), decreasing=TRUE)   
head(freq, 20)  
pal=brewer.pal(9, "Set1")

set.seed(100)
wordcloud(words = names(freq), freq = freq, max.words=250,
          random.order=FALSE,
          colors=pal)

```

```{r profiler}
#https://github.com/CCprofiler/CCprofiler/blob/master/vignettes/CCprofiler_vignette.Rmd
cran_deps <- c('proxy', 'doSNOW', 'igraph', 'pracma', 'Rmpfr') 
install.packages(cran_deps)
BiocManager::install("qvalue")
```


```{r compare}
#https://www.tidyverse.org/blog/2020/10/waldo/ 
x1 <- gh::gh("/repos/gaborcsardi/roxygenlabs")
x2 <- gh::gh("/repos/gaborcsardi/roxygenlabs", .token = "")
attr(x1, "response") <- NULL
attr(x1, ".send_headers") <- NULL
attr(x2, "response") <- NULL
attr(x2, ".send_headers") <- NULL
waldo::compare(x1, x2)
```


```{r HGNChelper}
#https://github.com/waldronlab/HGNChelper
#install.packages("HGNChelper")
human = c("FN1", "tp53", "UNKNOWNGENE","7-Sep", "9/7", "1-Mar", "Oct4", "4-Oct","OCT4-PG4", "C19ORF71", "C19orf71")
HGNChelper::checkGeneSymbols(human)
HGNChelper::checkGeneSymbols(c("1-Feb", "Pzp", "A2m", "E430008G22Rik"), species="mouse")
HGNChelper::getCurrentHumanMap() 
getCurrentMouseMap()
dim(mouse.table)
#> [1] 371392      2
dim(hgnc.table)
#> [1] 99492     3
```

```{r marker}
#https://cole-trapnell-lab.github.io/garnett/docs/
BiocManager::install(c("monocle"))
install.packages("devtools")
BiocManager::install(c("org.Mm.eg.db"))
devtools::install_github("cole-trapnell-lab/garnett")
```

```{r conditional}
#https://cran.r-project.org/web/packages/coin/vignettes/coin.pdf
install.packages("coin")
library("coin")
YOY <- data.frame(length = c(46, 28, 46, 37, 32, 41, 42, 45, 38, 44,42, 60, 32, 42, 45, 58, 27, 51, 42, 52,38, 33, 26, 25, 28, 28,26, 27, 27, 27,31, 30, 27, 29, 30, 25, 25, 24, 27, 30),site = gl(4, 10, labels = as.roman(1:4)))
it <- independence_test(length ~ site, data = YOY,ytrafo = function(data) trafo(data, numeric_trafo = rank_trafo),teststat = "quadratic")
#data: length by site (I, II, III, IV)
#chi-squared = 22.852, df = 3, p-value = 4.335e-05
statistic(it, type = "linear")
expectation(it)
covariance(it)
kt <- kruskal_test(length ~ site, data = YOY,distribution = approximate(nresample = 10000))
```

```{r corrplot}
install.packages("corrplot")
correlationMatrix <- cor(log2LFQ)
corrplot::corrplot(correlationMatrix, order = 'hclust', addrect = 2, addCoef.col = 'white', number.cex = 0.7) 
```

```{r prior}
#https://cran.r-project.org/web/packages/lme4/vignettes/lmer.pdf
install.packages("lme4")
fm1 <- lme4::lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
```
```{r limma}
#http://compgenomr.github.io/book/how-to-test-for-differences-between-samples.html#randomization-based-testing-for-difference-of-the-means
set.seed(100)

#sample data matrix from normal distribution

gset=rnorm(3000,mean=200,sd=70)
data=matrix(gset,ncol=6)

# set groups
group1=1:3
group2=4:6
n1=3
n2=3
dx=rowMeans(data[,group1])-rowMeans(data[,group2])
  
require(matrixStats)

# get the esimate of pooled variance 
stderr = sqrt( (rowVars(data[,group1])*(n1-1) + 
       rowVars(data[,group2])*(n2-1)) / (n1+n2-2) * ( 1/n1 + 1/n2 ))

# do the shrinking towards median
mod.stderr = (stderr + median(stderr)) / 2 # moderation in variation

# esimate t statistic with moderated variance
t.mod <- dx / mod.stderr

# calculate P-value of rejecting null 
p.mod = 2*pt( -abs(t.mod), n1+n2-2 )

# esimate t statistic without moderated variance
t = dx / stderr

# calculate P-value of rejecting null 
p = 2*pt( -abs(t), n1+n2-2 )

par(mfrow=c(1,2))
hist(p,col="cornflowerblue",border="white",main="",xlab="P-values t-test")
mtext(paste("signifcant tests:",sum(p<0.05))  )
hist(p.mod,col="cornflowerblue",border="white",main="",
     xlab="P-values mod. t-test")
mtext(paste("signifcant tests:",sum(p.mod<0.05))  )

```

```{r hrbrthemes}
#https://github.com/hrbrmstr/hrbrthemes
install.packages("hrbrthemes", repos = c("https://cinc.rud.is", "https://cloud.r-project.org/"))
packageVersion("hrbrthemes") # current verison ## [1] '0.8.6'
ggplot2::ggplot(data, ggplot2::aes(log2(Abundances.Normalized.F1.Sample), log2(Abundances.Normalized.F3.Sample))) +ggplot2::geom_point() +ggplot2::labs(x="F1", y="F3",title="F123",subtitle="",caption="TestFT") + hrbrthemes:: theme_ft_rc()
```


```{r MR}
#https://bioconductor.org/books/3.12/SingleRBook/annotation-diagnostics.html#based-on-the-deltas-across-cells
# Cholesky Factorization
system.time (C <- chol(B))
# Singular Value Decomposition
system.time (S <- svd (A,nu=0,nv=0))
plot(S$d)
# Principal Components Analysis
system.time (P <- prcomp(A))
# Linear Discriminant Analysis
#library('MASS')
#g <- 5
#k <- round (m/2)
#A <- data.frame (A, fac=sample (LETTERS[1:g],m,replace=TRUE))
#train <- sample(1:m, k)
#system.time (L <- lda(fac ~., data=A, prior=rep(1,g)/g, subset=train))
```

```{r}
BiocManager::install("corral")
```

```{r}
#https://bioconductor.org/packages/release/bioc/vignettes/msImpute/inst/doc/msImpute-vignette.html
BiocManager::install(version = "3.12")
BiocManager::install("msImpute")
BiocManager::install("imputeLCMD")
BiocManager::install("ComplexHeatmap")
library(reticulate)
library(msImpute)
library(limma)
library(imputeLCMD)
library(ComplexHeatmap)
data(pxd014777)
y <- pxd014777
```

```{r}
#https://bioconductor.org/packages/release/bioc/vignettes/metabolomicsWorkbenchR/inst/doc/Introduction_to_metabolomicsWorkbenchR.html
BiocManager::install("metabolomicsWorkbenchR")
# search for all studies with "Diabetes" in the title and return a summary
#library(metabolomicsWorkbenchR)
df = metabolomicsWorkbenchR::do_query(context = 'study',input_item = 'study_title',input_value = 'Diabetes',output_item = 'summary')
df[1:3,c(1,4)]
```


```{r COCA}
#https://acabassi.github.io/coca/articles/coca-vignette.html
#install.packages("coca")
data <- list()
data[[1]] <- as.matrix(read.csv(system.file("extdata",
                      "dataset1.csv", package = "coca"), row.names = 1))
data[[2]] <- as.matrix(read.csv(system.file("extdata",
                      "dataset2.csv", package = "coca"), row.names = 1))
data[[3]] <- as.matrix(read.csv(system.file("extdata",
                      "dataset3.csv", package = "coca"), row.names = 1))

### Build matrix of clusters
outputBuildMOC <- coca::buildMOC(data, M = 3, K = 5, distances = "cor")
### Extract matrix of clusters and dataset indicator vector
moc <- outputBuildMOC$moc
datasetIndicator <- outputBuildMOC$datasetIndicator
true_labels <- as.matrix(read.csv(system.file("extdata", "cluster_labels.csv",
                package = "coca"), row.names = 1))
annotations <- data.frame(true_labels = as.factor(true_labels))
### Plot matrix of clusters
coca::plotMOC(moc, datasetIndicator, annotations = annotations)
# Use COCA to find global clustering
coca <- coca::coca(moc, K = 5)
# Compare clustering to the true labels
ari <- mclust::adjustedRandIndex(true_labels, coca$clusterLabels)
ari
```

```{r liger}
install.packages('devtools')
library(devtools)
install_github('MacoskoLab/liger')
```

```{r stan}
#http://mc-stan.org/loo/articles/loo2-with-rstan.html
library("rstan")
# Prepare data 
url <- "http://stat.columbia.edu/~gelman/arm/examples/arsenic/wells.dat"
wells <- read.table(url)
wells$dist100 <- with(wells, dist / 100)
X <- model.matrix(~ dist100 + arsenic, wells)
standata <- list(y = wells$switch, X = X, N = nrow(X), P = ncol(X))
# Fit model
fit_1 <- stan("logistic.stan", data = standata)
print(fit_1, pars = "beta")
#http://mc-stan.org/loo/articles/loo2-with-rstan.html
#install.packages("loo")
library("loo")
# Extract pointwise log-likelihood
# using merge_chains=FALSE returns an array, which is easier to 
# use with relative_eff()
log_lik_1 <- extract_log_lik(fit_1, merge_chains = FALSE)
# as of loo v2.0.0 we can optionally provide relative effective sample sizes
# when calling loo, which allows for better estimates of the PSIS effective
# sample sizes and Monte Carlo error
r_eff <- relative_eff(exp(log_lik_1), cores = 24)
# preferably use more than 2 cores (as many cores as possible)
# will use value of 'mc.cores' option if cores is not specified
loo_1 <- loo(log_lik_1, r_eff = r_eff, cores = 24)
print(loo_1)
#compare
standata$X[, "arsenic"] <- log(standata$X[, "arsenic"])
fit_2 <- stan(fit = fit_1, data = standata)
log_lik_2 <- extract_log_lik(fit_2, merge_chains = FALSE)
r_eff_2 <- relative_eff(exp(log_lik_2))
loo_2 <- loo(log_lik_2, r_eff = r_eff_2, cores = 2)
print(loo_2)
comp <- loo_compare(loo_1, loo_2)
print(comp,simplify=FALSE)
```

```{r edit}
#https://cran.r-project.org/web/packages/DataEditR/vignettes/DataEditR.html
#devtools::install_github("DillonHammill/DataEditR")
#library(DataEditR)
DataEditR::data_edit(df, theme = "cosmo", viewer = FALSE)
mtcars_new <- cbind(as.data.frame(c(1:nrow(df))),rownames(df), df)
colnames(mtcars_new) <- "car"
# Convert characters to factors
mtcars_new <- DataEditR::data_edit(mtcars_new,col_factor = TRUE)
str(mtcars_new)
data_edit(mtcars,col_bind = "fast",col_options = list(fast = c(TRUE,FALSE)))
# Add column for car colour
data_edit(mtcars,col_bind = "col",col_options = list(col = c("red","blue","orange","green","black")))
data_edit(mtcars,col_stretch = TRUE)
```

```{r ComplexHeatmap, echo = FALSE}
#https://jokergoo.github.io/2020/05/06/translate-from-pheatmap-to-complexheatmap/
#BiocManager::install("ComplexHeatmap")
#library(ComplexHeatmap)
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
pheatmap::pheatmap(test)  # this is ComplexHeatmap::pheatmap
#https://github.com/jokergoo/ComplexHeatmap/issues/30#issuecomment-686440241
m = matrix(rnorm(10*50), ncol = 50)
fa = sample(letters[1:4], 50, replace = TRUE)
# ha just found, column_km can be used together with column_split
ComplexHeatmap::Heatmap(m, column_km = 3, column_split = fa, row_split = 2)
#https://jokergoo.github.io/2020/07/06/block-annotation-over-several-slices/
df = data.frame(km = kmeans(t(m), centers = 3)$cluster,fa = fa)
df$km = factor(df$km, levels = c(1, 2, 3))
df$fa = factor(df$fa, levels = letters[1:4])
ComplexHeatmap::Heatmap(m, column_split = df, row_split = 2, cluster_column_slices = FALSE)
```

```{r iq}
#https://www.rdocumentation.org/packages/iq/versions/1.9/vignettes/iq-fast.Rmd
#install.packages("iq")# if not already installed, run install.packages("iq") 
library("iq") 
#wget https://github.com/tvpham/iq/releases/download/v1.1/DIA-report-long-format.zip
raw <- read.delim("L:/promec/Animesh/DIA-report-long-format/DIA-report-long-format.txt")
selected <- raw$F.ExcludedFromQuantification == "False" & !is.na(raw$PG.Qvalue) & (raw$PG.Qvalue < 0.01) & !is.na(raw$EG.Qvalue) & (raw$EG.Qvalue < 0.01)
raw <- raw[selected,]
sample_id  <- "R.FileName" 
secondary_id <- c("EG.Library", "FG.Id", "FG.Charge", "F.FrgIon", "F.Charge", "F.FrgLossType")
norm_data <- iq::preprocess(raw, sample_id  = sample_id, secondary_id = secondary_id)
protein_list <- iq::create_protein_list(norm_data)
result <- iq::create_protein_table(protein_list)
annotation_columns <- c("PG.Genes", "PG.ProteinNames")
extra_names <- iq::extract_annotation(rownames(result$estimate), raw, annotation_columns = annotation_columns)
write.table(cbind(Protein = rownames(result$estimate),
                  extra_names[, annotation_columns],
                  MaxLFQ_annotation = result$annotation,
                  result$estimate),
            "iq-MaxLFQ.txt", sep = "\t", row.names = FALSE)
result_faster <- iq::fast_MaxLFQ(norm_data)
cat("Max difference =", max(abs(result_faster$estimate - result$estimate), na.rm = TRUE), "\n")
cat("Identical NAs =", identical(is.na(result_faster$estimate), is.na(result$estimate)), "\n")
cat("Equal annotation =", identical(result_faster$annotation, result$annotation), "\n")
system.time({
    protein_list <- iq::create_protein_list(norm_data)
    result <- iq::create_protein_table(protein_list)
})

system.time({
    result_faster <- iq::fast_MaxLFQ(norm_data)
})

sample_id  <- "R.FileName" 

secondary_id <- c("EG.Library", "FG.Id", "FG.Charge", "F.FrgIon", "F.Charge", "F.FrgLossType")

annotation_columns <- c("PG.Genes", "PG.ProteinNames")

iq_dat <- iq::fast_read("DIA-report-long-format.txt",
                        sample_id  = sample_id, 
                        secondary_id = secondary_id,
                        filter_string_equal = c("F.ExcludedFromQuantification" = "False"),
                        annotation_col = annotation_columns)

iq_norm_data <- iq::fast_preprocess(iq_dat$quant_table)

result_fastest <- iq::fast_MaxLFQ(iq_norm_data, 
                                  row_names = iq_dat$protein[, 1], 
                                  col_names = iq_dat$sample)

cat("Max difference =", max(abs(result_fastest$estimate - result$estimate), na.rm = TRUE), "\n")

cat("Identical NAs =", identical(is.na(result_fastest$estimate), is.na(result$estimate)), "\n")

cat("Equal annotation =", identical(result_fastest$annotation, result$annotation), "\n")

iq_extra_names <- iq::extract_annotation(rownames(result_fastest$estimate), 
                                         iq_dat$protein, 
                                         annotation_columns = annotation_columns)

write.table(cbind(Protein = rownames(result_fastest$estimate),
                  iq_extra_names[, annotation_columns],
                  MaxLFQ_annotation = result_fastest$annotation,
                  result_fastest$estimate), 
            "iq-MaxLFQ-fast.txt", sep = "\t", row.names = FALSE)

sample_id  <- "R.FileName" 

secondary_id <- c("EG.Library", "FG.Id", "FG.Charge", "F.FrgIon", "F.Charge", "F.FrgLossType")

annotation_columns <- c("PG.Genes", "PG.ProteinNames")

system.time({

    # reading data
    raw <- read.delim("DIA-report-long-format.txt")

    # filtering
    selected <- raw$F.ExcludedFromQuantification == "False" & 
                !is.na(raw$PG.Qvalue) & raw$PG.Qvalue < 0.01 &
                !is.na(raw$EG.Qvalue) & raw$EG.Qvalue < 0.01

    raw <- raw[selected,]

    ## process

    norm_data <- iq::preprocess(raw, 
                                sample_id  = sample_id, 
                                secondary_id = secondary_id)

    protein_list <- iq::create_protein_list(norm_data)

    result <- iq::create_protein_table(protein_list)

})

system.time({
    iq_dat <- iq::fast_read("DIA-report-long-format.txt",
                            sample_id  = sample_id, 
                            secondary_id = secondary_id,
                            filter_string_equal = c("F.ExcludedFromQuantification" = "False"),
                            annotation_col = annotation_columns)

    iq_norm_data <- iq::fast_preprocess(iq_dat$quant_table)

    result_fastest <- iq::fast_MaxLFQ(iq_norm_data, 
                                      row_names = iq_dat$protein[, 1], 
                                      col_names = iq_dat$sample)
})

```

```{r proteus}
#BiocManager::install("limma")
#devtools::install_github("bartongroup/proteusLabelFree")
#devtools::install_github("bartongroup/Proteus", build_opts= c("--no-resave-data", "--no-manual"), build_vignettes=F)
library(proteus)
evidenceFile <- system.file("extdata", "evidence.txt.gz", package="proteusLabelFree")
metadataFile <- system.file("extdata", "metadata.txt", package="proteusLabelFree")
evi <- readEvidenceFile(evidenceFile)
meta <- read.delim(metadataFile, header=TRUE, sep="\t")
pepdat <- makePeptideTable(evi, meta)
prodat <- makeProteinTable(pepdat)
prodat.med <- normalizeData(prodat)
res <- limmaDE(prodat.med)
plotVolcano_live(prodat.med, res)
```

```{r treeclimbR, echo = FALSE}
#https://github.com/fionarhuang/treeclimbR
#devtools::install_github("fionarhuang/treeclimbR")
#https://fionarhuang.github.io/treeclimbR_toy_example/toy_signal.html
# wilcox.test
test.func <- function(X, Y) {  
    Y <- as.numeric(factor(Y))
    obj <- apply(X, 1, function(x) {                
        p.value <- suppressWarnings(wilcox.test(x ~ Y)$p.value)
        e.sign <- sign(mean(x[Y == 2]) - mean(x[Y == 1]))
        c(p.value, e.sign)          
    })
    return(list(p.value=obj[1, ], e.sign=obj[2, ])) 
}
Y <- colData(tse)$group
X <- assays(tse)[[1]]
resW <- test.func(X,Y)
outW <- data.frame(node = rowLinks(tse)$nodeNum,
                   pvalue = resW$p.value,
                   sign = resW$e.sign)
```

```{r propR, echo = FALSE}
#Calculating Proportionality Between Vectors of Compositional Data https://cran.r-project.org/web/packages/propr/propr.pdf
#devtools::install_github("tpq/propr")
install.packages("propr")
library(propr)
counts <- matrix(rpois(20*50, 100), 20, 50)
group <- sample(c("A", "B"), size = 20, replace = TRUE)
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
pr <- propr(counts, # rows as samples, like it should be
            metric = "rho", # or "phi", "phs", "cor", "vlr"
            ivar = "clr", # or can use "iqlr" instead
            alpha = NA, # use to handle zeros
            p = 100) # used by updateCutoffs
updateCutoffs(pr,cutoff = seq(0, 1, .05), # cutoffs at which to estimate FDR
              ncores = 1) # parallelize here
pd <- propd(counts,group, # a vector of 2 or more groups
            alpha = NA, # whether to handle zeros
            weighted = TRUE, # whether to weigh log-ratios
            p = 100) # used by updateCutoffs
setDisjointed(pd)
setEmergent(pd)
pd <- updateF(pd,moderated = FALSE, # moderate stats with limma-voom
              ivar = "clr") # used for moderation
```

```{r scDAseq}
#https://klugerlab.github.io/DAseq/articles/tutorial.html
devtools::install_github("KlugerLab/DAseq")
```

```{r tidyHM}
#https://github.com/stemangiola/tidyHeatmap
#install.packages("tidyHeatmap")
#install.packages("tidyr")
library(tidyr)
pasilla_plus <- 
    tidyHeatmap::pasilla %>%
        dplyr::mutate(act = activation) %>% 
        tidyr::nest(data = -sample) %>%
        dplyr::mutate(size = rnorm(n(), 4,0.5)) %>%
        dplyr::mutate(age = runif(n(), 50, 200)) %>%
        tidyr::unnest(data) 

# Plot
pasilla_plus %>%
        heatmap(
            .column = sample,
            .row = symbol,
            .value = `count normalised adjusted`
        ) %>%
    add_tile(condition) %>%
    add_point(activation) %>%
    add_tile(act) %>%
    add_bar(size) %>%
    add_line(age)
```

```{r POMA}
#https://pcastellanoescuder.github.io/POMA/articles/POMA-eda.html
#BiocManager::install("POMA")
library(POMA)
```

```{r anamoly}
#https://github.com/pridiltal/stray
#devtools::install_github("pridiltal/stray")
library(stray)
require(ggplot2)
#> Loading required package: ggplot2
set.seed(1234)
data <- c(rnorm(1000, mean = -6), 0, rnorm(1000, mean = 6))
outliers <- find_HDoutliers(data, knnsearchtype = "brute")
names(outliers)
#> [1] "outliers"   "out_scores" "type"
display_HDoutliers(data, outliers)
#Two dimensional dataset with 8 outliers
set.seed(1234)
n <- 1000 # number of observations
nout <- 10 # number of outliers
typical_data <- matrix(rnorm(2*n), ncol = 2, byrow = TRUE)
out <- matrix(5*runif(2*nout,min=-5,max=5), ncol = 2, byrow = TRUE)
data <- rbind(out, typical_data )
outliers <- find_HDoutliers(data, knnsearchtype = "brute")
display_HDoutliers(data, outliers)
#3D
data <- rbind(matrix(rnorm(144), ncol = 3), c(10,12,10),c(3,7,10))
output <- find_HDoutliers(data, knnsearchtype = "brute")
display_HDoutliers(data, out = output)
#more
outliers<-find_HDoutliers(data_c[,1:2], knnsearchtype= "brute")
p <- display_HDoutliers(data_c[,1:2], outliers)+ggplot2::ggtitle("data_c")
print(p)
#non
outliers<-find_HDoutliers(data_d[,1:2], knnsearchtype= "brute")
p <- display_HDoutliers(data_d[,1:2], outliers)+ggplot2::ggtitle("data_d")
print(p)
```

```{r HieRFIT}
#https://www.biorxiv.org/content/10.1101/2020.09.16.300822v1
#https://github.com/yasinkaymaz/HieRFIT 
#devtools::install_github("yasinkaymaz/HieRFIT")
library(HieRFIT)
#BiocManager::install("Seurat")
library(Seurat)
pbmc <- readRDS("pbmc3k_final.Rds")
pbmc <- UpdateSeuratObject(pbmc)
```

```{r beta-A/B}
#https://www.countbayesie.com/blog/2020/8/16/why-bayesian-stats-need-monte-carlo-methods
N <- 10000
a_samples <- rbeta(N,2+1,13+1)
b_samples <- rbeta(N,3+1,11+1)
sum(b_samples > a_samples)/N
plot(a_samples,b_samples)
hist(b_samples-a_samples)
sum((b_samples-a_samples)>0)
```

```{r PRIMME}
#https://github.com/primme/primme/tree/master/R
#install.packages("PRIMME")
library(PRIMME)
A <- diag(1:10) 
r <- eigs_sym(A, 3);
r
plot(r$vectors)
plot(r$values,r$rnorms)
```

```{r causalML}
#https://github.com/animesh/causalML
#https://cran.r-project.org/web/packages/bnlearn/bnlearn.pdf
install.packages("bnlearn")
library(bnlearn)
data(alarm)
bn.cv(alarm, bn = "hc", algorithm.args = list(score = "bde", iss = 1))
#https://www.bnlearn.com/examples/xval/
#  k-fold cross-validation for Bayesian networks
# target learning algorithm:             Hill-Climbing
#  number of folds:                       10
#  loss function:                         Log-Likelihood Loss (disc.)
#  expected loss:                         10.82617
```

```{r pepFunc, echo = FALSE}
#source https://github.com/northomics/pepFunk
library(rhandsontable)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
library(colourpicker)
library(reshape2)
library(DT)
library(tidyverse)
library(plyr)
library(DESeq2)
library(GSVA)
library(limma)
library(ggdendro)
library(plotly)
library(dendextend)
library(LaCroixColoR) #devtools::install_github("johannesbjork/LaCroixColoR")
library(shinycssloaders)
# install.packages.auto(rhandsontable)
# devtools::install_github("johannesbjork/LaCroixColoR")
# install.packages.auto(DESeq2)
# install.packages.auto(GSVA)
#
# # if (!requireNamespace("BiocManager", quietly = TRUE))
# # install.packages("BiocManager")
# #
# # BiocManager::install("DESeq2")
# # BiocManager::install("GSVA")

# The proteinGroup files are large, increase the limit of file upload size to 500MB
options(shiny.maxRequestSize=500*1024^2)

source("peptide_centric_functions.R")
source("peptide_centric_module.R")



########
# DATA # # should add files to this folder
########

## Full KEGG database
kegg_L3 <- read.delim("./www/kegg_L3.txt", sep='\t', header=F,
                      col.names=c('L3', 'L3_desc', 'L4', 'L4_desc'),
                      colClasses=c('character','character','character','character')) %>% as.data.frame()
pathways <- kegg_L3$L4_desc %>% unique()
pathways <- pathways[-c(208:229)] #removing KO that are not in brite/pathway
pathway_kegg <- dlply(kegg_L3 %>% dplyr::select(L4_desc, L3), .(L4_desc))

## peptide to KEGG database now loaded depending on user's choice in server_analyze.R

#  _header ------------------------------------------------------


header <- dashboardHeader(title = span(img(src="logo_imetalab.png", width = 140), "pepFunk"),
                          titleWidth = 460,
                          tags$li(class = "dropdown",
                                  tags$a(tags$img(height = "18px", alt="SNAP Logo", src="logo_M.png")
                                  ),
                            tags$head(
                                    tags$link(rel = "stylesheet", type = "text/css", href = "./www/custom.css")
                                  )
                          )
)


#  _side bar ------------------------------------------------------

sidebar <- dashboardSidebar(
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "custom.css")
  ),
  width = 250,
  sidebarMenu(
    id = "tabs",
    menuItem("Upload Data", tabName = "dashboard", icon = icon("file")),
    # Get icon codes from here: https://fontawesome.com/v4.7.0/icons/
    sidebarMenuOutput("menu1"),
    menuItem("Analysis", tabName = "Analysis", icon = icon("file")),
    menuItem("Gallery", tabName = "gallery", icon = icon("picture-o")),
    menuItem("About", tabName = "about", icon = icon("question-circle")),
    menuItem("iMetaLab", icon = icon("home"),
             href = "http://www.imetalab.ca"),
    menuItem("pepFunk on GitHub", icon=icon("github"),
             href = "https://github.com/northomics/pepFunk")

  )
)


# _body --------------------------------------------------------------

body <- dashboardBody(
  tags$head(
    tags$link(rel = "stylesheet", type = "text/css", href = "custom.css")
  ),
  tabItems(
    #  ___dashboard/starting  tab  ------------------------------------------------------
    tabItem(tabName = "dashboard",
            source(
              file = "ui_dashboard.R",
              local = TRUE,
              encoding = "UTF-8"
            )$value),
    tabItem(tabName = "Analysis",
            source(
              file = "ui_analyze.R",
              local = TRUE,
              encoding = "UTF-8"
            )$value),
    tabItem(tabName = "gallery",
            tabItem(tabName = "gallery",
                    fluidRow(
                      box(
                        title = "PCA analysis",
                        solidHeader = TRUE,
                        status = "primary",
                        width = 6,
                        img(src='gallery/PCA.png')
                      ),
                      box(
                        title = "Heatmap of enriched functions",
                        solidHeader = TRUE,
                        status = "primary",
                        width = 6,
                        img(src='gallery/Heat.png')
                      )
                    )
            )
            ),
    tabItem(tabName = "about",
            fluidRow(
              box(
                title = "About pepFunk, a metaproteomic peptide-centric functional enrichment workflow.",
                solidHeader = TRUE,
                status = "primary",
                width = 12,
                "Welcome to pepFunk!",
                br(),
                "pepFunk allows you to complete a peptide-focused functional enrichment workflow for gut microbiome metaproteomic studies.

                This workflow uses KEGG annotation for pathway enrichment, alongside Gene Set Variation Analysis (GSVA) adapted for peptide data.
                By completing analysis on peptides, rather than proteins, we lose less information and retain more statistical power.
                We curated peptide database specific to human gut microbiome studies for computational speed.
              "
              )
            )
    )
  ),
  #Semi-collapsible sidebar
  tags$script(HTML("$('body').addClass('sidebar-mini');"))
)



# ------ UI ---------------------------
ui <- dashboardPage(
  title = "pepFunk",
  header,
  sidebar,
  body,
)


server <- function(input, output, session) {
  source(file = "server_analyze.R",
         local = TRUE,
         encoding = "UTF-8")
  output.fileUploaded1 = TRUE
}

shinyApp(ui, server)
```

```{r proVision, echo = FALSE}
#source https://github.com/JamesGallant/ProVision
#plot
#shiny being unreasonable
#library(BiocManager)
#options(repos = BiocManager::repositories())
#Libraries we need

#Modal doesnt load when tut is loaded, need to rename files for it to work.
#Double check the javascript


require(shinydashboard)
require(shiny)
library(tidyr)
require(ggplot2)
require(dplyr)
require(reshape2)
require(shinydashboardPlus)
require(DT)
#BiocManager::install(shinyjs)
#install.packages("shinyjs")
require(shinyjs)
require(stringr)
require(rhandsontable)
require(colourpicker)
#install.packages("shinyWidgets")
require(shinyWidgets)
require(RColorBrewer)
require(Hmisc)
require(limma)
require(ggrepel)
require(pheatmap)
require(rJava)
require(zip)
require(xlsx)
require(WebGestaltR)
#install.packages("shinycssloaders")
require(shinycssloaders)
#install.packages("httr")
require(httr)
#install.packages("colourpicker")
#install.packages("WebGestaltR")

#user interface starts here
ui <- dashboardPage(
  skin = "blue",
  dashboardHeader(title = "ProVision"),
  dashboardSidebar(useShinyjs(),
                   useSweetAlert(),
                   #welcome side bar menu
                   conditionalPanel(condition = "input.main_tabs == 'welcome'",
                                    sidebarMenu(
                                     #menuitems
                                      menuItem("Tutorials",startExpanded = TRUE,
                                               radioButtons(inputId = "tutOptions",
                                                            label = "choose tutorial options",
                                                            choices = c("Quick start" = "quickStart",
                                                                        "Full" = "full"),
                                                            selected = "quickStart"),
                                               disabled(
                                                 radioButtons(inputId = "fullTutPages",
                                                              label = "Load tutorial pages",
                                                              choices = c("Getting started" = "gs",
                                                                          "Data processing" = "dp",
                                                                          "Quality metrics" = "qm",
                                                                          "Statistics" = "stats",
                                                                          "Main figures" = "mf",
                                                                          "Export" = "exp"),
                                                              selected = "gs")
                                               ),
                                               actionButton(inputId = "goTut",
                                                            icon = icon("play-circle"),
                                                            label = "Go",
                                                            style = "width:200px")),
                                      menuItem("Citation",
                                               startExpanded = T,
                                               radioButtons(inputId = "citation_options",
                                                            label = "Cite this software and it's dependencies",
                                                            choices = c("All",
                                                                        "ProVision" = "Provision",
                                                                        "Limma",
                                                                        "Webgestalt",
                                                                        "StringDB"),
                                                            selected = "All"),
                                               downloadButton(outputId = "citation_download",
                                                              label = "Download",
                                                              style="display: block; margin: 0 auto; width: 200px;color: black;")))),
                   #data handling sidebar menu
                   conditionalPanel(condition = "input.main_tabs == 'data_handling'",
                                    sidebarMenu(
                                      actionButton(inputId = "DataProcTut",
                                                   label = "Show tutorial",
                                                   width = 200,
                                                   icon = icon("graduation-cap")),
                                      #this is where we handle file uploadinh
                                      menuItem("Upload your files", tabName = "file_upload",
                                               icon = icon("upload"),
                                               fileInput("user_file", "Choose your file",
                                                         accept = c("text/csv",
                                                                    "text/comma-separated-value",
                                                                    ".txt")),
                                               radioButtons(inputId = "userQuants",
                                                            label = "Choose quantification",
                                                            choices = c("Intensity" = "intensity",
                                                                        "LFQ intensity" = "lfq",
                                                                        "TMT tags" = "tmt"),
                                                            selected = "lfq"),
                                               uiOutput("TMTplexUI"),
                                               actionButton(inputId = "fileReset",
                                                            label = "Reset all data",
                                                            width = 200,
                                                            icon = icon("redo"))),
                                      #Filtering comes here
                                      menuItem("Filter and Transform", tabName = "file_filter",
                                               icon = icon("filter"),
                                               prettySwitch(
                                                 inputId = "unlockCols",
                                                 label = "Enable column editing",
                                                 status = "primary",
                                                 slim = TRUE),
                                               uiOutput("addRemCols"),
                                               #filtering buttons
                                               numericInput(inputId = "user_unique_pep",
                                                            value = 2,
                                                            label = "Minimum unique peptides",
                                                            min = 1),
                                               checkboxInput(inputId = "logTransform",
                                                             label = "Log2 transform data",
                                                             value = TRUE),
                                               checkboxInput(inputId = "median_center",
                                                             label = "Subtract the median",
                                                             width = 200,
                                                             value = FALSE),
                                               #this activates the filtering process
                                               actionButton(inputId = "activate_filter",
                                                            label = "Start filtering",
                                                            icon = icon("play-circle"),
                                                            width = 200)),
                                      menuItem("Assign groups",
                                               icon = icon("clone"),
                                               div(style = "text-align:center", "Click to render annotation table"),
                                               actionButton(inputId = "start_anno",
                                                            label = "Start",
                                                            icon = icon("play-circle"),
                                                            width = 200),
                                               br(),
                                               div(style = "text-align:center", "Your input in the second table",
                                                   br(), "will be used for stastical",
                                                   br(), "comparisons. Make sure to",
                                                   br(), "rename your replicates with",
                                                   br(), "the same annotion.",
                                                   br(), "Example:"),
                                               img(src = 'media/annotations.png', width = '100%'),
                                               div(style = "text-align:center", "once done renaming press",
                                                   br(), "submit to lock in the annotation"),
                                               actionButton(inputId = "submit_anno",
                                                            label = "Submit",
                                                            icon = icon("running"),
                                                            width = 200)),
                                      menuItem("Filter valid values",
                                               icon = icon("filter"),
                                               numericInput(inputId = "min_val_user",
                                                            label = "Minimum values per replicate",
                                                            value = 2,
                                                            min = 1
                                               ),
                                               radioButtons(inputId = "in_one_user",
                                                            label = "Filter valid values",
                                                            choices = c("In at least one group" = "one_group",
                                                                        "In each group"= "each_group",
                                                                        "Remove all missing values" = "entire_df"),
                                                            selected = "one_group"),
                                               actionButton(inputId = "filter_valids",
                                                            label = "filter",
                                                            icon = icon("filter"),
                                                            width = 200)),

                                      #imputation
                                      menuItem("Impute missing values",
                                               icon = icon("cogs"),
                                               br(),
                                               div(style = "text-align:left",
                                                   tags$b("Control imputation metrics"), br(),
                                                   "enable at own risk"),
                                               switchInput(inputId = "EnableImputeControl",
                                                           onLabel = "Yes", offLabel = "No",
                                                           onStatus = "danger", offStatus = "primary",
                                                           value = FALSE),
                                               disabled(numericInput(inputId = "imputeWidth",
                                                                     label = "Select width",
                                                                     value = 0.3),
                                                        numericInput(inputId = "imputeDS",
                                                                     label = "Select downshift",
                                                                     value = 1.8)),
                                               actionButton(inputId = "start_imputation",
                                                            label = "Start imputing",
                                                            width = 200,
                                                            icon = icon("play-circle"))),
                                      menuItem("Download tables",
                                               icon = icon("download"),
                                               actionButton(inputId = "tut_dataPreProcExport",
                                                            label = "Show tutorial",
                                                            width = 200,
                                                            icon = icon("graduation-cap")),
                                               textInput(inputId = "ProcDataDownName",
                                                         label = "File name",
                                                         placeholder = "My awesome data"),
                                               radioButtons(inputId = "ProcDataDownType",
                                                            label = "File type",
                                                            choices = c("Excel" = "xlsx",
                                                                        "Text" = "txt"),
                                                            selected = "xlsx"),
                                               uiOutput("ProcDataSelectorUI"),
                                               downloadButton(outputId = "filt1_download",
                                                              label = "Download",
                                                              style="display: block; margin: 0 auto; width: 200px;color: black;")))),
                   #qualityMetrics sidebar
                   conditionalPanel(condition = "input.main_tabs == 'quality_metrics'",
                                    sidebarMenu(
                                      actionButton(inputId = "tut_QC",
                                                   label = "Show tutorial",
                                                   width = 200,
                                                   icon = icon("graduation-cap")),
                                      #QQ-plots
                                      menuItem("Normality plots",
                                               icon = icon("line-chart"),
                                               actionButton(inputId = "normRender",
                                                            label = "Render Plot",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               div(style = "text-align:center; color: white, ",
                                                   tags$b("Cycle through plots")),
                                               disabled(actionButton(inputId = "normPrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "normNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               br(),
                                               radioButtons(inputId = "normPlotChoice",
                                                            label = "Choose plot type",
                                                            choices = c("Q-Q plot" = "qqPlot",
                                                                        "Histogram" = "histogram"),
                                                            selected = "qqPlot", inline = TRUE),
                                               colourInput(inputId = "normPlotCol",
                                                           label = "Choose border colour",
                                                           showColour = "both",
                                                           palette = "limited",
                                                           value = "#000000"),
                                               colourInput(inputId = "normPlotFill",
                                                           label = "Choose fill colour",
                                                           showColour = "both",
                                                           palette = "limited",
                                                           value = "#666666"),
                                               uiOutput("normality_control1"),
                                               uiOutput("normality_control2"),
                                               uiOutput("normality_control3"),
                                               uiOutput("normality_control4"),
                                               uiOutput("normality_control5"),
                                               br(),
                                               menuItem(text = "Downloads",
                                                        icon = icon("download"),
                                                        radioButtons(inputId = "normFigDownChoice",
                                                                     label = "Download:",
                                                                     choices = c("All", "Current"),
                                                                     selected = "Current", inline = TRUE),
                                                        selectInput(inputId = "normFigDownType",
                                                                    label = "Filetype",
                                                                    choices = c("tiff", "jpeg",
                                                                                "png", "pdf"),
                                                                    selected = "tiff"),
                                                        selectInput(inputId = "normFigRes",
                                                                    label = "Figure resolution",
                                                                    choices = c("High" = "retina",
                                                                                "Medium" = "print",
                                                                                "low" = "screen"),
                                                                    selected = "300"),
                                                        downloadButton(outputId = "normFigDownload",
                                                                       label = "download",
                                                                       style="display: block; margin: 0 auto; width: 200px;color: black;"))
                                      ),
                                      #scatter plots
                                      menuItem("Scatter plots",
                                               icon = icon("line-chart"),
                                               actionButton(inputId = "scatRender",
                                                            label = "Render Plot",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               div(style = "text-align:center; color: white, ",
                                                   tags$b("Cycle through scatter plots")),
                                               disabled(actionButton(inputId = "scatPrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "scatNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               textInput(inputId = "scatTitle",
                                                         label = "Label plot",
                                                         value = "",
                                                         placeholder = "My scatter plot"),
                                               colourInput(inputId = "scat_point_col",
                                                           label = "plot point color", showColour = "both",
                                                           palette = "limited",
                                                           value = "#000000"),
                                               sliderInput(inputId = "scatPlotAlphaChannel",
                                                           label = "Change transparency",
                                                           min = 0.1, max = 1, step = 0.1,
                                                           value = 1),
                                               sliderInput(inputId = "scatPointSize",
                                                           label = "Point size",
                                                           min = 0.5, max = 5, step = 0.5,
                                                           value = 1),
                                               radioButtons(inputId = "scatCharcters",
                                                            label = "Select point type",
                                                            choices = c("Circle" = 21,
                                                                        "Square" = 22,
                                                                        "Diamond"= 23,
                                                                        "Triangle 1" = 24,
                                                                        "Triangle2" = 25),
                                                            selected = 21),
                                               menuItem(text = "Downloads",
                                                        icon = icon("download"),
                                                        radioButtons(inputId = "scatFigDownChoice",
                                                                     label = "Download:",
                                                                     choices = c("All", "Current"),
                                                                     selected = "Current", inline = TRUE),
                                                        selectInput(inputId = "scatFigDownType",
                                                                    label = "Filetype",
                                                                    choices = c("tiff", "jpeg",
                                                                                "png", "pdf"),
                                                                    selected = "tiff"),
                                                        selectInput(inputId = "scatFigRes",
                                                                    label = "Figure resolution",
                                                                    choices = c("High" = "retina",
                                                                                "Medium" = "print",
                                                                                "low" = "screen"),
                                                                    selected = ""),
                                                        downloadButton(outputId = "scatFigDownload",
                                                                       label = "download",
                                                                       style="display: block; margin: 0 auto; width: 200px;color: black;"))),
                                      menuItem("Correllelogram",
                                               icon = icon("line-chart"),
                                               actionButton(inputId = "corrRender",
                                                            label = "Render Plot",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               textInput(inputId = "corrPlotTitle", label = "Enter plot title"),
                                               checkboxInput(inputId = "corrValDisp",
                                                             label = "Show correlation value",
                                                             value = TRUE ),
                                               radioButtons(inputId = "corrColChoice",
                                                            label = "Choose correlation colour gradient",
                                                            choices = c("Red-Yellow-Blue" = "RdYlBu",
                                                                        "Red-Blue" = "RdBu",
                                                                        "Purple-Orange" = "PuOr",
                                                                        "Purple-Green" = "PRGn",
                                                                        "Purple-Yellow-Green" = "PiYG",
                                                                        "Brown-Blue-Green" = "BrBG"),
                                                            selected = "RdYlBu"),
                                               radioButtons(inputId = "correlation_test",
                                                            label = "Correlation test",
                                                            choices = c("Pearson" = "pearson",
                                                                        "Spearman" = "spearman"),
                                                            selected = "pearson",
                                                            inline = TRUE),
                                               sliderInput(inputId = "corrSlider",
                                                           label = "Set lower correlation limit",
                                                           min = 0, max = 1, step = 0.05, value = 0),
                                               menuItem(text = "Downloads",
                                                        icon = icon("download"),
                                                        selectInput(inputId = "corrFigDownType",
                                                                    label = "Filetype",
                                                                    choices = c("tiff", "jpeg",
                                                                                "png", "pdf"),
                                                                    selected = "tiff"),
                                                        selectInput(inputId = "corrFigRes",
                                                                    label = "Figure resolution",
                                                                    choices = c("High" = "retina",
                                                                                "Medium" = "print",
                                                                                "low" = "screen"),
                                                                    selected = ""),
                                                        downloadButton(outputId = "corrFigDownload",
                                                                       label = "download",
                                                                       style="display: block; margin: 0 auto; width: 200px;color: black;"))),
                                      #Principle componet analysis
                                      menuItem("PCA plots",
                                               icon = icon("line-chart"),
                                               actionButton(inputId = "pcaRender",
                                                            label = "Render Plot",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               textInput(inputId = "pcaPlotTitle", label = "Enter plot title"),
                                               checkboxInput(inputId = "pcaZscore",
                                                             label = "Z-score data",
                                                             value = TRUE),
                                               sliderInput(inputId = "pcaPlotPointSize", label = "change point size",
                                                           min = 1, max = 10, step = 1,
                                                           value = 4),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Colour by group")),
                                                        icon = icon("swatchbook"),
                                                        uiOutput("pcaColChoice")),
                                               sliderInput(inputId = "pcaAlphaChannel", label = "Change transparency",
                                                           min = 0.1, max = 1, step = 0.1, value = 1),
                                               menuItem(text = "Downloads",
                                                        icon = icon("download"),
                                                        selectInput(inputId = "pcaFigDownType",
                                                                    label = "Filetype",
                                                                    choices = c("tiff", "jpeg",
                                                                                "png", "pdf"),
                                                                    selected = "tiff"),
                                                        selectInput(inputId = "pcaFigRes",
                                                                    label = "Figure resolution",
                                                                    choices = c("High" = "retina",
                                                                                "Medium" = "print",
                                                                                "low" = "screen"),
                                                                    selected = ""),
                                                        downloadButton(outputId = "pcaFigDownload",
                                                                       label = "download",
                                                                       style="display: block; margin: 0 auto; width: 200px;color: black;")))#PCA close
                                    )
                   ), #QC metrics close
                   #statistics sidebar
                   conditionalPanel(condition = "input.main_tabs == 'statistics'",
                                    sidebarMenu(
                                      actionButton(inputId = "tut_stats",
                                                   label = "Show tutorial",
                                                   width = 200,
                                                   icon = icon("graduation-cap")),
                                      menuItem(text = "Analyse data",
                                               icon = icon("calculator"),
                                               radioButtons(inputId = "ComparisonSwitch",
                                                            label = "Switch comparison",
                                                            choices = c("A-B" = 1,
                                                                        "B-A" = 2),
                                                            selected = 1, inline = TRUE),
                                               uiOutput("statComparisonMat"),
                                               radioButtons(inputId = "UserSigCutoff",
                                                            label = "Choose significance cut off",
                                                            choices = c("Less than 0.05" = 0.05,
                                                                        "Less than 0.01" = 0.01),
                                                            selected = 0.05),
                                               sliderInput(inputId = "UserFCCutoff",
                                                           label = "Choose log Fold change cutt off",
                                                           min = 0, max = 3, step = 0.5,
                                                           value = 1,
                                                           ticks = TRUE),
                                               radioButtons(inputId = "pvalAdjust",
                                                            label = "Choose p-value adjustment",
                                                            choices = c("Benjamini-Hochberg FDR" = "BH",
                                                                        "Bonferonni" = "bonferroni",
                                                                        "Hommel" = "hommel",
                                                                        "Benjamini-Yekutieli" = "BY"),
                                                            selected = "BH"),
                                               actionButton(inputId = "calculateStats",
                                                            label = "Calculate",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               disabled(actionButton(inputId = "statCyclePrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "statCycleNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"))),
                                      menuItem("Download tables",
                                               icon = icon("download"),
                                               actionButton(inputId = "tut_statsExport",
                                                            label = "Show tutorial",
                                                            width = 200,
                                                            icon = icon("graduation-cap")),
                                               textInput(inputId = "SigDataDownName",
                                                         label = "File name",
                                                         placeholder = "My awesome data"),
                                               radioButtons(inputId = "WhichSigDataDown",
                                                            label = "Download:",
                                                            choices = c("All comparisons" = "all",
                                                                        "Current comparison" = "current"),
                                                            selected = "current"),
                                               radioButtons(inputId = "SigDataDownType",
                                                            label = "File type",
                                                            choices = c("Excel" = "xlsx",
                                                                        "Text" = "txt"),
                                                            selected = "xlsx"),
                                               uiOutput("SigDataSelectorUI"),
                                               downloadButton(outputId = "SigDownload",
                                                              label = "Download",
                                                              style="display: block; margin: 0 auto; width: 200px;color: black;"))
                                    )
                   ),
                   #figure construction sidebar
                   conditionalPanel(condition = "input.main_tabs == 'figures'",
                                    sidebarMenu(
                                      actionButton(inputId = "tut_mainFigs",
                                                   label = "Show tutorial",
                                                   width = 200,
                                                   icon = icon("graduation-cap")),
                                      menuItem("Volcano plots",
                                               icon = icon("chart-line"),
                                               actionButton(inputId = "generateVolcs",
                                                            label = "Render plots",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               div(style = "text: align-left; color: white,", tags$b("Current comparison")),
                                               verbatimTextOutput(outputId = "currentCompareText"),
                                               br(),
                                               disabled(actionButton(inputId = "volcCyclePrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "volcCycleNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Alter point characteristics")),
                                                        icon = icon("swatchbook"),
                                                        sliderInput(inputId = "volcPlotPointSize", label = "change point size",
                                                                    min = 1, max = 10, step = 1,
                                                                    value = 3),
                                                        sliderInput(inputId = "volcAlphaChannel", label = "Change transparency",
                                                                    min = 0.1, max = 1, step = 0.1, value = 1),
                                                        colourInput(inputId = "volcDown",
                                                                    label = "Downregulated", showColour = "both",
                                                                    palette = "limited",
                                                                    value = "blue"),
                                                        colourInput(inputId = "volcUp",
                                                                    label = "Upregulated", showColour = "both",
                                                                    palette = "limited",
                                                                    value = "red"),
                                                        colourInput(inputId = "volcNS",
                                                                    label = "Non significant", showColour = "both",
                                                                    palette = "limited",
                                                                    value = "#000000")
                                               ),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Label significant proteins")),
                                                        icon = icon("tags"),
                                                        radioButtons(inputId = "volcSigLabels",
                                                                     label = "Display labels",
                                                                     choices = c("None", "Upregulated", "Downregulated", "Both"),
                                                                     selected = "None"),
                                                        sliderInput(inputId = "volclabelNoOfSig",
                                                                    label = "Label top signficantly regulated proteins",
                                                                    min = 1, max = 30, step = 1, value = 0)),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Plot title control")),
                                                        icon = icon("heading"),
                                                        textInput(inputId = "volcTitle",
                                                                  label = "Enter plot title",
                                                                  value = ""),
                                                        sliderInput(inputId = "volcTitlePos",
                                                                    label = "Set title position",
                                                                    min = 0, max = 1, step = 0.1,
                                                                    value = 0),
                                                        radioButtons(inputId = "VolcTitleFace",
                                                                     label = "Title face",
                                                                     choices = c("plain", "bold",
                                                                                 "italic", "bold.italic"))),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Alter plot characteristics")),
                                                        icon = icon("gears"),
                                                        radioButtons(inputId = "volcLegendPostition", label = "Legend position",
                                                                     choices = c("right", "left", "top", "bottom", "none"),
                                                                     selected = "top"),
                                                        radioButtons(inputId = "volcFeatures",
                                                                     label = "display:",
                                                                     choices = c("Lines", "Counts", "Both", "None"),
                                                                     selected = "Both"))
                                      ),
                                      menuItem("Heatmaps",
                                               icon = icon('chart-line'),
                                               actionButton(inputId = "generateHM",
                                                            label = "Render Heatmap",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               radioButtons(inputId = "HMAllorSig",
                                                            label = "Plot:",
                                                            choices = c("All proteins" = "All", "Significant proteins" = "Sig"),
                                                            selected = "Sig"),
                                               div(style = "text: align-left; color: white,", tags$b("Current comparison")),
                                               uiOutput("HMComparisonUI"),
                                               br(),
                                               disabled(actionButton(inputId = "HMCyclePrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "HMCycleNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Alter plot characteristics")),
                                                        icon = icon("tags"),
                                                        radioButtons(inputId = "HMdata",
                                                                     label = "Switch between data type",
                                                                     choices = c("Plot averages" = "averages",
                                                                                 "Plot replicates" = "reps"),
                                                                     selected = "reps"),
                                                        checkboxInput(inputId = "HMDispCol",
                                                                      label = "Show column label",
                                                                      value = TRUE),
                                                        checkboxInput(inputId = "HMDispRow",
                                                                      label = "Show row labels",
                                                                      value = TRUE),
                                                        radioButtons(inputId = "HMSigLabels",
                                                                     label = "Isolate significant proteins",
                                                                     choices = c("Upregulated", "Downregulated", "Both"),
                                                                     selected = "Upregulated"),
                                                        checkboxInput(inputId = "HMzScore",
                                                                      label = "Z-score data", value = FALSE),
                                                        numericInput(inputId = "HMlabelNoOfSig",
                                                                     label = "No. of regulated proteins to display",
                                                                     min = 1, step = 1, value = 10)),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Change colour scheme")),
                                                        icon = icon("swatchbook"),
                                                        radioButtons(inputId = "HMColChoice",
                                                                     label = "Choose correlation colour gradient",
                                                                     choices = c("Red-Yellow-Blue" = "RdYlBu",
                                                                                 "Red-Blue" = "RdBu",
                                                                                 "Purple-Orange" = "PuOr",
                                                                                 "Purple-Green" = "PRGn",
                                                                                 "Purple-Yellow-Green" = "PiYG",
                                                                                 "Brown-Blue-Green" = "BrBG"),
                                                                     selected = "RdYlBu"),
                                                        sliderInput(inputId = "HMcolScale",
                                                                    label = "Choose colour scale",
                                                                    min = 1, max = 11, step = 1, value = 11),
                                                        colourInput(inputId = "HMborderCol",
                                                                    label = "Border colour", showColour = "both",
                                                                    palette = "limited",
                                                                    value = "#000000")),
                                               menuItem(text = div(style = "text-align:left; color: white, ",
                                                                   tags$b("Correlation")),
                                                        icon = icon("calculator"),
                                                        checkboxInput(inputId = "HMclustCols",
                                                                      label = "cluster columns",
                                                                      value = TRUE),
                                                        checkboxInput(inputId = "HMclustRows",
                                                                      label = "cluster rows",
                                                                      value = TRUE),
                                                        pickerInput(inputId = "HMClustMethod",
                                                                    label = "Clustering method",
                                                                    choices = c("complete", "ward.D", "ward.D2",
                                                                                "single", "average", "median",
                                                                                "centroid"),
                                                                    multiple = FALSE,
                                                                    selected = "complete",
                                                                    choicesOpt = list(
                                                                      style = rep(("color: black;"),7)))
                                               )
                                      ),
                                      #Webgestalt controls
                                      menuItem(text = "Webgestalt enrichments",
                                               icon = icon("bezier-curve"),
                                               actionButton(inputId = "generateEnrichments",
                                                            label = "start",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               div(style = "text: align-left; color: white,", tags$b("Current comparison")),
                                               verbatimTextOutput(outputId = "enrichmet_currentCompareText"),
                                               br(),
                                               disabled(actionButton(inputId = "enrichmentCyclePrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "enrichmentCycleNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               br(),
                                               pickerInput(inputId = "webgesalt_orgs",
                                                           label = "Choose model organism",
                                                           choices =  listOrganism(),
                                                           multiple = FALSE,
                                                           selected = "hsapiens",
                                                           choicesOpt = list(
                                                             style = rep(("color: black;"),12))),
                                               radioButtons(inputId = "webgestalt_tests",
                                                            label = "Choose a test",
                                                            choices = c("ORA", "GSEA"),
                                                            inline = TRUE,
                                                            selected = "ORA"),
                                               uiOutput("webgestalt_yaxis_render"),
                                               uiOutput("webgestalt_enrichment_variations_render"),
                                               radioButtons(inputId = "webgestalt_db",
                                                            label = "Choose querry database",
                                                            choices = c("Gene ontology" = "gene_ontology",
                                                                        "Pathway" = "pathway"),
                                                            selected = "pathway"),
                                               uiOutput("webgestalt_function"),
                                               uiOutput("webgestalt_fdr_render"),
                                               uiOutput("top_enrichment_slider"),
                                               uiOutput("webgestalt_plotting_slider"),
                                               uiOutput("webgestalt_sig_slider"),
                                               uiOutput("webgestalt_fdr_options_render"),
                                               actionButton(inputId = "calculateEnrichments",
                                                            label = "Calculate",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;")),
                                      #string
                                      menuItem(text = "String controls",
                                               icon = icon("atom"),
                                               actionButton(inputId = "generateStringNetwork",
                                                            label = "start",
                                                            icon = icon("play-circle"),
                                                            style ="display: block; margin: 0 auto; width: 200px;color: black;"),
                                               br(),
                                               div(style = "text: align-left; color: white,", tags$b("Current comparison")),
                                               verbatimTextOutput(outputId = "string_currentCompareText"),
                                               br(),
                                               disabled(actionButton(inputId = "stringCyclePrevious",
                                                                     label = "Previous",
                                                                     icon = icon("backward"),
                                                                     style="display:inline-block;width:40%;text-align: center;"),
                                                        actionButton(inputId = "stringCycleNext",
                                                                     label = "Next",
                                                                     icon = icon("forward"),
                                                                     style="display:inline-block;width:40%;text-align: center;")),
                                               br(),
                                               pickerInput(inputId = "string_data_options",
                                                           label = "Choose data set",
                                                           c("Upregulated" = "upregulated",
                                                             "Downregulated" = "downregulated",
                                                             "Custom Uniprot ID" = "custom"),
                                                           selected = "upgegulated",
                                                           multiple = FALSE,
                                                           choicesOpt = list(
                                                             style = rep(("color: black;"),3))),
                                               uiOutput("string_data_inputs"),
                                               numericInput(inputId = "string_sig_threshold",
                                                            label = "siginifcance threshold",
                                                            min = 1, max = 1000,
                                                            value = 950),
                                               numericInput(inputId = "string_max_nodes",
                                                            label = "max nodes",
                                                            min = 1, max = 100,
                                                            value = 10)

                                               ), # string menu close
                                      menuItem(text = "Download options",
                                               icon = icon("download"),
                                               textInput(inputId = "mainFigDownTitle",
                                                         label = "file name",
                                                         placeholder = "Current comparison"),
                                               selectInput(inputId = "mainFigDownType",
                                                           label = "Filetype",
                                                           choices = c("tiff", "jpeg",
                                                                       "png", "pdf"),
                                                           selected = "tiff"),
                                               selectInput(inputId = "mainFigRes",
                                                           label = "Figure resolution",
                                                           choices = c("High" = "retina",
                                                                       "Medium" = "print",
                                                                       "low" = "screen"),
                                                           selected = "")))
                   ), #figures close
                   #about us panel
                   conditionalPanel(condition = "input.main_tabs == 'AboutUs'",
                                    sidebarMenu(

                                    ) #sidebar close

                   ) #about us close
  ), #sidebar close

  dashboardBody(useShinyjs(),
                #tags$head(includeHTML("analytics.html")),
                tags$head(tags$script(HTML("
                    // Enable navigation prompt
                    window.onbeforeunload = function() {
                        return 'Carefull, your changes will be lost!';
                    };
                "))),
                tabsetPanel(id = "main_tabs",
                            #welcome tab/about tab
                            tabPanel(title = "Welcome",
                                     value = "welcome",
                                     icon = icon("door-open"),
                                     uiOutput("welcomeHTML")),
                            #data handling tab
                            tabPanel(title = "Data handling",
                                     value = "data_handling",
                                     icon = icon("table"),
                                     fluidPage(
                                       fluidRow(
                                         infoBoxOutput("data_handling_info"),
                                         valueBoxOutput("protein_ids_count"),
                                         valueBoxOutput("contaminants_count")
                                       ),
                                       fluidRow(
                                         column(width = 6,
                                                DT::dataTableOutput("user_data_in")),
                                         column(width = 3,
                                                rHandsontableOutput("defineReps")))
                                     )),
                            #QC tab
                            tabPanel(title = "Quality metrics",
                                     value = "quality_metrics",
                                     icon = icon("chart-line"),
                                     fluidPage(
                                       fluidRow(
                                         column(6,
                                                dropdownButton(circle = TRUE,
                                                               status = "primary",
                                                               tooltip = TRUE,
                                                               icon = icon("gears"),
                                                               label = "Click for more plotting options",
                                                               h4(tags$b("Q-Q plot options")),
                                                               colourInput(inputId = "qqLineCol",
                                                                           label = "Line colour",
                                                                           palette = "limited",
                                                                           value = "#000000"),
                                                               sliderInput(inputId = "qqLineWidth",
                                                                           label = "Line width",
                                                                           min = 0.1, max = 2, step = 0.1,
                                                                           value = 1),
                                                               radioButtons(inputId = "qqLinesType",
                                                                            label = "Choose line type",
                                                                            choices = c("solid", "dashed",
                                                                                        "dotted", "dotdash",
                                                                                        "longdash", "twodash"),
                                                                            selected = "solid", inline = TRUE),
                                                               h4(tags$b("Q-Q and histogram options")),
                                                               sliderInput(inputId = "normTitlePos",
                                                                           label = "Set title position",
                                                                           min = 0, max = 1, step = 0.1,
                                                                           value = 0),
                                                               radioButtons(inputId = "normTitleFace",
                                                                            label = "Title face",
                                                                            choices = c("plain", "bold",
                                                                                        "italic", "bold.italic"),
                                                                            selected = "plain",
                                                                            inline = TRUE),
                                                               h4(tags$b("Font sizes")),
                                                               fluidRow(column(4,
                                                                               numericInput(inputId = "normXsize",
                                                                                            label = "X-axis title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "normYsize",
                                                                                            label = "Y-axis title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "normTitleSize",
                                                                                            label = "Plot title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 15)))),
                                                plotOutput("qqPlot")),
                                         column(6,
                                                dropdownButton(circle = TRUE,
                                                               status = "primary",
                                                               tooltip = TRUE,
                                                               icon = icon("gears"),
                                                               label = "Click for more plotting options",
                                                               colourInput(inputId = "scatPointBorder",
                                                                           label = "change point border colour",
                                                                           palette = "limited",
                                                                           value = "#000000"),
                                                               sliderInput(inputId = "scatTitlePos",
                                                                           label = "Set title position",
                                                                           min = 0, max = 1, step = 0.1,
                                                                           value = 0),
                                                               radioButtons(inputId = "scatTitleFace",
                                                                            label = "Title face",
                                                                            choices = c("plain", "bold",
                                                                                        "italic", "bold.italic"),
                                                                            selected = "plain"),
                                                               h4(tags$b("Font sizes")),
                                                               fluidRow(column(4,
                                                                               numericInput(inputId = "scatXsize",
                                                                                            label = "X-axis title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "scatYsize",
                                                                                            label = "Y-axis title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "scatTitleSize",
                                                                                            label = "Plot title",
                                                                                            min = 1, max = 30, step = 1,
                                                                                            value = 15)))),
                                                plotOutput("scatPlot"))),
                                       br(),
                                       #corrplot
                                       fluidRow(
                                         column(6,
                                                dropdownButton(circle = TRUE,
                                                               status = "primary",
                                                               tooltip = TRUE,
                                                               icon = icon("gears"),
                                                               label = "Click for more plotting options",
                                                               h4(tags$b("Plot title options")),
                                                               sliderInput(inputId = "corrTitlePos",
                                                                           label = "Set title position",
                                                                           min = 0, max = 1, step = 0.1,
                                                                           value = 0),
                                                               radioButtons(inputId = "corrTitleFace",
                                                                            label = "Title face",
                                                                            choices = c("plain", "bold",
                                                                                        "italic", "bold.italic"),
                                                                            selected = "plain", inline = TRUE),
                                                               h4(tags$b("plot aesthetics")),
                                                               numericInput(inputId = "corrDecimalPos",
                                                                            label = "Correlation decimal positions",
                                                                            value = 2, min = 1),
                                                               sliderInput(inputId = "corrColourScale",
                                                                           label = "Set colour scale",
                                                                           min = 3, max = 11, step = 1,
                                                                           value = 11),
                                                               h4(tags$b("Font sizes")),
                                                               fluidRow(column(4,
                                                                               numericInput(inputId = "corrXSize",
                                                                                            label = "X-axis",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "corrYSize",
                                                                                            label = "Y-axis",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "corrTitleSize",
                                                                                            label = "Plot title",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 15)))
                                                ), #dropdownclose
                                                plotOutput("corrPlot")),
                                         column(6,
                                                dropdownButton(circle = TRUE,
                                                               status = "primary",
                                                               tooltip = TRUE,
                                                               icon = icon("gears"),
                                                               label = "Click for more plotting options",
                                                               h4(tags$b("Plot aesthetics")),
                                                               radioButtons(inputId = "pcaLegendPostition", label = "Position legend",
                                                                            choices = c("right", "left", "top", "bottom", "none"),
                                                                            selected = "top", inline = TRUE),
                                                               radioButtons(inputId = "pcaCharcters",
                                                                            label = "Select point type",
                                                                            choices = c("Circle" = 21,
                                                                                        "Square" = 22,
                                                                                        "Diamond"= 23,
                                                                                        "Triangle 1" = 24,
                                                                                        "Triangle2" = 25),
                                                                            selected = 21, inline = TRUE),
                                                               h4(tags$b("Plot title options")),
                                                               sliderInput(inputId = "pcaTitlePos",
                                                                           label = "Set title position",
                                                                           min = 0, max = 1, step = 0.1,
                                                                           value = 0),
                                                               radioButtons(inputId = "pcaTitleFace",
                                                                            label = "Title face",
                                                                            choices = c("plain", "bold",
                                                                                        "italic", "bold.italic"),
                                                                            selected = "plain", inline = TRUE),
                                                               h4(tags$b("Font sizes")),
                                                               fluidRow(column(4,
                                                                               numericInput(inputId = "pcaXSize",
                                                                                            label = "X-axis",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "pcaYSize",
                                                                                            label = "Y-axis",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 12)),
                                                                        column(4,
                                                                               numericInput(inputId = "pcaTitleSize",
                                                                                            label = "Plot title",
                                                                                            min = 0, max = 30, step = 0.5,
                                                                                            value = 15)))),
                                                plotOutput("pcaPlot"))
                                       ))),
                            #statistics tab
                            tabPanel(title = "Statistics",
                                     value = "statistics",
                                     icon = icon("calculator"),
                                     fluidPage(
                                       fluidRow(
                                         infoBoxOutput("currentCompare"),
                                         valueBoxOutput("downReg"),
                                         valueBoxOutput("upReg"),
                                         valueBoxOutput("totalSig")
                                       ),
                                       fluidRow(column(12,
                                                       dataTableOutput("statsTable"))))
                            ),
                            #figures tab
                            tabPanel(title = "Figure construction",
                                     value = "figures",
                                     icon = icon("chart-area"),
                                     fluidPage(
                                       fluidRow(column(6,
                                                       dropdownButton(circle = TRUE,
                                                                      status = "primary",
                                                                      tooltip = TRUE,
                                                                      icon = icon("gears"),
                                                                      label = "Click for more plotting options",
                                                                      sliderInput(inputId = "volcLinesLWD",
                                                                                  label = "Set line width",
                                                                                  min = 0, max = 5, step = 0.1, value = 1.4),
                                                                      radioButtons(inputId = "volcLinesType",
                                                                                   label = "Choose line type",
                                                                                   choices = c("solid", "dashed",
                                                                                               "dotted", "dotdash",
                                                                                               "longdash", "twodash"),
                                                                                   selected = "longdash", inline = TRUE),
                                                                      h4(tags$b("Font sizes")),
                                                                      fluidRow(column(4,
                                                                                      numericInput(inputId = "VolcXSize",
                                                                                                   label = "X-axis",
                                                                                                   min = 0, max = 30, step = 0.5,
                                                                                                   value = 12)),
                                                                               column(4,
                                                                                      numericInput(inputId = "VolcYSize",
                                                                                                   label = "Y-axis",
                                                                                                   min = 0, max = 30, step = 0.5,
                                                                                                   value = 12)),
                                                                               column(4,
                                                                                      numericInput(inputId = "VolcTitleSize",
                                                                                                   label = "Plot title",
                                                                                                   min = 0, max = 30, step = 0.5,
                                                                                                   value = 15))),
                                                                      h4(tags$b("Control position of significant counts:")),
                                                                      br(),
                                                                      fluidRow(column(4,
                                                                                      numericInput(inputId = "volcXdown",
                                                                                                   label = "Downregulated x position",
                                                                                                   value = -5)),
                                                                               column(4,
                                                                                      numericInput(inputId = "volcYdown",
                                                                                                   label = "Downregulated y position",
                                                                                                   value = 10))),
                                                                      fluidRow(column(4,
                                                                                      numericInput(inputId = "volcXup",
                                                                                                   label = "Upregulated x position",
                                                                                                   value = 5)),
                                                                               column(4,
                                                                                      numericInput(inputId = "volcYup",
                                                                                                   label = "Upregulated y position",
                                                                                                   value = 10)))
                                                       ),
                                                       plotOutput("volcplotOut"),
                                                       downloadButton(outputId = "VolcDownloader",
                                                                      label = "Download Volcano plot",
                                                                      style="color: black;")
                                       ),
                                       column(6,
                                              dropdownButton(circle = TRUE,status = "primary", tooltip = TRUE,
                                                             icon = icon("gears"),
                                                             label = "Click for more plotting options",
                                                             h4(tags$b("Font sizes")),
                                                             fluidRow(column(4,
                                                                             numericInput(inputId = "HMColFontSize",
                                                                                          label = "Column font size",
                                                                                          value = 12)),
                                                                      column(4,
                                                                             numericInput(inputId = "HMRowFontSize",
                                                                                          label = "Row font size",
                                                                                          value = 12))),
                                                             radioButtons(inputId = "HMcolAngle",
                                                                          label = "Column text angle",
                                                                          choices = c(0, 45, 90, 270, 315),
                                                                          selected = 90, inline = TRUE),
                                                             sliderInput(inputId = "HMColTreeHeight",
                                                                         label = "Decrease column dendogram height",
                                                                         min = 0, max = 50, step = 2, value = 50),
                                                             sliderInput(inputId = "HMRowTreeHeight",
                                                                         label = "Decrease row dendogram height",
                                                                         min = 0, max = 50, step = 2, value = 50)),
                                              tags$head(tags$style(".shiny-output-error{color: black;}")),
                                              plotOutput("Heatmap"),
                                              downloadButton(outputId = "HMDownloader",
                                                             label = "Download Heatmap",
                                                             style="color: black;"))),
                                       fluidRow(column(12,
                                                       tabsetPanel(id = "enrichment_plot_tabs",
                                                                   tabPanel(title = "Webgestalt",
                                                                            fluidRow(
                                                                              column(9,
                                                                                     plotOutput("webgestalt_plot") %>%
                                                                                       withSpinner(type = 3, color.background = '#ECEFF4')),
                                                                              column(3,
                                                                                     dropdownButton(circle = TRUE,status = "primary", tooltip = TRUE,
                                                                                                    icon = icon("gears"),
                                                                                                    label = "click for plotting options",
                                                                                         fluidPage(
                                                                                           fluidRow(
                                                                                             column(6,
                                                                                                    textInput(inputId = "webgestalt_x_label",
                                                                                                              label = "x-axis label",
                                                                                                              placeholder = "Enrichment Ratio")
                                                                                             ),
                                                                                             column(6,
                                                                                                    textInput(inputId = "webgestalt_y_label",
                                                                                                              label = "y-axis label",
                                                                                                              placeholder = "Description")
                                                                                             ),
                                                                                             fluidRow(
                                                                                               div(style = "margin-left:15px;
                                                                                                            margin-right:15px;",
                                                                                                   column(3,
                                                                                                          numericInput(inputId = "enrichment_x_axis_font_size",
                                                                                                                       label = "X-axis size",
                                                                                                                       min = 1, max = 30,
                                                                                                                       value = 10)),
                                                                                                   column(3,
                                                                                                          numericInput(inputId = "enrichment_y_axis_font_size",
                                                                                                                       label = "Y-axis size",
                                                                                                                       min = 1, max = 30,
                                                                                                                       value = 8)),
                                                                                                   column(3,
                                                                                                          numericInput(inputId = "enrichment_x_title_font_size",
                                                                                                                       label = "Y-title size",
                                                                                                                       min = 1, max = 30,
                                                                                                                       value = 16)),
                                                                                                   column(3,
                                                                                                          numericInput(inputId = "enrichment_y_title_font_size",
                                                                                                                       label = "X-axis size",
                                                                                                                       min = 1, max = 30,
                                                                                                                       value = 16)))

                                                                                             ),
                                                                                             fluidRow(column(6,
                                                                                                             div(style = "margin-left:10px;",
                                                                                                                 colourInput(inputId = "webgestalt_colour_fill",
                                                                                                                             label = "fill colour",
                                                                                                                             showColour = "both",
                                                                                                                             palette = "limited",
                                                                                                                             value = "blue")
                                                                                                             )

                                                                                             ),
                                                                                             column(6,
                                                                                                    actionButton(inputId = "webgestalt_tables",
                                                                                                                 label = "Show data",
                                                                                                                 style ="display: block;
                                                                                                                    background-color:white;
                                                                                                                    margin-top: 25px;
                                                                                                                    marin-right: 15px;
                                                                                                                    width: 150px;
                                                                                                                    font-face:bold;
                                                                                                                    color: black;"))),
                                                                                             fluidRow(column(12,
                                                                                                             div(style = "margin-left:25px",
                                                                                                                 sliderInput(inputId = "webgestalt_top_n_slider",
                                                                                                                             label = "Plot top n enrichments",
                                                                                                                             min = 1, max = 30, step = 1,
                                                                                                                             value = 10,
                                                                                                                             width = 300))
                                                                                             ))))
                                                                                     )  #dropdown close
                                                                                     )
                                                                                      ),
                                                                            downloadButton(outputId = "webgestalt_downloader",
                                                                                         label = "Download enrichment plot",
                                                                                         style="color: black;")
                                                                            ),
                                                                   tabPanel(title = "String",
                                                                            fluidRow(radioButtons(inputId = "string_image_extention",
                                                                                                  label = "",
                                                                                                  choices = c("png" = "highres_image",
                                                                                                              "svg" = "svg"),
                                                                                                  selected = "highres_image",
                                                                                                  inline = TRUE)),
                                                                            fluidRow(
                                                                              downloadButton(outputId = "string_download_image",
                                                                                             label = "Download",
                                                                                             style="color: black;")
                                                                            ),
                                                                            uiOutput("string_image") %>%
                                                                              withSpinner(type = 3, color.background = '#ECEFF4')
                                                                            ))
                                                       )
                                                )
                                     ) #fluidpage close
                            ),#Figs close
                            #About us tab
                            tabPanel(title = "About us",
                                     value = "AboutUs",
                                     icon = icon("user-tie"),
                                     includeHTML("www/HTML/about.html")
                            )
                          )

  )#Body close
) #user interface close

#server starts here
server <- function(input, output, session) {

  filterValidVals <- function(x, in_one, user_val, anno_data) {
    #count reps and get groups
    if (in_one == "one_group") {
      #need to keep genenames indexed
      gene.names <- x$GeneNames
      x$GeneNames <- NULL

      colnames(x) <- anno_data$annotation

      conditions <- as.data.frame(table(unlist(names(x))))
      conditions <- conditions$Var1

      cond.filter <- sapply(levels(conditions), function(i) {
        df2 <- x[, grepl(i, names(x))]
        counts <- rowSums(is.finite(as.matrix(df2)))
        counts >= user_val
      })

      x$keep = apply(cond.filter, 1, any)

      x$GeneNames <- gene.names
      #filter

      x <- x[!(x$keep=="FALSE"),]
      x$keep <- NULL
      x$geneNames <- NULL
    }

    if (in_one == "each_group") {
      anno_data <- anno_data()
      #need to keep genenames indexed
      gene.names <- x$GeneNames
      x$GeneNames <- NULL

      colnames(x) <- anno_data$annotation


      conditions <- as.data.frame(table(unlist(names(x))))
      conditions <- conditions$Var1

      cond.filter <- sapply(levels(conditions), function(i) {
        df2 <- x[, grepl(i, names(x))]
        counts <- rowSums(is.finite(as.matrix(df2)))
        counts >= user_val
      })

      x$keep = apply(cond.filter, 1, all)

      x$GeneNames <- gene.names
      #filter

      x <- x[!(x$keep=="FALSE"),]
      x$keep <- NULL
      x$geneNames <- NULL
    }
    #in matrix

    if (in_one == "entire_df") {
      anno_data <- anno_data()
      #need to keep genenames indexed
      gene.names <- x$GeneNames
      x$GeneNames <- NULL

      colnames(x) <- anno_data$annotation
      rows <- rownames(x)

      x = do.call(data.frame, lapply(x, function(dat) replace(dat, is.infinite(dat), NA)))

      rownames(x) <- rows
      colnames(x) <- anno_data$annotation
      x$GeneNames <- gene.names
      x = na.omit(x)

    }
    return(x)

  }
  ######Upload limit#####
  options(shiny.maxRequestSize=30*1024^2)
  options(shiny.sanitize.errors = FALSE)


  source(file = "www/scripts/utility_functions.R")

  ######Welcome tab######


  tab1Counters <- reactiveValues(ClickCounter = 0)

  observeEvent(input$goTut, {
    tab1Counters$ClickCounter <- tab1Counters$ClickCounter + 1
  })

  observeEvent(input$main_tabs != 'welcome', {
    tab1Counters$ClickCounter = 0
  })

  observe({
    if (input$tutOptions == "full") {
      enable("fullTutPages")
    } else {
      disable("fullTutPages")
    }
  })

  HTMLdata <- reactive({
    if (tab1Counters$ClickCounter == 0) {
      includeHTML("www/HTML/welcome.html")
    } else if (input$tutOptions == "quickStart") {
      includeHTML("www/HTML/quickstart.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "gs") {
      includeHTML("www/HTML/gettingStarted.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "dp") {
      includeHTML("www/HTML/dataProcessing.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "qm") {
      includeHTML("www/HTML/qc.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "stats") {
      includeHTML("www/HTML/stats.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "mf") {
      includeHTML("www/HTML/mainFigs.html")
    } else if (input$tutOptions == "full" & input$fullTutPages == "exp") {
      includeHTML("www/HTML/export.html")
    } else {
      return(NULL)
    }
  })

  output$welcomeHTML <- renderUI({
    HTMLdata()
  })

  #tutModal_preprocess-------------------------------------------------------------------------------------------------->
  observeEvent(input$DataProcTut, {
    showModal(tutmodal_preprocessing())
  })

  tutmodal_preprocessing <- function(){
    modalDialog(includeHTML("www/HTML/dataProcessing.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }


  #TutModal_QC----------------------------------------------------------------------------------------------------------->
  observeEvent(input$tut_QC, {
    showModal(tutmodal_qc())
  })

  tutmodal_qc <- function(failed = FALSE){
    modalDialog(includeHTML("www/HTML/qc.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }


  #tutmodal_stats-------------------------------------------------------------------------------------------------------->

  observeEvent(input$tut_stats, {
    showModal(tutmodal_stats())
  }
  )

  tutmodal_stats <- function(failed = FALSE){
    modalDialog(includeHTML("www/HTML/stats.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }

  #tutmodal_mainfigs------------------------------------------------------------------------------------------------------->

  observeEvent(input$tut_mainFigs, {
    showModal(tutmodal_mainfigs())
  }
  )

  tutmodal_mainfigs <- function(failed = FALSE){
    modalDialog(includeHTML("www/HTML/mainFigs.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }


  #tutmodal_preprocessing_export------------------------------------------------------------------------------------------>

  observeEvent(input$tut_dataPreProcExport, {
    showModal(tutmodal_export_preprocessing())
  })

  tutmodal_export_preprocessing <- function(failed = FALSE){
    modalDialog(includeHTML("www/HTML/processedDataExportModal.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }

  #tutmodal_stats_export-------------------------------------------------------------------------------------------------->
  observeEvent(input$tut_statsExport, {
    showModal(tutmodal_export_stats())
  })

  tutmodal_export_stats <- function(failed = FALSE){
    modalDialog(includeHTML("www/HTML/statsDataExportModal.html"),
                size = "l",
                easyClose = TRUE,
                fade = TRUE)
  }


  ###### DATA INPUT #####
  file_upload <- reactive({
    data <- read.csv(input$user_file$datapath,
                     stringsAsFactors = FALSE,
                     colClasses = "character",
                     sep = "\t",
                     header = TRUE)

    return(data)
  })

  output$TMTplexUI <- renderUI({
    if (input$userQuants == "tmt") {
      radioButtons(inputId = "tmtPlex",
                   label = "Choose TMT plex",
                   choices = c("TMT Six plex" = 5,
                               "TMT Ten plex" = 9,
                               "TMT eleven plex" = 10),
                   selected = 9)
    }
  })

  colPickData <- reactive({
    if (!is.null(input$user_file)) {
      df <- file_upload()

      if (input$userQuants == "lfq") {
        intensity.names = grep("^LFQ.intensity", names(df), value = TRUE)
      } else if (input$userQuants == "intensity") {
        intensity.names = grep("^Intensity.", names(df), value = TRUE)
      } else {
        intensity.names = c()
        for (i in 0:input$tmtPlex) {
          pat <- paste0("^Reporter.intensity.corrected.", i, "$")
          tmt <- grep(pattern = pat, names(df), value = TRUE)
          intensity.names <- c(intensity.names, tmt)
        }

      }
      return(intensity.names)
    }
  })

  output$addRemCols <- renderUI({
    if (!is.null(input$user_file) & input$unlockCols == TRUE) {
      pickerInput(inputId = "RemCols",
                  label = "Remove specific columns",
                  choices = unlist(colPickData()),
                  multiple = TRUE,
                  selected = unlist(colPickData()),
                  options = list(`actions-box` = TRUE,
                                 `selected-text-format` = "count > 0"), choicesOpt = list(
                                   style = rep(("color: black;"),length(colPickData()))))

    } else {return(NULL)}
  })

  #### Data handling ################################################################

  #control imputations
  observe({
    if (input$EnableImputeControl == TRUE) {
      enable("imputeWidth")
      enable("imputeDS")
    } else {
      reset("imputeWidth")
      reset("imputeDS")
      reset("median_center")
      disable("imputeWidth")
      disable("imputeDS")
    }
  })

  #TMT needs subtraction of the median
  observe({
    if (input$userQuants == "tmt") {
      updateCheckboxInput(session = session,
                          inputId = "median_center",
                          value = TRUE)
    } else {
      updateCheckboxInput(session = session,
                          inputId = "median_center",
                          value = FALSE)
    }
  })

  # control data flow allows to ignore the cached data
  dataControl = reactiveValues(activateFilter = 0,
                               uploadState = NULL,
                               filterValids = 0,
                               imputation = 0,
                               annoStart = 0,
                               annoSubmit = 0)

  observeEvent(input$activate_filter, {
   dataControl$activateFilter <- dataControl$activateFilter + 1
  })

  observeEvent(input$user_file, {
    dataControl$uploadState <- "uploaded"
  })

  observeEvent(input$filter_valids, {
    dataControl$filterValids <-  dataControl$filterValids + 1
  })

  observeEvent(input$start_imputation, {
    dataControl$imputation <-  dataControl$imputation + 1
  })

  observeEvent(input$start_anno, {
    dataControl$annoStart <-  dataControl$annoStart + 1
  })

  observeEvent(input$submit_anno, {
    dataControl$annoSubmit <-  dataControl$annoSubmit + 1
  })

  processed_data <- reactive({
    if (dataControl$activateFilter > 0) {
      raw <- file_upload()
      uniquePep <- isolate(input$user_unique_pep)
      logTrans <- isolate(input$logTransform)

      # Filter identifications

      validate(
        need(raw$Potential.contaminant,
             message = "File error: is this a MaxQuant output file?")
      )

      df = raw %>%
        filter(Potential.contaminant != "+") %>%
        filter(Reverse != "+") %>%
        filter(Only.identified.by.site != "+")

      df <- subset(df, df$Unique.peptides > (uniquePep-1))

      # Extract names of quant columns
      if (input$unlockCols == TRUE) {
        intensity.names = input$RemCols
      } else {
        if (input$userQuants == "lfq") {
          intensity.names = grep("^LFQ.intensity", names(df), value = TRUE)
        } else if (input$userQuants == "intensity") {
          intensity.names = grep("^Intensity", names(df), value = TRUE)
        } else {
          intensity.names = c()
          for (i in 0:input$tmtPlex) {
            pat <- paste0("^Reporter.intensity.corrected.", i, "$")
            tmt <- grep(pattern = pat, names(df), value = TRUE)
            intensity.names <- c(intensity.names, tmt)
          }
        }
      }

      # Cast as numeric
      df[intensity.names] = sapply(df[intensity.names], as.numeric)

      #logTransfomation
      if (logTrans == TRUE) {
        df[intensity.names] = log2(df[intensity.names])

      }


      #create new dataframe from LFQ intensities
      df2 <-  df[intensity.names]


      if (input$median_center == TRUE) {
        df2 <- center_med(x = df2)
      }
      #assign protein IDs from oringinal this will be majority prt IDs in the end
      df2$Protein.IDs <- df$Protein.IDs
      df2$Majority.protein.IDs <- df$Majority.protein.IDs
      df2$Fasta.headers <- df$Fasta.headers
      #need to get everything before a ; character first
      #check for fasta col, if present use that
      parseRule <- grepl(">", df2$Fasta.headers)
      if (TRUE %in% parseRule ) {
        fasta <- word(df2$Fasta.headers, 1, sep = ";")
      } else {
        fasta <- word(df2$Majority.protein.IDs, 1, sep = ";")
      }

      sanityRule <- grepl("\\|", fasta)
      if (TRUE %in% sanityRule) {
        df2$UniprotID <- str_extract(fasta,"(?<=\\|)(.+)(?=\\|)")
        temp1_genename <- str_extract(fasta,"(?<=\\|)(.+)(?=\\_)")
        df2$GeneNames <- sapply(strsplit(temp1_genename, "\\|"), "[", 2)
      } else {
        df2$UniprotID <- fasta
        df2$GeneNames <- fasta
      }
      df2$Fasta.headers <- NULL


      #get the uniprot ID

      #rename cols
      if (input$userQuants == "lfq") {
        names(df2) = gsub(pattern = "LFQ.intensity.", replacement = "", x = names(df2))
      } else if (input$userQuants == "intensity") {
        names(df2) = gsub(pattern = "Intensity.", replacement = "", x = names(df2))
        df2$Intensity <- NULL
      } else {
        names(df2) = gsub(pattern = "Reporter.intensity.corrected", replacement = "Reporter",
                          x = names(df2))
      }

      #rownames as IDs for later
      #df2 <- df2[1:nrow(df2)-1,]
      rownames(df2) <- df2$UniprotID

      #remove redundant col
      df2$UniprotID <- NULL
      df2$Protein.IDs <- NULL
      df2$Majority.protein.IDs <- NULL
      orig.col.names <- colnames(df2[names(df2) != "GeneNames"])


      if (dataControl$filterValids > 0) {
        #x <- df2
        anno_data_func <- anno_data()
        #need to keep genenames indexed
        #gene.names <- x$GeneNames
        #x$GeneNames <- NULL

        #colnames(x) <- anno_data$annotation


        min_val_user <- isolate(input$min_val_user)
        #in_one_user <- isolate(input$in_one)
        df2 <- filterValidVals(x = df2,
                                user_val = min_val_user,
                                in_one = input$in_one_user,
                                anno_data = anno_data_func)

        #add gene names again
        #dat2$GeneNames <- gene.names
        #filter

        #dat2 <- dat2[!(dat2$keep=="FALSE"),]
        #dat2$keep <- NULL
        #dat2$geneNames <- NULL
        #df2 <- dat2

        if (dataControl$imputation > 0) {
          #centering
          impute_dat <- isolate(input$impute_choices)
          gene.names <- df2$GeneNames
          df2$GeneNames <- NULL
          colnames(df2) <- orig.col.names

          df2 <- imputeFunc(x = df2,
                            width = input$imputeWidth,
                            downshift = input$imputeDS)
          anno_data <- anno_data()
          colnames(df2) <- anno_data$ID
          df2$GeneNames <- gene.names

        }
      }
      return(tryCatch(df2, error = function(e) stop(safeError(""))))
    }
    return(tryCatch(df2, error = function(e) stop(safeError(""))))
  })

  ##### get df to display for user input ###
  #we will prompt for reps like this
  categorial_anno <- reactive({
    d <- processed_data()
    d$GeneNames <- NULL
    d1 <- data.frame(ID = colnames(d),
                     annotation = colnames(d),
                     axisLabels = colnames(d))
    return(d1)
  })

  output$defineReps <- renderRHandsontable({
    if (dataControl$annoStart > 0) {
      categorial_anno <- categorial_anno()
      categorial_anno$ID <- as.character(categorial_anno$ID)
      categorial_anno$annotation <- as.character(categorial_anno$annotation)
      categorial_anno$axisLabels <- as.character(categorial_anno$axisLabels)
      tab <- rhandsontable(categorial_anno) %>%
          hot_col("ID", readOnly = T)
      return(tab)
    } else {
      return(NULL)
    }
  })

  #get data from user
  #displays need to signal data is submitted
  anno_data <- reactive({
    if (dataControl$annoSubmit > 0) {
      reps <- isolate(input$defineReps)
      repsOut <- hot_to_r(reps)
      return(repsOut)
    } else {
      return(NULL)
    }
  })

  redundant <- function(x){
    anno_data <- eventReactive(input$submit_anno, {
      reps <- isolate(input$defineReps)
      repsOut <- hot_to_r(reps)
      return(repsOut)
    })
  }

  #This controls enabling and disabling anno button

  observe({
    if (dataControl$annoSubmit > 0) {
      sendSweetAlert(
        session = session,
        title = "Success",
        text = "Your data is submitted",
        type = "success",
        closeOnClickOutside = TRUE,
        width = 400
      )
     # hide("defineReps")
      disable("submit_anno")
    } else {
     # show("defineReps")
      enable("submit_anno")
    }
  })

  #render the data table
  output$user_data_in <-  DT::renderDataTable({

    #this is to remove error message in display
    if (is.null(dataControl$uploadState)) {
      return(NULL)
    }

    if (dataControl$activateFilter == 0) {
      #first display
      file_upload <- file_upload()

      validate(
        need(file_upload$Potential.contaminant,
             message = "Certain key columns were not detected, are you sure the file is correct?")
      )

      datatable(file_upload, options = list(searching = F,
                                              pageLength = 20,
                                              lengthMenu = c(5, 10, 15, 20),
                                              scrollX = T,
                                              autoWidth = TRUE
      ))
    } else if (dataControl$activateFilter > 0) {
      datatable(processed_data(),  options = list(searching = TRUE,
                                                  pageLength = 20,
                                                  lengthMenu = c(5, 10, 15, 20),
                                                  scrollX = T,
                                                  autoWidth = TRUE
      ))
    }
  })

  #information boxes: Handlers

  infovals = reactiveValues(countervalue = 0)

  observeEvent(input$activate_filter, {
    infovals$countervalue <- infovals$countervalue + 1
  })

  observeEvent(input$submit_anno, {
    infovals$countervalue <- infovals$countervalue + 1
  })

  observeEvent(input$filter_valids, {
    infovals$countervalue <- infovals$countervalue + 1
  })

  observeEvent(input$start_imputation, {
    infovals$countervalue <- infovals$countervalue + 1
  })

  #render the info boxes
  output$data_handling_info <- renderValueBox({
    #check if data is loaded
    if (is.null(dataControl$uploadState)) {
      infoBox(title = "Information",
              value = "Upload proteinGroups.txt file",
              icon = icon("info"),
              color = "olive")

    } else if (infovals$countervalue == 0) {
      infoBox(title = "Information",
              value = div("Next step:",
                          br(),
                          "Filter erroneus IDs"),
              icon = icon("info"),
              color = "olive",
              subtitle = "Two unique peptides is the default")

    } else if (infovals$countervalue == 1 ) {
      infoBox(title = "Information",
              value = div("Next step:",
                          br(),
                          "go to assign groups"),
              subtitle = "reps get the same name",
              icon = icon("info"),
              color = "olive")

    } else if (infovals$countervalue == 2 ) {
      infoBox(title = "Information",
              value = div("Next step:",
                          br(),
                          "valid value filtering"),
              subtitle = "Recommended choices are autoselected",
              icon = icon("info"),
              color = "olive")

    } else if (infovals$countervalue == 3) {
      infoBox(title = "Information",
              value = div("Next step:",
                          br(),
                          "Impute missing data"),
              subtitle = "Optional step but recommended",
              icon = icon("info"),
              color = "olive")
    } else if (infovals$countervalue == 4) {
      infoBox(title = "Information",
              value = div("Next step:",
                          br(),
                          "Go to next tab"),
              subtitle = "Perform QC metrics assesment",
              icon = icon("info"),
              color = "olive")
    } else if (infovals$countervalue > 4) {
      infoBox(title = "Information",
              value = "Help is out of bounds",
              subtitle = "Data calculations are not affected",
              icon = icon("info"),
              color = "red")
    }
  })

  #valueboxes 1
  output$protein_ids_count <- renderValueBox({
    #Display unique peptides here
    if (is.null(dataControl$uploadState)) {
      valueBox(value = "No file loaded",
               subtitle = "Number of proteins",
               color = "aqua",
               icon = icon("list-ol"))
    } else {
      if (dataControl$activateFilter == 0) {

        file_upload <- file_upload()

        validate(
          need(file_upload$Potential.contaminant,
               message = "")
        )

        valueBox(value = nrow(file_upload),
                 subtitle = "Number of proteins",
                 color = "orange",
                 icon = icon("list-ol"))
      } else {
        if (dataControl$activateFilter > 0) {

          valueBox(value = nrow(processed_data()),
                   subtitle = "Number of proteins",
                   color = "orange",
                   icon = icon("list-ol"))
        }
      }
    }
  }) #protein ID close

  #valuebox 2
  output$contaminants_count <- renderValueBox({

    if (is.null(dataControl$uploadState)) {
      valueBox(value = "No file loaded",
               subtitle = "Potential errouneuos protein IDs",
               color = "aqua",
               icon = icon("exclamation-triangle"))
    } else {
      if (dataControl$activateFilter == 0) {
        rawFile <- file_upload()

        validate(
          need(rawFile$Majority.protein.IDs,
               message = "Protein IDs column not detected, is this a MaxQuant file?"))

        contam1 <- nrow(subset(rawFile, Potential.contaminant == "+"))
        contam2 <- nrow(subset(rawFile, Reverse == "+"))
        contam3 <- nrow(subset(rawFile, Only.identified.by.site == "+"))
        contam <- sum(contam1,contam2, contam3)

        valueBox(value = contam,
                 subtitle = "Potential errouneuos protein IDs",
                 icon = icon("exclamation-triangle"),
                 color = "orange")
      } else {
        if (dataControl$activateFilter > 0) {
          valueBox(value = 0,
                   subtitle = "Potential errouneuos protein IDs",
                   icon = icon("exclamation-triangle"),
                   color = "orange")
        }
      }
    }

  }) #valuebox 2 close

  observeEvent(input$fileReset, {
    reset("user_file")
    dataControl$uploadState <- NULL
    dataControl$activateFilter <- 0
    dataControl$filterValids <- 0
    dataControl$imputation <- 0
    dataControl$annoStart <- 0
    dataControl$annoSubmit <- 0
    infovals$countervalue <- 0
  })

  #QC_plots------------------------------------------------------------------------------------------------->
  #ui_logic------------------------------------------------>

  output$normality_control1 <- renderUI({
    if (input$normPlotChoice == "qqPlot") {
      ui_widget <- textInput(inputId = "qqPlotTitle",
                             label = "Plot title",
                             value = "",
                             placeholder = "Q-Q plot of ...")
    } else {
      ui_widget <- textInput(inputId = "HistoTitle",
                             label = "Plot title",
                             value = "",
                             placeholder = "Histogram of ...")
    }
    return(ui_widget)
  })
  output$normality_control2 <- renderUI({
    if (input$normPlotChoice == "qqPlot") {
      ui_widget <- sliderInput(inputId = "qqPointSize",
                                label = "Change point size",
                                min = 1, max = 10, step = 1,
                                value = 2)
    } else {
      ui_widget <- sliderInput(inputId = "HistoBinWidth",
                               label = "Select bin width",
                               min = 1, max = 100, step = ,
                               value = 30)
    }
    return(ui_widget)
  })
  output$normality_control3 <- renderUI({
    if (input$normPlotChoice == "qqPlot") {
      ui_widget <- sliderInput(inputId = "qqPlotAlphaChannel",
                                label = "Change transparency",
                                min = 0.1, max = 1, step = 0.1,
                                value = 1)
    } else {
      ui_widget <- prettySwitch(
        inputId = "HistoPlotDensity",
        label = "Add density distribution",
        status = "primary",
        slim = TRUE)
    }
    return(ui_widget)
  })
  output$normality_control4 <- renderUI({
    if (input$normPlotChoice == "qqPlot") {
      return(NULL)
    } else {
      return(colourInput(inputId = "normDensityFill",
                         label = "Density plot colour",
                         palette = "limited",
                         value = "#666666"))
    }
  })
  output$normality_control5 <- renderUI({
    if (input$normPlotChoice == "qqPlot") {
      return(NULL)
    } else {
      return(sliderInput(inputId = "DensPlotAlphaChannel",
                         label = "Change transparency",
                         min = 0.1, max = 1, step = 0.1,
                         value = 0.4))
    }
  })

  #server_logic--------------------------------------------->
  Counter <- reactiveValues(normcounter = 1,
                            scatcounter = 1)


  observeEvent(input$normRender, {
    enable("normPrevious")
    enable("normNext")
  })

  observeEvent(input$normPrevious, {
    if (Counter$normcounter > 1) {
      Counter$normcounter <- Counter$normcounter - 1
    }
  })

  observeEvent(input$normNext, {
    #processed_data <- processed_data()
    if (Counter$normcounter < ncol(processed_data()) - 1) {
      Counter$normcounter <- Counter$normcounter + 1
    }
  })

  NormalityPlot <- reactive({

    if (is.null(input$user_file)) {
      return(NULL)
    }

    processed_data <- processed_data()

    processed_data$GeneNames <- NULL

    anno_data <- anno_data()
    colnames(processed_data) <- anno_data$axisLabels
    ylabname <- colnames(processed_data[Counter$normcounter])
    index <- Counter$normcounter
    qqplotList <- list()
    histPlotList <- list()

    #init plot cylce on render to save computing time
    if (input$normRender > 0) {
      #run for selected plots only
      if (input$normPlotChoice == "qqPlot") {
        for (i in 1:ncol(processed_data)) {
          dat <- data.frame(qqnorm(processed_data[,i], plot.it = FALSE))
          axisname <- colnames(processed_data[i])
          p <- ggplot(dat, aes(x, y)) +
            geom_point(pch = 21,
                       alpha = input$qqPlotAlphaChannel,
                       size = input$qqPointSize,
                       colour = input$normPlotCol,
                       fill = input$normPlotFill) +
            geom_qq_line(aes(sample = y),
                         lty = input$qqLinesType,
                         lwd = input$qqLineWidth,
                         colour = input$qqLineCol) +
            ylab(axisname) +
            xlab("Theoretical quantiles") +
            ggtitle(input$qqPlotTitle) +
            theme_classic(base_size = 14) +
            theme(plot.title = element_text(hjust = input$normTitlePos,
                                            face = input$normTitleFace,
                                            size = input$normTitleSize),
                  axis.title.x = element_text(size = input$normXsize),
                  axis.title.y = element_text(size = input$normYsize))

          qqplotList[[i]] = p
        }

        return(qqplotList)

      } else {
        #histograms
        for (i in 1:ncol(processed_data)) {
          axisName <- colnames(processed_data[i])

          p <- ggplot(processed_data, aes_string(processed_data[,i])) +
            geom_histogram(aes(y = ..density..),
                           bins = input$HistoBinWidth, fill = input$normPlotFill,
                           colour = input$normPlotCol) +
            xlab(axisName) +
            ggtitle(input$HistoTitle) +
            theme_classic() +
            theme(plot.title = element_text(hjust = input$normTitlePos,
                                            face = input$normTitleFace,
                                            size = input$normTitleSize),
                  axis.title.x = element_text(size = input$normXsize),
                  axis.title.y = element_text(size = input$normYsize))

          if (input$HistoPlotDensity == TRUE) {
            p <- p + geom_density(fill = input$normDensityFill,
                                  alpha = input$DensPlotAlphaChannel)
          }


          histPlotList[[i]] = p
        }

        return(histPlotList)
      }

    } else {
      return(NULL)
    }
  })

  output$qqPlot <- renderPlot({NormalityPlot()[Counter$normcounter]})

  ###scatterplots###
  scatter_user <- reactive({
    if (is.null(input$user_file)) {
      return(NULL)
    }

    processed_data <- processed_data()
    anno_data <- anno_data()
    colnames(processed_data) <- anno_data$ID
    index <- Counter$scatcounter
    plot_list <- list()
    plot.col <- input$scat_point_col
    for(i in unique(anno_data$annotation)){
      COLS=anno_data$ID[anno_data$annotation ==i]
      plot_combinations <- combn(COLS,
                                 2,
                                 simplify = FALSE)

      for (a in 1:length(plot_combinations)) {
        p = ggplot(processed_data,
                   aes_string(x = plot_combinations[[a]][1],
                              y = plot_combinations[[a]][2])) +
          geom_point(pch = as.integer(input$scatCharcters),
                     colour = input$scatPointBorder,
                     size = input$scatPointSize,
                     fill = plot.col,
                     alpha = input$scatPlotAlphaChannel) +
          ggtitle(input$scatTitle) +
          theme_classic(base_size = 14) +
          theme(plot.title = element_text(hjust = input$scatTitlePos,
                                          face = input$scatTitleFace,
                                          size = input$scatTitleSize),
                axis.title.x = element_text(size = input$scatXsize),
                axis.title.y = element_text(size = input$scatYsize))
        out_name <- paste(i,a,sep = "_")
        plot_list[[out_name]] = p
      }
    }

    if (input$scatRender == 0) {
      return(NULL)
    } else {
      dispPlot <- plot_list
    }
    return(dispPlot)
  })

  observeEvent(input$scatRender, {
    enable("scatPrevious")
    enable("scatNext")
  })

  observeEvent(input$scatPrevious, {
    if (Counter$scatcounter > 1) {
      Counter$scatcounter <- Counter$scatcounter - 1
    }
  })

  observeEvent(input$scatNext, {
    if (Counter$scatcounter < length(scatter_user())) {
      Counter$scatcounter <- Counter$scatcounter + 1
    } else {
      Counter$scatcounter <- Counter$scatcounter - (length(scatter_user()) + 1)

    }
  })

  output$scatPlot <- renderPlot({
    index <- Counter$scatcounter
    scatter_user()[index]})

  #corrplots

  corrProcessing <- reactive({
    processed_data <-processed_data()

    anno_data <- anno_data()
    processed_data$GeneNames <- NULL
    colnames(processed_data) <- anno_data$axisLabels
    d <- processed_data

    checks <- sapply(d, function(x) {is.finite(x)})

    if (FALSE %in% checks) {

      sanityRule <- "fail"
    } else {
      sanityRule <- "pass"
    }

    validate(
      need(sanityRule == "pass", message = "This plot requires data with no missing values")
    )

    cormatrix = rcorr(as.matrix(d), type=input$correlation_test)
    cordata = melt(cormatrix$r)
    cordata$labelr = abbreviateSTR(melt(cormatrix$r)$value, 'r')
    cordata$labelP = abbreviateSTR(melt(cormatrix$P)$value, 'P')
    cordata$label = paste(cordata$labelr, "\n",
                          cordata$labelP, sep = "")
    cordata$strike = ""
    cordata$strike[cormatrix$P > 0.05] = "X"

    txtsize <- par('din')[2] / 2

    cordata$value <- round(cordata$value, digits = input$corrDecimalPos)

    return(cordata)
  })

  correllelogram <- reactive({

    if (input$corrRender == 0) {
      return(NULL)
    } else {
      cordata <- corrProcessing()
      p = ggplot(cordata, aes(x=Var1, y=Var2, fill=value)) +
        geom_tile() +
        scale_fill_gradientn(colours = brewer.pal(input$corrColChoice,
                                                  n = input$corrColourScale),
                             name = "Pearson",
                             limits = c(input$corrSlider, 1)) +
        xlab(NULL) + ylab(NULL) + ggtitle(input$corrPlotTitle) +
        theme_classic(base_size = 14) +
        theme(plot.title = element_text(hjust = input$corrTitlePos,
                                        face = input$corrTitleFace,
                                        size = input$corrTitleSize),
              axis.text.x = element_text(angle=90, hjust = 1, size = input$corrXSize),
              axis.text.y = element_text(size = input$corrYSize))

      if (input$corrValDisp == TRUE) {
        txtsize <- par('din')[2] / 2
        p =  p + geom_text(label=cordata$value, size=txtsize * 0.8, color="grey9")

        return(p)
      } else {
        return(p)
      }
    }
  })

  output$corrPlot <- renderPlot({
    correllelogram()
  })

  #pca plots

  pcaCols <- reactive({
    anno_data <- anno_data()
    if (input$pcaRender > 0) {
      lapply(unique(anno_data$annotation), function(i) {
        colourInput(inputId = paste("col", i, sep="_"),
                    label = paste0("Choose colour for ", i),
                    value = i, palette = "limited",
                    showColour = "both")
      })
    }

  })

  pca_color_input <- reactive({
    if (input$pcaRender > 0) {
      anno_data <- anno_data()
      lapply(unique(anno_data$annotation), function(i) {
        input[[paste("col", i, sep="_")]]
      })
    }
  })

  pcaColNames <- reactive({unlist(pca_color_input())})

  pca <- reactive({
    if (input$pcaRender > 0) {
      dat <- processed_data()

      anno_data <- anno_data()
      idnames <- anno_data$ID
      dat$GeneNames <- NULL
      colnames(dat) <- as.character(idnames)
      if (input$pcaZscore == TRUE) {
        dat <- scale(dat, scale = TRUE)
      }
      pcaData <- prcomp(x = t(dat), scale. = TRUE)
      pcaData <- as.data.frame(pcaData$x)
      names <- anno_data$annotation
      pcaData$names <- names
      return(pcaData)
    }
  })

  pcaPlots <- reactive({
    pcaData <- pca()

    anno_data <- anno_data()
    cols <- pcaColNames()
    if (is.null(pcaColNames())) {
      cols <- rep("#000000", length(unique(anno_data$annotation)))
    } else {
      cols <- pcaColNames()
    }
    if (input$pcaRender > 0) {
      p <- ggplot(pcaData, aes(pcaData$PC1, pcaData$PC2)) +
        geom_point(pch = as.integer(input$pcaCharcters),
                   size = input$pcaPlotPointSize,
                   colour = "black",
                   alpha = input$pcaAlphaChannel,
                   aes(fill = pcaData$names)) +
        scale_fill_manual(values = cols) +
        theme_classic() +
        ylab("Principle component 2") + xlab("Principle component 1") +
        labs(fill = NULL) +
        ggtitle(input$pcaPlotTitle) +
        theme(legend.position = input$pcaLegendPostition,
              plot.title = element_text(hjust = input$pcaTitlePos,
                                        face = input$pcaTitleFace,
                                        size = input$pcaTitleSize),
              axis.title.x = element_text(size = input$pcaXSize),
              axis.title.y = element_text(size = input$pcaYSize))
      return(p)
    }
  })

  output$pcaColChoice <- renderUI({pcaCols()})

  output$pcaPlot <- renderPlot({
    if (input$pcaRender == 0) {
      return(NULL)
    } else {pcaPlots()}

  })

  ###stats###
  #control system
  observeEvent(input$calculateStats, {
    enable("statCyclePrevious")
    enable("statCycleNext")
  })

  statsCycler <- reactiveValues(counter = 1)

  observeEvent(input$statCyclePrevious, {
    if (statsCycler$counter > 1) {
      statsCycler$counter <- statsCycler$counter - 1
    }
  })

  statComb <- reactive({
    anno_data <- anno_data()
    comb <- combn(unique(anno_data$annotation), 2, simplify = FALSE)
    contrast <- lapply(comb, function(i) {
      if (input$ComparisonSwitch == 1) {
        compare <- paste(i[1], i[2], sep = "-")
      } else {
        compare <- paste(i[2], i[1], sep = "-")
      }
      return(compare)
    })
  })

  output$statComparisonMat <- renderUI({
    pickerInput(inputId = "hypoTestMat",
                label = "Choose conditions to compare",
                choices = unlist(statComb()),
                multiple = TRUE,
                selected = unlist(statComb()),
                options = list(`actions-box` = TRUE,
                               `selected-text-format` = "count > 0"), choicesOpt = list(
                                 style = rep(("color: black;"),length(statComb())))
    )
  })

  observeEvent(input$statCycleNext, {
    if (statsCycler$counter < length(input$hypoTestMat)) {
      statsCycler$counter <- statsCycler$counter + 1
    } else if (statsCycler$counter == length(input$hypoTestMat)) {
      statsCycler$counter <- 1
    }
  })

  #infoboxes
  output$currentCompare <- renderInfoBox({
    if (input$calculateStats > 0) {
      hypoTestMat <- input$hypoTestMat
      infoBox(title = "Current comparison",
              value = hypoTestMat[statsCycler$counter],
              icon = icon("info"),
              color = "orange")
    } else {
      infoBox(title = "Perform hypothesis testing",
              value = "Remember to choose comparisons",
              color = "aqua")
    }
  })

  #Limma stats
  statsTestedData <- reactive({
    processed_data <- processed_data()
    rownames(processed_data) <- paste(rownames(processed_data),
                                      processed_data$GeneNames,
                                      sep = "_")
    processed_data$GeneNames <- NULL
    anno_data <- anno_data()

    validate(
      need(!is.null(anno_data),
           message = "No groups assigned")
    )

    colnames(processed_data) <- anno_data$ID
    anno_data$axisLabels <- NULL
    if (input$calculateStats > 0) {
      f.df <- factor(anno_data$annotation)
      design <- model.matrix(~0+f.df)
      colnames(design) <- levels(f.df)
      fit <- lmFit(processed_data, design)
      f.df <- factor(anno_data$annotation)
      design <- model.matrix(~0+f.df)
      colnames(design) <- levels(f.df)
      fit <- lmFit(processed_data, design)

      cont.matrix <- makeContrasts(contrasts = input$hypoTestMat, levels = design)

      fit2 <- contrasts.fit(fit, cont.matrix)
      fit2 <- eBayes(fit2)

      return(fit2)

    } else {
      return(NULL)
    }
  })

  statsOut <- reactive({
    fit2 <- statsTestedData()
    statComb <- statComb()

    d.out <- data.frame(ID = names(fit2$coefficients[,statsCycler$counter]),
                        pValue = fit2$p.value[,statsCycler$counter],
                        qValue = p.adjust(fit2$p.value[,statsCycler$counter], input$pvalAdjust),
                        EffectSize = fit2$coefficients[,statsCycler$counter],
                        comparison = statComb[statsCycler$counter])
    d.out <- mutate(d.out,
                    significant = ifelse(test = round(d.out$qValue, 3) < input$UserSigCutoff & d.out$EffectSize > input$UserFCCutoff,
                                         yes = "Upregulated",
                                         ifelse(test =  round(d.out$qValue, 3) < input$UserSigCutoff & d.out$EffectSize < (input$UserFCCutoff * -1),
                                                yes = "Downregulated", no = "Non significant")))

    d2 <- data.frame(d.out,
                     colsplit(string = d.out$ID,
                              pattern = "_",
                              names = c("UniprotID", "GeneName")))
    rownames(d2) <- d2$UniprotID
    d2$ID <- NULL
    d2$UniprotID <- NULL

    return(d2)
  })

  output$downReg <- renderValueBox({
    if (input$calculateStats > 0) {
      d <- statsOut()

      valueBox(value = sum(round(d$qValue, 3) < input$UserSigCutoff & d$EffectSize < (input$UserFCCutoff * -1),
                           na.rm = TRUE),
               subtitle = "Total significantly downregulated proteins",
               color = "orange")
    } else {
      valueBox(value = NULL,
               subtitle = "No calculations performed",
               color = "aqua")
    }
  })

  output$upReg <- renderValueBox({
    if (input$calculateStats > 0) {
      d <- statsOut()
      valueBox(value = sum(round(d$qValue, 3) < input$UserSigCutoff & d$EffectSize > input$UserFCCutoff,
                           na.rm = TRUE ),
               subtitle = "Total significantly upregulated proteins",
               color = "orange")
    } else {
      valueBox(value = NULL,
               subtitle = "No calculations performed",
               color = "aqua")
    }
  })

  output$totalSig <- renderValueBox({
    if (input$calculateStats > 0) {
      d <- statsOut()
      valueBox(value = sum(round(d$qValue, 3) < input$UserSigCutoff & abs(d$EffectSize) > input$UserFCCutoff,
                           na.rm = TRUE ),
               subtitle = "Total significantly regulated proteins",
               color = "orange")
    } else {
      valueBox(value = NULL,
               subtitle = "No calculations performed",
               color = "aqua")
    }
  })


  output$statsTable <- DT::renderDataTable({
    if (input$calculateStats == 0) {
      return(NULL)
    } else {
      hypoTestMat <- input$hypoTestMat
      datatable(statsOut(), extensions = 'Buttons',
                options = list(
                  dom = "Blfrtip",
                  buttons =
                    list("copy", list(
                      extend = "collection",
                      buttons = c("csv", "excel", "pdf"),
                      text = "Download", filename = hypoTestMat[statsCycler$counter]
                    ) ), # end of buttons customization

                  # customize the length menu
                  lengthMenu = list( c(10, 20, -1) # declare values
                                     , c(10, 20, "All") # declare titles
                  ), # end of lengthMenu customization
                  pageLength = 10
                ))
    }
  })

  ###volcplots###
  volcPlotData <- reactive({
    datList <- list()
    for (i in 1:length(input$hypoTestMat)) {
      if (input$generateVolcs > 0) {
        fit2 <- statsTestedData()
        statComb <- statComb()

        d.out <- data.frame(ID = names(fit2$coefficients[,i]),
                            pValue = fit2$p.value[,i],
                            qValue = p.adjust(fit2$p.value[,i], input$pvalAdjust),
                            EffectSize = fit2$coefficients[,i],
                            comparison = statComb[i])
        d.out <- mutate(d.out,
                        sig = ifelse(d.out$EffectSize > input$UserFCCutoff & round(d.out$qValue, 3) < input$UserSigCutoff, "Upregulated",
                                     ifelse(d.out$EffectSize < (input$UserFCCutoff * -1) & round(d.out$qValue, 3) < input$UserSigCutoff, "Downregulated", "Non significant")))


        d2 <- data.frame(d.out,
                         colsplit(string = d.out$ID,
                                  pattern = "_",
                                  names = c("UniprotID", "GeneName")))


        if (input$volclabelNoOfSig > 0) {

          if (input$volcSigLabels == "Upregulated") {
            d.up = d2 %>%
              filter(sig == "Upregulated") %>%
              arrange(desc(EffectSize)) %>%
              slice(1:input$volclabelNoOfSig) %>%
              select(UniprotID, GeneName)

            d2 <- merge(d2, d.up, by = "UniprotID", all.x  = TRUE)
          } else if (input$volcSigLabels == "Downregulated") {
            d.down = d2 %>%
              filter(sig == "Downregulated") %>%
              arrange(EffectSize) %>%
              slice(1:input$volclabelNoOfSig) %>%
              select(UniprotID, GeneName)

            d2 <- merge(d2, d.down, by = "UniprotID", all.x  = TRUE)

          } else if (input$volcSigLabels == "Both") {
            d.up = d2 %>%
              filter(sig == "Upregulated") %>%
              arrange(desc(EffectSize)) %>%
              slice(1:input$volclabelNoOfSig) %>%
              select(UniprotID, GeneName)

            colnames(d.up)[colnames(d.up)=="GeneName"] <- "GeneNameup"

            d.down = d2 %>%
              filter(sig == "Downregulated") %>%
              arrange(EffectSize) %>%
              slice(1:input$volclabelNoOfSig) %>%
              select(UniprotID, GeneName)

            colnames(d.down)[colnames(d.down)=="GeneName"] <- "GeneNamedown"

            df.down <- merge(d2, d.down, by = "UniprotID", all.x = TRUE)
            df.down$GeneName <- NULL
            d2 <- merge(df.down, d.up, by = "UniprotID", all.x = TRUE)
          }
        }
      }
      rownames(d2) <- d2$UniprotID
      d2$ID <- NULL
      d2$UniprotID <- NULL

      datName <- input$hypoTestMat[i]
      datList[[datName]] = d2

    } #for loop close
    return(datList)
  })

  observeEvent(input$generateVolcs, {
    enable("volcCyclePrevious")
    enable("volcCycleNext")
    output$currentCompareText <- renderText(input$hypoTestMat[volcCycler$counter])
  })

  volcCycler <- reactiveValues(counter = 1)

  observeEvent(input$volcCyclePrevious, {
    if (volcCycler$counter > 1) {
      volcCycler$counter <- volcCycler$counter - 1
    }
  })

  observeEvent(input$volcCycleNext, {
    if (volcCycler$counter < length(input$hypoTestMat)) {
      volcCycler$counter <- volcCycler$counter + 1
    } else if (volcCycler$counter == length(input$hypoTestMat)) {
      volcCycler$counter <- 1
    }
  })

  volcPlot <- reactive({
    if (input$generateVolcs > 0) {
      #plotList <- list()
      d <- volcPlotData()[[volcCycler$counter]]
      #volcSigLabel <- volcSigLabel()
      d.down = sum(round(d$qValue, 3) < input$UserSigCutoff & d$EffectSize < (input$UserFCCutoff * -1) )
      d.up = sum(round(d$qValue, 3) < input$UserSigCutoff & d$EffectSize > input$UserFCCutoff )
      p <- ggplot(d, aes(x=EffectSize, y=-log10(pValue), fill = sig)) +
        xlab("log2 fold change") + ylab("-log10 p-value") + labs(fill = NULL) +
        ggtitle(label = input$volcTitle) +
        theme_classic(base_size = 14) +
        geom_point(pch = 21, colour = "black", alpha = input$volcAlphaChannel, size = input$volcPlotPointSize) +
        scale_fill_manual(values=c("Non significant" = input$volcNS,
                                   "Downregulated" = input$volcDown,
                                   "Upregulated" = input$volcUp)) +
        theme(legend.position = input$volcLegendPostition,
              plot.title = element_text(face  = input$VolcTitleFace,
                                        hjust = input$volcTitlePos,
                                        size = input$VolcTitleSize),
              axis.title.x = element_text(size = input$VolcXSize),
              axis.title.y = element_text(size = input$VolcYSize))

      if (input$volcSigLabels == "Upregulated" || input$volcSigLabels == "Downregulated") {
        p <- p + geom_text_repel(aes(label = d$GeneName.y), show.legend = FALSE)
      }

      if (input$volcSigLabels == "Both") {
        p <- p + geom_text_repel(aes(label = d$GeneNamedown), show.legend = FALSE) +
          geom_text_repel(aes(label = d$GeneNameup), show.legend = FALSE)
      }



      if (input$volcFeatures == "Lines") {
        p <- p +  geom_vline(aes(xintercept = (input$UserFCCutoff*-1)),
                             lty = input$volcLinesType,
                             colour = input$volcDown,
                             lwd=input$volcLinesLWD) +
          geom_vline(aes(xintercept = input$UserFCCutoff),
                     lty = input$volcLinesType, colour =input$volcUp,
                     lwd=input$volcLinesLWD)
      }

      if (input$volcFeatures == "Counts") {
        p <- p + geom_text(aes(x = input$volcXdown, y= input$volcYdown, label=d.down)) +
          geom_text(aes(x = input$volcXup, y= input$volcYup, label=d.up))
      }

      if (input$volcFeatures == "Both") {
        p <- p + geom_vline(aes(xintercept = (input$UserFCCutoff*-1)),
                            lty = input$volcLinesType,
                            colour = input$volcDown,
                            lwd=input$volcLinesLWD) +
          geom_vline(aes(xintercept = input$UserFCCutoff),
                     lty = input$volcLinesType, colour =input$volcUp,
                     lwd=input$volcLinesLWD) +
          geom_text(aes(x = input$volcXdown,
                        y=input$volcYdown,
                        label=d.down)) +
          geom_text(aes(x = input$volcXup,
                        y= input$volcYup,
                        label=d.up))
      }

      if (input$volcFeatures == "None") {
        p <- p
      }

      return(p)

    } else {
      return(NULL)
    }

  })

  output$volcplotOut <-renderPlot(volcPlot())

  ###heatmaps###
  HMPlotData <- reactive({
    fit2 <- statsTestedData()
    processed_data <- processed_data()
    anno_data <- anno_data()
    processed_data$GeneName <- NULL
    colnames(processed_data) <- anno_data$ID
    processed_data$UniprotID <- rownames(processed_data)

    statComb <- statComb()
    datList <- list()
    for (i in 1:length(input$hypoTestMat)) {
      if (input$generateHM > 0) {
        d.out <- data.frame(ID = names(fit2$coefficients[,i]),
                            pValue = fit2$p.value[,i],
                            qValue = p.adjust(fit2$p.value[,i], input$pvalAdjust),
                            EffectSize = fit2$coefficients[,i],
                            comparison = statComb[i])
        d.out <- mutate(d.out,
                        sig = ifelse(d.out$EffectSize > input$UserFCCutoff & round(d.out$qValue, 3) < input$UserSigCutoff, "Upregulated",
                                     ifelse(d.out$EffectSize < (input$UserFCCutoff * -1) & round(d.out$qValue, 3) < input$UserSigCutoff, "Downregulated", "Non significant")))


        d2 <- data.frame(d.out,
                         colsplit(string = d.out$ID,
                                  pattern = "_",
                                  names = c("UniprotID", "GeneName")))

        if (input$HMAllorSig == "Sig") {
          if (input$HMSigLabels == "Upregulated") {
            d.up = d2 %>%
              filter(sig == "Upregulated") %>%
              arrange(desc(EffectSize)) %>%
              slice(1:input$HMlabelNoOfSig) %>%
              select(UniprotID, GeneName)
            colnames(d.up)[colnames(d.up)=="GeneName"] <- "GeneNameup"

            d2 <- merge(d2, d.up, by = "UniprotID", all.x  = TRUE)
            d2$GeneName <- NULL
            d3 <- merge(processed_data, d2[, c("UniprotID", "GeneNameup")], by = "UniprotID",
                        all.x = TRUE)
            d3 = d3 %>%
              drop_na(GeneNameup)

            rownames(d3) <- d3$GeneNameup
            d3$GeneNameup <- NULL
            d3$UniprotID <- NULL
            d3 <- d3[,1:nrow(anno_data)]

          } else if (input$HMSigLabels == "Downregulated") {
            d.down = d2 %>%
              filter(sig == "Downregulated") %>%
              arrange(EffectSize) %>%
              slice(1:input$HMlabelNoOfSig) %>%
              select(UniprotID, GeneName)

            colnames(d.down)[colnames(d.down)=="GeneName"] <- "GeneNamedown"

            d2 <- merge(d2, d.down, by = "UniprotID", all.x  = TRUE)
            d2$GeneName <- NULL
            d3 <- merge(processed_data, d2[, c("UniprotID", "GeneNamedown")],
                        by = "UniprotID",
                        all.x = TRUE)
            d3 = d3 %>%
              drop_na(GeneNamedown)

            rownames(d3) <- d3$GeneNamedown
            d3$GeneNameup <- NULL
            d3$UniprotID <- NULL
            d3 <- d3[,1:nrow(anno_data)]

          } else if (input$HMSigLabels == "Both") {
            d.up = d2 %>%
              filter(sig == "Upregulated") %>%
              arrange(desc(EffectSize)) %>%
              slice(1:input$HMlabelNoOfSig) %>%
              select(UniprotID, GeneName)

            colnames(d.up)[colnames(d.up)=="GeneName"] <- "GeneNameup"

            d.down = d2 %>%
              filter(sig == "Downregulated") %>%
              arrange(EffectSize) %>%
              slice(1:input$HMlabelNoOfSig) %>%
              select(UniprotID, GeneName)

            colnames(d.down)[colnames(d.down)=="GeneName"] <- "GeneNamedown"

            df.down <- merge(d2, d.down, by = "UniprotID", all.x = TRUE)
            df.down$GeneName <- NULL

            d2 <- merge(df.down, d.up, by = "UniprotID", all.x = TRUE)

            d2$GeneName <- coalesce(d2$GeneNameup, d2$GeneNamedown)

            d3 <- merge(processed_data, d2, by = "UniprotID",
                        all.x = TRUE)
            d3 = d3 %>%
              drop_na(GeneName)

            rownames(d3) <- d3$GeneName

            d3$UniprotID <- NULL

            d3 <- d3[,1:nrow(anno_data)]

          }

          if (input$HMzScore == TRUE) {
            d4 <- scale(d3, scale = TRUE)
          } else {
            d4 <- d3
          }

          datName <- input$hypoTestMat[i]
          datList[[datName]] = d4
        }

      } #GenerateHM close

    } #for loop close
    return(datList)
  })

  HMCycler <- reactiveValues(counter = 1)

  observeEvent(input$generateHM, {
    enable("HMCyclePrevious")
    enable("HMCycleNext")
    output$HMcurrentCompareText <- renderText(input$hypoTestMat[HMCycler$counter])
  })

  output$HMComparisonUI <- renderUI({
    if (input$HMAllorSig == "Sig") {

      verbatimTextOutput(outputId = "HMcurrentCompareText")
    }
  })

  observe({
    if (input$HMAllorSig == "All") {
      updateCheckboxInput(session, "HMDispRow", value = FALSE)
    } else {
      updateCheckboxInput(session, "HMDispRow", value = TRUE)
    }
  })

  observeEvent(input$HMCyclePrevious, {
    if (HMCycler$counter > 1) {
      HMCycler$counter <- HMCycler$counter - 1
    }
  })

  observeEvent(input$HMCycleNext, {
    if (HMCycler$counter < length(input$hypoTestMat)) {
      HMCycler$counter <- HMCycler$counter + 1
    } else if (HMCycler$counter == length(input$hypoTestMat)) {
      HMCycler$counter <- 1
    }
  })

  allHeatMapData <- reactive({
    d <- processed_data()
    anno_data <- anno_data()
    d$GeneNames <- NULL
    colnames(d) <- anno_data$ID
    d$UniprotID <- rownames(processed_data)
    d$UniprotID <- NULL

    if (input$HMzScore == TRUE) {
      d2 <- scale(d, scale = TRUE)
    } else {
      d2 <- d
    }

    return(d2)
  })

  UserHeatmap <- reactive({
    anno_data <- anno_data()
    if (input$generateHM > 0) {
      if (input$HMAllorSig == "All") {
        d1 <- allHeatMapData()
      } else {
        d1 <- HMPlotData()[[HMCycler$counter]]
        #d1 <- SigheatmapData()
      }


      if (input$HMdata == "averages") {
        colnames(d1) <- anno_data$annotation
        d2 <- sapply(split.default(d1, names(d1)), rowSums, na.rm = TRUE)
      } else {
        colnames(d1) <- anno_data$axisLabels
        d2 <- d1
      }

      validate(
        need(dim(d2)[1] != 0, message = "This comparison has no significant proteins"),
        errorClass = ".shiny-output-error-validation {
        color: red;
    }"
      )
      p <- pheatmap(d2, color = rev(brewer.pal(input$HMColChoice,
                                           n = input$HMcolScale)),
                    border_color = input$HMborderCol,
                    fontsize_col = input$HMColFontSize,
                    fontsize_row = input$HMRowFontSize,
                    angle_col = input$HMcolAngle,
                    cluster_cols = input$HMclustCols,
                    cluster_rows = input$HMclustRows,
                    clustering_method = input$HMClustMethod,
                    show_colnames = input$HMDispCol,
                    show_rownames = input$HMDispRow,
                    treeheight_col = input$HMColTreeHeight,
                    treeheight_row = input$HMColTreeHeight)

      return(p)
  }

  })

  output$Heatmap <- renderPlot({
    if (!is.null(input$user_file)) {
      UserHeatmap()
    } else {
      return(NULL)
    }

    })

  #Webgestalt---------------------------------------------------------------------------------------->
  webbestaltEnrichment <- function(data){
    if (input$webgestalt_tests == "ORA") {
      if (input$webgestalt_fdr == "fdr") {
        WebGestaltR(enrichMethod = "ORA",
                    interestGene = data,
                    isOutput = FALSE,
                    interestGeneType = "uniprotswissprot",
                    enrichDatabase = input$webgestalt_function_picker,
                    organism = input$webgesalt_orgs,
                    referenceSet = "genome_protein-coding",
                    projectName = "User",
                    sigMethod = input$webgestalt_fdr,
                    fdrMethod = input$webgestalt_fdr_options,
                    fdrThr = as.numeric(input$webgestalt_sig_radio_out)
        )
      } else {
        WebGestaltR(enrichMethod = "ORA",
                    interestGene = data,
                    isOutput = FALSE,
                    interestGeneType = "uniprotswissprot",
                    enrichDatabase = input$webgestalt_function_picker,
                    organism = input$webgesalt_orgs,
                    referenceSet = "genome_protein-coding",
                    projectName = "User",
                    sigMethod = input$webgestalt_fdr,
                    fdrMethod = input$webgestalt_fdr_options,
                    topThr = input$webgestalt_top_calc_slider
        )
      }

    } else if (input$webgestalt_tests == "GSEA") {

      tryCatch(WebGestaltR(enrichMethod = "GSEA",
                           interestGene = data,
                           isOutput = FALSE,
                           interestGeneType = "uniprotswissprot",
                           enrichDatabase = input$webgestalt_function_picker,
                           organism = input$webgesalt_orgs,
                           referenceSet = "genome_protein-coding"
      ), error = function(e) {
        stop(safeError(paste0(error_message_webgestalt(inputCall = paste0("No",
                                                                          " ",
                                                                          error_message_webgestalt(inputCall = input$webgestalt_function_picker),
                                                                          "\'s",
                                                                          " ",
                                                                          "were enriched, try another method or pathway")))))
      })
    }


  }

  enrichmentCycler <- reactiveValues(counter = 1)

  observeEvent(input$enricmentCyclePrevious, {
    if (enrichmentCycler$counter > 1) {
      enrichmentCycler$counter <- enrichmentCycler$counter - 1
    }
  })

  observeEvent(input$enrichmentCycleNext, {
    if (enrichmentCycler$counter < length(input$hypoTestMat)) {
      enrichmentCycler$counter <- enrichmentCycler$counter + 1
    } else if (enrichmentCycler$counter == length(input$hypoTestMat)) {
      enrichmentCycler$counter <- 1
    }
  })

  observeEvent(input$generateEnrichments, {
    enable("enrichmentCyclePrevious")
    enable("enrichmentCycleNext")
    output$enrichmet_currentCompareText <- renderText(input$hypoTestMat[enrichmentCycler$counter])
  })


  output$webgestalt_enrichment_variations_render <- renderUI({
    if (input$webgestalt_tests == "ORA") {
      pickerInput(inputId = "enrichment_data_options_ora",
                  label = "What should be enriched",
                  c("All protein IDs" = "all",
                    "Upregulated proteins" = "up",
                    "Downregulated proteins" = "down"),
                  selected = "all",
                  multiple = FALSE,
                  choicesOpt = list(
                    style = rep(("color: black;"),3)))
    } else {
      pickerInput(inputId = "enrichment_data_options_gsea",
                  label = "What should be enriched",
                  c("Strict" = "strict",
                    "Lenient" = "lenient",
                    "All protein IDs" = "all"),
                  selected = "strict",
                  multiple = FALSE,
                  choicesOpt = list(
                    style = rep(("color: black;"),3)))
    }

  })

  output$webgestalt_function <- renderUI({
    if (input$webgestalt_db == "pathway") {
      pickerInput(inputId = "webgestalt_function_picker",
                  label = "Choose pathway database",
                  choices = c("KEGG" = "pathway_KEGG",
                              "Panther" = "pathway_Panther",
                              "Reactome" = "pathway_Reactome",
                              "Wiki pathway" = "pathway_Wikipathway"),
                  selected = "pathway_KEGG",
                  choicesOpt = list(
                    style = rep(("color: black;"),4)))
    } else {
      pickerInput(inputId = "webgestalt_function_picker",
                  label = "Choose enrichment database",
                  choices = c("Biological processes" = "geneontology_Biological_Process",
                              "Molecular function" = "geneontology_Molecular_Function",
                              "Cellular component" = "geneontology_Cellular_Component"),
                  choicesOpt = list(
                    style = rep(("color: black;"),3)))
    }
  })

  output$webgestalt_fdr_render <- renderUI({
    if (input$webgestalt_tests == "ORA") {
      radioButtons(inputId = "webgestalt_fdr",
                   label = "Choose correction method",
                   choices = c("False discovery rate" = "fdr",
                               "Top" = "top"),
                   selected = "fdr",
                   inline = TRUE)
    } else {
      return(NULL)
    }
  })

  output$webgestalt_fdr_options_render <- renderUI({
    if (input$webgestalt_tests == "ORA" && input$webgestalt_fdr == "fdr") {
      pickerInput(inputId = "webgestalt_fdr_options",
                  label = "Choose enrichment FDR cut off",
                  choices = c(p.adjust.methods[1:6]),
                  selected = "BH",
                  choicesOpt = list(
                  style = rep(("color: black;"),6)))
    } else {
      return(NULL)
    }
  })

  output$webgestalt_sig_slider <- renderUI({
    if (input$webgestalt_tests == "ORA" && input$webgestalt_fdr == "fdr") {
      radioButtons(inputId = "webgestalt_sig_radio_out",
                   label = "Choose test FDR cut-off",
                   choices = c(0.01, 0.05),
                   selected = 0.05,
                   inline = TRUE)
    }
  })

  output$webgestalt_yaxis_render <- renderUI({
    if (input$webgestalt_tests == "ORA") {
      pickerInput(inputId = "webgestalt_yaxis",
                  label = "Choose plot data",
                  choices = c("Enrichment ratio" = "enrichmentRatio",
                              "P-value" = "pValue",
                              "False discovery rate" = "FDR"),
                  selected = "enrichmentRatio",
                  multiple = FALSE,

                  options = list(`actions-box` = TRUE,
                                 `selected-text-format` = "count > 0"),
                  choicesOpt = list(
                    style = rep(("color: black;"), 3)))
    } else {
      pickerInput(inputId = "webgestalt_yaxis",
                  label = "Y axis",
                  choices = c("Enrichment score" = "enrichmentScore",
                              "Normalised enrichment score" = "normalizedEnrichmentScore",
                              "p-value" = "pValue",
                              "False discovery rate" = "FDR"),
                  selected = "normalizedEnrichmentScore",
                  multiple = FALSE,

                  options = list(`actions-box` = TRUE,
                                 `selected-text-format` = "count > 0"),
                  choicesOpt = list(
                    style = rep(("color: black;"), 4)))
      }
    })

  output$top_enrichment_slider <- renderUI({
    if (input$webgestalt_tests == "ORA" && input$webgestalt_fdr == "top") {
      sliderInput(inputId = "webgestalt_top_calc_slider",
                  label = "Plot top n enrichments",
                  min = 1, max = 30, step = 1,
                  value = 10)

    }
  })


  encrichment_input_data <- reactive({
    if (input$generateEnrichments > 0) {
      enrichment_data_list <- list()
      for (i in 1:length(input$hypoTestMat)) {
        fit2 <- statsTestedData()
        statComb <- statComb()

        d.out <- data.frame(ID = names(fit2$coefficients[,i]),
                            pValue = fit2$p.value[,i],
                            qValue = p.adjust(fit2$p.value[,i], input$pvalAdjust),
                            EffectSize = fit2$coefficients[,i],
                            comparison = statComb[i])
        d.out <- mutate(d.out,
                        significant = ifelse(d.out$EffectSize > input$UserFCCutoff & round(d.out$qValue, 3) < input$UserSigCutoff, "Upregulated",
                                     ifelse(d.out$EffectSize < (input$UserFCCutoff * -1) & round(d.out$qValue, 3) < input$UserSigCutoff, "Downregulated", "Non_significant")))


        d2 <- data.frame(d.out,
                         colsplit(string = d.out$ID,
                                  pattern = "_",
                                  names = c("UniprotID", "GeneName")))

        enrichment_data_name <- input$hypoTestMat[i]
        enrichment_data_list[[enrichment_data_name]] = d2

      } # for loop close


      enrichment_target_df <- enrichment_data_list[[enrichmentCycler$counter]]
      validate(need(enrichment_target_df,
                    message = "Start the calculations first"))
    }

    return(enrichment_target_df)
  })

  enrichment_data <- eventReactive(input$calculateEnrichments, {
    encrichment_input_data <- encrichment_input_data()
    if (input$webgestalt_tests == "ORA") {
      if (input$enrichment_data_options_ora == "up") {
        enrichment_target_list_up <- ora_list(ora_data = encrichment_input_data,
                                              regulation = "Upregulated")


        enrichment_out_up <- webbestaltEnrichment(data = enrichment_target_list_up)


        enrichment_out_data <- enrichment_out_up


      } else if (input$enrichment_data_options_ora == "down") {

        enrichment_target_list_down <- ora_list(ora_data = encrichment_input_data,
                                             regulation = "Downregulated")


        enrichment_out_down <- webbestaltEnrichment(data = enrichment_target_list_down)


        enrichment_out_data <- enrichment_out_down


      } else {

        enrichment_target_list_up <- ora_list(ora_data = encrichment_input_data,
                                              regulation = "Upregulated")

        enrichment_target_list_down <- ora_list(ora_data = encrichment_input_data,
                                                regulation = "Downregulated")


        enrichment_out_up <- webbestaltEnrichment(data = enrichment_target_list_up)



        enrichment_out_down <- webbestaltEnrichment(data = enrichment_target_list_down)


        if (!is.null(enrichment_out_down)) {
          enrichment_out_down$enrichmentRatio <- enrichment_out_down$enrichmentRatio * - 1

        }


        enrichment_out_data <- rbind(enrichment_out_up, enrichment_out_down)


      }

    } else {
      #GSEA starts here

      gsea_data <- gsea_df(gsea_data = encrichment_input_data,
                           enrichment_options = input$enrichment_data_options_gsea,
                           sig_cutoff = input$UserSigCutoff)

      enrichment_out_data <- webbestaltEnrichment(data = gsea_data)


    }
    return(enrichment_out_data)
  })

  enrichment_data_filtered <- reactive({
    enrichment_data <- enrichment_data()
    if (input$webgestalt_tests == "ORA") {

      validate(
        need(enrichment_data$enrichmentRatio,
             message = paste0("recalculate")))

      if (input$enrichment_data_options_ora == "up") {
        if (!is.null(enrichment_data)) {
          enrichment_data = enrichment_data %>%
            arrange(desc(enrichmentRatio)) %>%
            slice(1:input$webgestalt_top_n_slider)
        }

        validate(
          need(enrichment_data$FDR,
               message = paste0("No",
                                " ",
                                error_message_webgestalt(inputCall = input$webgestalt_function_picker),
                                " ",
                                "were enriched, try another method or pathway"))
        )

      } else if (input$enrichment_data_options_ora == "down") {
        if (!is.null(enrichment_data)) {
          enrichment_data = enrichment_data %>%
            arrange(enrichmentRatio) %>%
            slice(1:input$webgestalt_top_n_slider)
        }

        validate(
          need(enrichment_data$FDR,
               message = paste0("No",
                                " ",
                                error_message_webgestalt(inputCall = input$webgestalt_function_picker),
                                " ",
                                "were enriched, try another method or pathway"))
        )

      } else {
        # merged up and down
        if (!is.null(enrichment_data)) {
          enrichment_up = enrichment_data %>%
            filter(enrichmentRatio > 0) %>%
            arrange(desc(enrichmentRatio)) %>%
            slice(1:input$webgestalt_top_n_slider)

          enrichment_down = enrichment_data %>%
            filter(enrichmentRatio < 0) %>%
            arrange(enrichmentRatio) %>%
            slice(1:input$webgestalt_top_n_slider)

          enrichment_data <- rbind(enrichment_up, enrichment_down)
        }


        validate(
          need(enrichment_data$FDR,
               message = paste0("No",
                                " ",
                                error_message_webgestalt(inputCall = input$webgestalt_function_picker),
                                " ",
                                "were enriched, try another method or pathway"))
        )

      }
    } else {
      #GSEA

      enrichment_data <- gsea_webgestalt_df(data = enrichment_data, topN = input$webgestalt_top_n_slider)


      validate(
        need(enrichment_data$FDR,
             message = paste0("No",
                              " ",
                              error_message_webgestalt(inputCall = input$webgestalt_function_picker),
                              " ",
                              "were enriched, try another method or pathway"))
      )
    }

    return(enrichment_data)

  })

  observeEvent(input$webgestalt_tables, {
    showModal(tags$div(id="ORA", data_table))
  })

  data_table <- modalDialog(

    fluidPage(
      h3(strong("Enrichment table"), align="left"),
      dataTableOutput('table_render')
    ),
    size="l",
    easyClose = TRUE,
    fade = TRUE
  )

  output$table_render <-  DT::renderDataTable({
    datatable(enrichment_data_filtered(), extensions = 'Buttons',
              options = list(
                scrollX = T,
                autoWidth = TRUE,
                dom = "Blfrtip",
                buttons =
                  list("copy", list(
                    extend = "collection",
                    buttons = c("csv", "excel", "pdf"),
                    text = "Download", filename = paste0(input$webgestalt_tests,
                                                         "_",
                                                         input$hypoTestMat[enrichmentCycler$counter],
                                                         "_",
                                                         input$webgestalt_function_picker)
                  ) ), # end of buttons customization

                # customize the length menu
                lengthMenu = list( c(10, 20, -1) # declare values
                                   , c(10, 20, "All") # declare titles
                ), # end of lengthMenu customization
                pageLength = 10
              ))

  })

  enrichment_plot <- reactive({
    enrichment_data <- enrichment_data_filtered()
    if (input$webgestalt_tests == "GSEA") {
      validate(need(enrichment_data$normalizedEnrichmentScore,
                    message = "Recalculate the enrichment"))
    } else {
      validate(need(enrichment_data$enrichmentRatio,
                    message = "Recalculate the enrichment"))
    }

    p <- ggplot(enrichment_data, aes_string(x = paste0("reorder(description",
                                                       ",",
                                                       "",
                                                       "-",
                                                       input$webgestalt_yaxis,
                                                       ")"),
                                            y = input$webgestalt_yaxis)) +
      geom_bar(stat = "identity", fill = input$webgestalt_colour_fill, colour = "black") +
      ylab(input$webgestalt_x_label) + xlab(input$webgestalt_y_label) +
      coord_flip() +
      theme_classic(base_size = 14) +
      theme(axis.text.x = element_text(size = input$enrichment_x_axis_font_size),
            axis.text.y = element_text(size = input$enrichment_y_axis_font_size, face = "bold"),
            axis.title.x = element_text(size = input$enrichment_x_title_font_size),
            axis.title.y = element_text(size = input$enrichment_y_title_font_size))


    return(p)
  })

  output$webgestalt_plot <- renderPlot({
    if (input$calculateEnrichments == 0) {
      return(NULL)
    } else {
      enrichment_plot()
    }
  })


#stringDB-------------------------------------------------------------------------------------->
#basic buid: construct a base html and hit the stringt api using httr
#
  # Server side UI logic

  stringCycler <- reactiveValues(counter = 1)

  observeEvent(input$stringCyclePrevious, {
    if (stringCycler$counter > 1) {
      stringCycler$counter <- stringCycler$counter - 1
    }
  })

  observeEvent(input$stringCycleNext, {
    if (stringCycler$counter < length(input$hypoTestMat)) {
      stringCycler$counter <- stringCycler$counter + 1
    } else if (stringCycler$counter == length(input$hypoTestMat)) {
      stringCycler$counter <- 1
    }
  })

  observeEvent(input$generateStringNetwork, {
    enable("stringCyclePrevious")
    enable("stringCycleNext")
    output$string_currentCompareText <- renderText(input$hypoTestMat[stringCycler$counter])
  })


  # server sude UI rendereing
  output$string_data_inputs <- renderUI({
    if (input$string_data_options == "upregulated" || input$string_data_options == "downregulated") {
      sliderInput(inputId = "string_no_of_proteins",
                  label = "Number of proteins",
                  min = 1, max = 50, step = 1,
                  value = 1)
    } else {
      textInput(inputId = "string_proteins_user",
                label = "Enter proteins comma separated",
                placeholder = "O69732,P9WJC1")
    }
  })

  # data input

  string_full_sig_data <- reactive({
    if (input$generateStringNetwork > 0) {
      string_data_list <- list()
      for (i in 1:length(input$hypoTestMat)) {
        fit2 <- statsTestedData()
        statComb <- statComb()

        d.out <- data.frame(ID = names(fit2$coefficients[,i]),
                            pValue = fit2$p.value[,i],
                            qValue = p.adjust(fit2$p.value[,i], input$pvalAdjust),
                            EffectSize = fit2$coefficients[,i],
                            comparison = statComb[i])
        d.out <- mutate(d.out,
                        significant = ifelse(d.out$EffectSize > input$UserFCCutoff & round(d.out$qValue, 3) < input$UserSigCutoff, "upregulated",
                                             ifelse(d.out$EffectSize < (input$UserFCCutoff * -1) & round(d.out$qValue, 3) < input$UserSigCutoff, "downregulated", "non_significant")))


        d2 <- data.frame(d.out,
                         colsplit(string = d.out$ID,
                                  pattern = "_",
                                  names = c("UniprotID", "GeneName")))

        string_data_name <- input$hypoTestMat[i]
        string_data_list[[string_data_name]] = d2

      } # for loop close


      string_target_df <- string_data_list[[stringCycler$counter]]
      validate(need(string_target_df,
                    message = "Start the calculations first"))
    }

    return(string_target_df)
  })


  string_URL_data <- reactive({
    df <- string_full_sig_data()
    if (input$string_data_options == "custom") {
      string_df <- input$string_proteins_user
    } else if (input$string_data_options == "upregulated") {
      string_df <- df %>%
        filter(significant == input$string_data_options) %>%
        arrange(EffectSize) %>%
        select(UniprotID) %>%
        slice(1:input$string_no_of_proteins)

    } else if (input$string_data_options == "downregulated") {
      string_df <- df %>%
        filter(significant == input$string_data_options) %>%
        arrange(EffectSize) %>%
        slice(1:input$string_no_of_proteins)


    }
    return(string_df)
  })

  string_url <- reactive({

    if (input$string_data_options == "custom") {
      URL <- string_url_builder(sig_thresh = input$string_sig_threshold,
                                max_nodes = input$string_max_threshold,
                                protein_querry = reformat_proteinID(input_ID = string_URL_data(),
                                                                    data_options = input$string_data_options))
    } else {
      string_df <- string_URL_data()
      URL <- string_url_builder(sig_thresh = input$string_sig_threshold,
                                max_nodes = input$string_max_threshold,
                                protein_querry = reformat_proteinID(input_ID = string_df$UniprotID,
                                                                    data_options = input$string_data_options))
    }

    return(URL)
  })

  # render image
  output$string_image <- renderUI({
    if (input$generateStringNetwork > 0) {

      div(
        tags$img(src=string_url(),
                 id="stringImage",
                 width="auto",
                 height="auto",
                 align="left",
                 style = "position: center;"
        ))

    } else {
      return(c("Start calculations first"))
    }


  })



  #downlowding--------------------------------------------------------------------------------------------------------->
  #Citations------------------------------------------------------------->
  citation_filename <- reactive({
    switch (input$citation_options,
      All = {return("all_citations.ris")},
      Provision = {return("Provision_citation.ris")},
      StringDB = {return("StringDB_citation.ris")},
      Webgestalt = {return("Webgestalt_citation.ris")},
      Limma = {return("Limma_citation.ris")}

    )
  })
  output$citation_download <- downloadHandler(
    filename <- function() {
      citation_filename()
    },

    content <- function(file) {
      citation_file <- input$citation_options
      file.copy(str_glue("www/data/{citation_file}.ris"), file)
    },
    contentType = "application/ris"
  )

  #processed data-------------------------------------------------------->
  output$ProcDataSelectorUI <- renderUI({
    if (input$ProcDataDownType == "txt") {
      selectInput(inputId = "ProcDataDownSep",
                  label = "Choose separator",
                  choices = c("Tab" = "\t",
                              "Comma" = ",",
                              "Space" = " ",
                              "Colon" = ";"),
                  selected = "\t")
    }
  })
  dataFileName <- reactive({
    if (input$ProcDataDownName == "") {
      if (input$ProcDataDownType == "xlsx") {

        n = paste(Sys.Date(), "-", "processedMQ", ".", "xlsx", sep = "")
      } else {
        n = paste(Sys.Date(), "-", "processedMQ", ".", "txt", sep = "")
      }
    } else {
      if (input$ProcDataDownType == "xlsx") {
        n = paste(input$ProcDataDownName, ".", "xlsx", sep = "")
      } else {
        n = paste(input$ProcDataDownName, ".txt", sep = "")
      }
    }
    return(n)
  })
  dataoutprocess <- reactive({
    d <- processed_data()
    anno_data <- anno_data()
    gene.names <- d$GeneNames
    d$GeneNames <- NULL
    colnames(d) <- anno_data[1:nrow(anno_data),3]
    d$UniprotID <- rownames(d)
    d$GeneNames <- gene.names
    return(d)
  })

  output$filt1_download <- downloadHandler(
    filename = function() {
      dataFileName()
    },
    content = function(file) {
      if (input$ProcDataDownType == "xlsx") {
        write.xlsx2(dataoutprocess(),
                    file = file,
                    sheetName = "Sheet1",
                    col.names = TRUE,
                    row.names = FALSE,
                    append = FALSE)
      } else {
        write.table(dataoutprocess(),
                    file = file,
                    sep = input$ProcDataDownSep,
                    row.names = F)

      }

    }
  )

  #Significant data
  output$SigDataSelectorUI <- renderUI({
    if (input$SigDataDownType == "txt") {
      selectInput(inputId = "SigDataDownSep",
                  label = "Choose separator",
                  choices = c("Tab" = "\t",
                              "Comma" = ",",
                              "Space" = " ",
                              "Colon" = ";"),
                  selected = "\t")
    }
  })
  SigFileName <- reactive({

    if (input$WhichSigDataDown == "current") {

      if (input$SigDataDownName == "") {
        if (input$SigDataDownType == "xlsx") {

          n = paste(Sys.Date(), "-", "Statistics-",input$hypoTestMat[statsCycler$counter], ".", "xlsx", sep = "")
        } else {
          n = paste(Sys.Date(), "-", "Statistics-",input$hypoTestMat[statsCycler$counter], ".", "txt", sep = "")
        }
      } else {
        if (input$SigDataDownType == "xlsx") {
          n = paste(input$SigDataDownName, ".", "xlsx", sep = "")
        } else {
          n = paste(input$SigDataDownName, ".txt", sep = "")
        }
      }

    } else {

      n <- "Statistics.zip"

    }

    return(n)
  })
  dataoutSig <- reactive({
    if (input$WhichSigDataDown == "current") {
      d <- statsOut()
      d$UniprotID <- rownames(d)
      return(d)
    } else {
      fit2 <- statsTestedData()
      datList <- lapply(1:length(statComb()), function(i) {
        d.out <- paste("d-", i, sep = "")
        d.out <- data.frame(ID = names(fit2$coefficients[,i]),
                            pValue = fit2$p.value[,i],
                            qValue = p.adjust(fit2$p.value[,i], input$pvalAdjust),
                            EffectSize = fit2$coefficients[,i],
                            comparison = statComb()[i])

        d.out <- mutate(d.out,
                        sig = ifelse(d.out$EffectSize > input$UserFCCutoff & round(d.out$qValue, 3) < input$UserSigCutoff, "Upregulated",
                                     ifelse(d.out$EffectSize < (input$UserFCCutoff * -1) & round(d.out$qValue, 3) < input$UserSigCutoff, "Downregulated", "Non significant")))
        dat <- data.frame(d.out,
                          colsplit(string = d.out$ID,
                                   pattern = "_",
                                   names = c("UniprotID", "GeneName")))
        dat$ID <- NULL
        return(dat)

      })
      return(datList)
    }
  })

  output$SigDownload <- downloadHandler(
    filename = function() {
      SigFileName()
    },
    content = function(file) {
      if (input$WhichSigDataDown == "current") {
        if (input$SigDataDownType == "xlsx") {
          write.xlsx2(dataoutSig(),
                      file = file,
                      sheetName = "Sheet1",
                      col.names = TRUE,
                      row.names = FALSE,
                      append = FALSE)
        } else {
          write.table(dataoutSig(),
                      file = file,
                      sep = input$SigDataDownSep,
                      row.names = F)

        }
      } else {
        files <- NULL;
        withProgress(message = "Saving files", value = 0, {
          for (i in 1:length(dataoutSig())) {
            if (input$SigDataDownType == "xlsx") {
              fileName = paste(Sys.Date(), "-", "Statistics", "-", statComb()[i], ".", "xlsx", sep = "")
              write.xlsx2(dataoutSig()[i],
                          file = fileName,
                          sheetName = "Sheet1",
                          col.names = TRUE,
                          row.names = FALSE,
                          append = FALSE)
            } else {
              fileName = paste(Sys.Date(), "-", "Statistics", "-", statComb()[i], ".", "txt", sep = "")
              write.table(dataoutSig()[i],
                          file = fileName,
                          sep = input$SigDataDownSep,
                          row.names = F)
            } #file naming close
            files <- c(fileName, files)
            incProgress(1/length(dataoutSig()),
                        detail = paste("Adding file:", i, sep = " "))
          } # for loop close
        })

        zip(file, files)
      }

    }
  )
  #normaldistrubtion--------------------------------------------------------------------------------------------->
  normFileName <- reactive({
    if (input$normFigDownChoice == "Current") {
      p <- NormalityPlot()[Counter$normcounter]
      axisTitleList <- as.character(unlist(p[[1]][["labels"]]))

      if (input$normPlotChoice == "qqPlot") {
        name <- paste("qqPlot-",
                      axisTitleList[3], ".",
                      input$normFigDownType,
                      sep = "")
      } else {
        name <- paste("Histogram-",
                      axisTitleList[2], ".",
                      input$normFigDownType,
                      sep = "")
      }

    } else {
      if (input$normPlotChoice == "qqPlot") {
        name <- "qqplots.zip"
      } else {
        name <- "Histograms.zip"
      }

    }
    return(name)
  })

  output$normFigDownload <- downloadHandler(
    filename = function() { normFileName() },
    content = function(file) {
      if (input$normFigDownChoice == "Current") {
        ggsave(file,
               plot = NormalityPlot()[[Counter$normcounter]],
               device = isolate(input$normFigDownType),
               dpi = isolate(input$normFigRes)
        )
      } else {
        files <- NULL;
        withProgress(message = "Saving files", value = 0, {
          for (i in 1:length(NormalityPlot())) {
            p <- NormalityPlot()[[i]]
            axisTitleList <- as.character(unlist(p[["labels"]]))

            if (input$normPlotChoice == "qqPlot") {
              FileName <- paste("qqPlot-", axisTitleList[3], ".",
                                input$normFigDownType,
                                sep = "")
            } else{
              FileName <- paste("Histogram-", axisTitleList[2], ".",
                                input$normFigDownType,
                                sep = "")
            }

            ggsave(filename = FileName,
                   plot = NormalityPlot()[[i]],
                   device = isolate(input$normFigDownType),
                   dpi = isolate(input$normFigRes)
            )
            #files
            files <- c(FileName, files)
            incProgress(amount = 1/length(NormalityPlot()),
                        detail = paste("Adding plot:", i, sep = " "))
          }
        })
        zip(file, files)
      }
    }
  )

  #scatterplots------------------------------------------------------------------------------------------->
  scatFileName <- reactive({
    if (input$scatFigDownChoice == "Current") {
      p <- scatter_user()[[Counter$scatcounter]]
      axisTitleList <- as.character(unlist(p[["labels"]]))
      axisTitle <- paste(axisTitleList[1], axisTitleList[2], sep = "-")
      name <- paste("Scatter-", axisTitle, ".", input$scatFigDownType,
                    sep = "")
    } else {
      name <- "Scatterplots.zip"
    }
    return(name)
  })

  output$scatFigDownload <- downloadHandler(
    filename = function() { scatFileName() },
    content = function(file) {
      if (input$scatFigDownChoice == "Current") {
        ggsave(file,
               plot = scatter_user()[[Counter$scatcounter]],
               device = isolate(input$scatFigDownType),
               dpi = isolate(input$scatFigRes)
        )
      } else {
        files <- NULL;
        withProgress(message = "Saving files", value = 0, {
          for (i in 1:length(scatter_user())) {
            p <- scatter_user()[[i]]
            axisTitleList <- as.character(unlist(p[["labels"]]))
            axisTitle <- paste(axisTitleList[1], axisTitleList[2], sep = "-")
            FileName <- paste("Scatter-", axisTitle, ".", input$scatFigDownType,
                              sep = "")

            ggsave(filename = FileName,
                   plot = scatter_user()[[i]],
                   device = isolate(input$scatFigDownType),
                   dpi = isolate(input$scatFigRes)
            )
            #files
            files <- c(FileName, files)
            incProgress(1/length(scatter_user()), detail = paste("Adding plot:", i, sep = " "))
          }
        })

        zip(file, files)
      }
    }
  )

  #correlation----------------------------------------------------------------------------------------------------->
  corrFileName <- reactive({
    name <- paste("Correlogram", ".", input$corrFigDownType,
                  sep = "")

    return(name)
  })

  output$corrFigDownload <- downloadHandler(
    #getting input is not working for filename
    filename = function() {corrFileName() },
    content = function(file) {
      ggsave(file,
             plot = correllelogram(),
             device = isolate(input$corrFigDownType),
             dpi = isolate(input$corrFigRes))
    }
  )

  #pcaPlotDownloads
  pcaFileName <- reactive({
    name <- paste("PCA-plot", ".", input$pcaFigDownType,
                  sep = "")

    return(name)
  })

  output$pcaFigDownload <- downloadHandler(
    #getting input is not working for filename
    filename = function() {pcaFileName() },
    content = function(file) {
      ggsave(file,
             plot = pcaPlots(),
             device = isolate(input$pcaFigDownType),
             dpi = isolate(input$pcaFigRes))
    }
  )
  #volcanos---------------------------------------------------------------------------------------------->
  volcFileName <- reactive({
    if (input$mainFigDownTitle == "") {

      n <- paste("Volcano-", input$hypoTestMat[volcCycler$counter], ".", input$mainFigDownType,
                 sep = "")
    } else {

      n <- paste("Volcano-", input$mainFigDownTitle, ".", input$mainFigDownType,
                 sep = "")
    }

    return(n)
  })
  output$VolcDownloader <- downloadHandler(
    #getting input is not working for filename
    filename = function() {volcFileName() },
    content = function(file) {
      ggsave(file,
             plot = volcPlot(),
             device = isolate(input$mainFigDownType),
             dpi = isolate(input$mainFigRes))
    }
  )

  #heatmap------------------------------------------------------------------------------------------>
  heatmapFileName <- reactive({
    if (input$mainFigDownTitle == "") {
      n <- paste("Heatmap-", input$hypoTestMat[HMCycler$counter], ".", input$mainFigDownType,
                 sep = "")
    } else {

      n <- paste("Heatmap-", input$mainFigDownTitle, ".", input$mainFigDownType,
                 sep = "")
    }
    return(n)
  })


  output$HMDownloader <- downloadHandler(
    #getting input is not working for filename
    filename = function() {heatmapFileName() },
    content = function(file) {
      ggsave(file,
             plot = UserHeatmap(),
             device = isolate(input$mainFigDownType),
             dpi = isolate(input$mainFigRes))
    }
  )
  #----------------------------------------------------------------------------------------------->
  #Webgestalt download
  #volcanos
  enrichmentFileName <- reactive({
    if (input$mainFigDownTitle == "") {

      n <- paste("Webgestalt-", input$hypoTestMat[enrichmentCycler$counter], ".", input$mainFigDownType,
                 sep = "")
    } else {

      n <- paste("Webgestalt-", input$mainFigDownTitle, ".", input$mainFigDownType,
                 sep = "")
    }

    return(n)
  })
  output$webgestalt_downloader <- downloadHandler(
    #getting input is not working for filename
    filename = function() {enrichmentFileName() },
    content = function(file) {
      ggsave(file,
             plot = enrichment_plot(),
             device = isolate(input$mainFigDownType),
             dpi = isolate(input$mainFigRes))
    }
  )

  #StringDownload------------------------------------------------------------------------------------>

  string_url_dl <- reactive({

    if (input$string_data_options == "custom") {
      URL <- string_url_builderDL(sig_thresh = input$string_sig_threshold,
                                max_nodes = input$string_max_threshold,
                                protein_querry = reformat_proteinID(input_ID = string_URL_data(),
                                                                    dtype = input$string_image_extention,
                                                                    data_options = input$string_data_options))
    } else {
      string_df <- string_URL_data()
      URL <- string_url_builderDL(sig_thresh = input$string_sig_threshold,
                                max_nodes = input$string_max_threshold,
                                dtype = input$string_image_extention,
                                protein_querry = reformat_proteinID(input_ID = string_df$UniprotID,
                                                                    data_options = input$string_data_options))
    }

    return(URL)
  })

  output$string_download_image <- downloadHandler(
    filename = function() {
      if (input$string_image_extention == "highres_image") {
        paste0("String_network", Sys.Date(), ".png")
      } else {
        paste0("String_network", Sys.Date(), ".svg")
      }

    },
    content = function(file) {
      GET(string_url_dl(), write_disk(file))
    }
  )

  ###about us tab ###


} #server close

shinyApp(ui, server)


```



```{r DEP}
#http://www.matrixscience.com/blog/using-the-quantitation-summary-to-create-reports-and-charts.html
#BiocManager::install("DEP")
library("DEP")
inpD <-getwd()
data = read.table(paste0(inpD,"/PXD004163.txt"),stringsAsFactors = FALSE, header = TRUE, quote = "", comment.char = "", sep = "\t")
# tweaks to data frame required by DEP
data$Gene.names = data$Protein.IDs
data$Majority.protein.IDs = data$Protein.IDs
colnames(data)[colnames(data) == 'Peptide.counts..all.'] <- 'Peptides'
colnames(data)[colnames(data) == 'Peptide.counts..unique.'] <- 'Unique.peptides'
data$Razor...unique.peptide = data$Unique.peptides
data$Protein.names = data$Fasta.headers
colnames(data)
dim(data) 
data <- filter(data,Potential.contaminant!="+")
dim(data) 
data_unique <- make_unique(data, "Gene.names", "Protein.IDs", delim = ";")
LFQ_columns <- grep("Intensity.", colnames(data_unique))
experimental_design = read.table(paste0(inpD,"/PXD004163_exp_des.txt"),stringsAsFactors = FALSE, header = TRUE, quote = "", comment.char = "", sep = "\t")
summary(experimental_design)
data_se <- make_se(data_unique, LFQ_columns, experimental_design)
summary(data_se)
plot_frequency(data_se)
data_filt <- filter_missval(data_se, thr = 0)
plot_numbers(data_filt)
data_norm <- normalize_vsn(data_filt)
plot_normalization(data_filt, data_norm)
plot_detect(data_filt)
data_imp <- impute(data_norm, fun = "MinProb", q = 0.01)
plot_imputation(data_norm, data_imp)
data_diff <- test_diff(data_imp, type = "control", control = "siCtrl")
dep <- add_rejections(data_diff, alpha = 0.05, lfc = log2(1.5))
plot_pca(dep, x = 1, y = 2, n = 500, point_size = 4)
plot_cor(dep, significant = TRUE, lower = 0.8, upper = 1, pal = "Reds")
plot_heatmap(dep, type = "centered", kmeans = TRUE, k = 6, col_limit = 4, show_row_names = FALSE, indicate = c("condition", "replicate"))
plot_heatmap(dep, type = "contrast", kmeans = TRUE, k = 6, col_limit = 10, show_row_names = FALSE)
plot_volcano(dep, contrast = "miR_191_vs_siCtrl", label_size = 2, add_names = TRUE)
```


```{r MSnbase}
#https://www.youtube.com/watch?v=TyRJOrFfQus
#https://docs.google.com/document/d/1N_L2UTOepitl-uHOjfyS8EtkWFNvcQFyQZhU8nFr2AY/edit
#https://lgatto.github.io/2020_05_07_MayInstitute/
install.packages(“microbenchmark”)
install.packages(“magrittr”)
install.packages(“pryr”)
install.packages(“plotly”)
install.packages(“remotes”)
install.packages(“BiocManager”)
BiocManager::install(“MSnbase”)
BiocManager::install(“msdata”)
BiocManager::install(“lgatto/MSnbaseBoxCar”)
BiocManager::install("MSnbase")

library(MSnbase)
library(magrittr)
f <- msdata::proteomics(pattern = "201412", full.names = TRUE)
basename(f)
system.time(x_dsk <- readMSData(f, mode = "onDisk"))
sp <- x_dsk[[1]]
plot(sp)
chr1 <- chromatogram(x_dsk)
plot(chr1)
plot(x_dsk2[[1227]], reporters = TMT6, full = TRUE)

library(MSnbaseBoxCar)
bcf <- 
   dir(system.file("extdata", package = "MSnbaseBoxCar"),
    pattern = "boxcar.mzML", 
    full.names = TRUE)
bc <- readMSData(bcf, mode = "onDisk") 
bc
p <- plot(bc[1:4])
bc2 <- bc %>% 
   bc_groups() %>% 
   filterBoxCar() %>% 
   bc_zero_out_box() %>% 
   combineSpectra(fcol = "bc_groups",
                  method = boxcarCombine)
```

```{r LFQbench, echo = FALSE}
#https://github.com/IFIproteomics/LFQbench
install.packages("devtools")
library(devtools)
install_github("IFIproteomics/LFQbench")
library(LFQbench)
```

```{r pkgs, echo = FALSE}
#https://jokergoo.github.io/2020/05/31/word-cloud-as-heatmap-annotation/
install.packages("SDMTools")
library(SDMTools)
tmp_file = tempfile()
download.file("https://jokergoo.github.io/word_cloud_annotation_example.RData", 
    destfile = tmp_file, quiet = TRUE)
load(tmp_file); file.remove(tmp_file)
```



```{r tidyHeatmap, echo = FALSE}
#https://github.com/stemangiola/tidyHeatmap
install.packages("tidyHeatmap")
#devtools::install_github("stemangiola/tidyHeatmap")
library(tidyHeatmap)
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
heatmap(test)  # this is ComplexHeatmap::pheatmap
```

```{r review, echo = FALSE}
#check min-max scaling robustness to outliers
data<-rnorm(100)
hist(data)
data<-c(data,rnorm(100,mean = 1000, sd = 1),rnorm(1,mean = -1000, sd = 1))
hist(data)
dataS<-(data-min(data))/(max(data)-min(data))
hist(dataS)
#
```

```{r pepFunk, echo = FALSE}
#https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/btaa289/5830271
#https://shiny.imetalab.ca/pepFunk/
#git clone https://github.com/animesh/pepFunk.git

```

```{r projectR, echo = FALSE}
#https://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/btaa183/5804979
#BiocManager::install("projectR")
#https://github.com/genesofeve/projectR/blob/master/vignettes/projectR.Rmd
library(projectR)
data(p.RNAseq6l3c3t)
# do PCA on RNAseq6l3c3t expression data 
pc.RNAseq6l3c3t<-prcomp(t(p.RNAseq6l3c3t))
pcVAR <- round(((pc.RNAseq6l3c3t$sdev)^2/sum(pc.RNAseq6l3c3t$sdev^2))*100,2)
dPCA <- data.frame(cbind(pc.RNAseq6l3c3t$x,pd.RNAseq6l3c3t))
#plot pca
library(ggplot2)
setCOL <- scale_colour_manual(values = c("blue","black","red"), name="Condition:") 
setFILL <- scale_fill_manual(values = c("blue","black","red"),guide = FALSE) 
setPCH <- scale_shape_manual(values=c(23,22,25,25,21,24),name="Cell Line:")
pPCA <- ggplot(dPCA, aes(x=PC1, y=PC2, colour=ID.cond, shape=ID.line, 
        fill=ID.cond)) +
        geom_point(aes(size=days),alpha=.6)+ 
        setCOL + setPCH  + setFILL +
        scale_size_area(breaks = c(2,4,6), name="Day") + 
        theme(legend.position=c(0,0), legend.justification=c(0,0),
              legend.direction = "horizontal",
              panel.background = element_rect(fill = "white",colour=NA),
              legend.background = element_rect(fill = "transparent",colour=NA),
              plot.title = element_text(vjust = 0,hjust=0,face="bold")) +
        labs(title = "PCA of hPSC",
            x=paste("PC1 (",pcVAR[1],"% of varience)",sep=""),
            y=paste("PC2 (",pcVAR[2],"% of varience)",sep=""))
plot(pPCA)
```

```{r NPARC, echo = FALSE}
#https://bioconductor.org/packages/release/bioc/vignettes/NPARC/inst/doc/NPARC.html
#Analysing thermal proteome profiling data
BiocManager::install("NPARC")
library("NPARC")
data("stauro_TPP_data_tidy")
df <- stauro_TPP_data_tidy
df %>%   mutate(compoundConcentration = factor(compoundConcentration), 
         replicate = factor(replicate), 
         dataset = factor(dataset)) %>%   
  summary()
df %<>% filter(uniquePeptideMatches >= 1)
df %<>% filter(!is.na(relAbundance))
nullFit <- NPARC:::fitSingleSigmoid(x = stk4$temperature, y = stk4$relAbundance)
```

```{r systemPipeR, echo = FALSE}
#https://bioconductor.org/packages/release/bioc/vignettes/systemPipeR/inst/doc/systemPipeR.html
#install.packages("BiocManager")
#BiocManager::install("systemPipeR")
#BiocManager::install("systemPipeRdata")
library("systemPipeR")  # Loads the package
library(help = "systemPipeR")  # Lists package info
vignette("systemPipeR")
library(systemPipeRdata)
genWorkenvir(workflow = "rnaseq")# Opens vignette
```

```{r structToolbox-metabolites+, echo = FALSE}
#https://bioconductor.org/packages/release/bioc/vignettes/structToolbox/inst/doc/data_analysis_omics_using_the_structtoolbox.html
BiocManager::install("structToolbox")
library("structToolbox")
D = iris_DatasetExperiment()
D$sample_meta$class = D$sample_meta$Species
P = PCA(number_components=15)
M = mean_centre() + PCA(number_components = 4)
M = model_train(M,D)
M = model_predict(M,D)
M = model_apply(M,D)
C = pca_scores_plot(factor_name='class') # colour by class
chart_plot(C,M[2])
```

```{r mitch-GSEA, echo = FALSE}
#https://bioconductor.org/packages/release/bioc/vignettes/mitch/inst/doc/mitchWorkflow.html
BiocManager::install("mitch")
library("mitch")
download.file("https://reactome.org/download/current/ReactomePathways.gmt.zip",destfile="ReactomePathways.gmt.zip")
unzip("ReactomePathways.gmt.zip")
genesets<-gmt_import("ReactomePathways.gmt")
data(genesetsExample)
head(genesetsExample,3)
data(rna,k9a)
x<-list("rna"=rna,"k9a"=k9a)
y<-mitch_import(x,"edgeR")
y<-mitch_import(rna,DEtype="edger")
rna_mod<-rna
rna_mod$MyGeneIDs<-rownames(rna_mod)
rownames(rna_mod)<-seq(nrow(rna_mod))
head(rna_mod)
res<-mitch_calc(y,genesetsExample,priority="significance",cores=2)
head(res$enrichment_result)
res<-mitch_calc(y,genesetsExample,priority="significance",minsetsize=5,cores=2)
head(res$enrichment_result)
res<-mitch_calc(y,genesetsExample,priority="significance",resrows=3,cores=2)
head(res$enrichment_result)
mitch_report(res,"myreport.html")
mitch_plots(res,outfile="mycharts.pdf")
```

```{r WebGestaltR, echo = FALSE}
#https://cran.r-project.org/web/packages/WebGestaltR/WebGestaltR.pdf
install.packages("WebGestaltR")
library("WebGestaltR")
help(WebGestaltR)
#ORA####
geneFile <- system.file("extdata", "interestingGenes.txt", package="WebGestaltR")
refFile <- system.file("extdata", "referenceGenes.txt", package="WebGestaltR")
outputDirectory <- getwd()
enrichResult <- WebGestaltR(enrichMethod="ORA", organism="hsapiens",
  enrichDatabase="pathway_KEGG", interestGeneFile=geneFile,
  interestGeneType="genesymbol", referenceGeneFile=refFile,
  referenceGeneType="genesymbol", isOutput=TRUE,
  outputDirectory=outputDirectory, projectName=NULL)
#GSEA####
rankFile <- system.file("extdata", "GeneRankList.rnk", package="WebGestaltR")
outputDirectory <- getwd()
enrichResult <- WebGestaltR(enrichMethod="GSEA", organism="hsapiens",
  enrichDatabase="pathway_KEGG", interestGeneFile=rankFile,
  interestGeneType="genesymbol", sigMethod="top", topThr=10, minNum=5,
  outputDirectory=outputDirectory)
#NTA#####
enrichResult <- WebGestaltR(enrichMethod="NTA", organism="hsapiens",
  enrichDatabase="network_PPI_BIOGRID", interestGeneFile=geneFile,
  interestGeneType="genesymbol", sigMethod="top", topThr=10,
  outputDirectory=getwd(), highlightSeedNum=10,
  networkConstructionMethod="Network_Retrieval_Prioritization")
```

```{r gene2num, echo = FALSE}
#https://www.gungorbudak.com/blog/2018/08/07/convert-gene-symbols-to-entrez-ids-in-r/
symbols <- c('AHNAK', 'BOD1L1', 'HSPB1', 'SMARCA4', 'TRIM28')
library(org.Hs.eg.db)#
select(org.Hs.eg.db, symbols, "ENTREZID", "SYMBOL")
inpD <-"C:/Users/animeshs/GD/"
inpF<-paste0(inpD,"gene")
gene <- read.delim(inpF,sep="\t",header = F)
gene2num<-select(org.Hs.eg.db, as.character(gene$V1), "ENTREZID", "SYMBOL")
outF<-paste0(inpD,"gene2num.txt")
write.table(gene2num,outF,sep = "\t")
#uniprot
inpF<-paste0(inpD,"uniprot")
uniprot <- read.delim(inpF,sep="\t",header = F)
uni2num<-select(org.Hs.eg.db, as.character(uniprot$V1), "ENTREZID", "UNIPROT")
outF<-paste0(inpD,"uni2num.txt")
write.table(uni2num,outF,sep = "\t")
```


```{r parametric-time-warping, echo = FALSE}
#https://www.bioconductor.org/packages/release/bioc/vignettes/RankProd/inst/doc/RankProd.pdf
#BiocManager::install("RankProd")
library(RankProd)
data(arab)
#Dilution <- ReadAffy()
#data<-exprs(rma(Dilution))
colnames(arab)
arab.cl
arab.sub <- arab[,which(arab.origin==1)]
arab.cl.sub <- arab.cl[which(arab.origin==1)]
arab.origin.sub <- arab.origin[which(arab.origin==1)]
RP.out <- RankProducts(arab.sub,arab.cl.sub, logged=TRUE, na.rm=FALSE,plot=FALSE, rand=123)
RP.out <- RankProducts(arab.sub,arab.cl.sub,gene.names=arab.gnames,rand=123)
RP.out <- RP.advance(arab.sub, arab.cl.sub, arab.origin.sub,logged = TRUE, na.rm = FALSE, gene.names = arab.gnames, plot = FALSE,rand = 123)
RP.out=RP.advance(arab.sub,arab.cl.sub,arab.origin.sub,gene.names=arab.gnames,rand=123)
RP.out <- RP(arab.sub,arab.cl.sub,gene.names=arab.gnames,rand=123)
RP.out=RPadvance(arab.sub,arab.cl.sub,arab.origin.sub,gene.names=arab.gnames, rand=123)
plotRP(RP.out, cutoff=0.05)
topGene(RP.out,cutoff=0.05,method="pfp",logged=TRUE,logbase=2,gene.names=arab.gnames)
topGene(RP.out,cutoff=0.05,method="pval",logged=TRUE,logbase=2,gene.names=arab.gnames)
topGene(RP.out,num.gene=50,gene.names=arab.gnames)
```

```{r parametric-time-warping, echo = FALSE}
#https://github.com/rwehrens/ptw/blob/master/ptwVignette/stickPTW.pdf
install.packages("ptw")
library(ptw)
```

```{r partial-least-squares/principal-component-regression, echo = FALSE}
#https://cran.r-project.org/web/packages/pls/vignettes/pls-manual.pdf
library(devtools)
#install_github("bhmevik/pls")
library(pls)
data(yarn)
data(oliveoil)
data(gasoline)
gasTrain <- gasoline[1:50,]
gasTest <- gasoline[51:60,]
gas1 <- plsr(octane ~ NIR, ncomp = 10, data = gasTrain, validation = "LOO")
summary(gas1)
plot(RMSEP(gas1), legendpos = "topright")
plot(gas1, ncomp = 2, asp = 1, line = TRUE)
plot(gas1, plottype = "scores", comps = 1:3)
explvar(gas1)
predict(gas1, ncomp = 2, newdata = gasTest)
RMSEP(gas1, newdata = gasTest)
dens1 <- plsr(density ~ NIR, ncomp = 5, data = yarn)
plsr(sensory ~ chemical, data = oliveoil)
gas2 <- plsr(octane ~ msc(NIR), ncomp = 10, data = gasTrain)
gas2.cv <- crossval(gas2, segments = 10)
plot(MSEP(gas2.cv), legendpos="topright")
summary(gas2.cv, what = "validation")
plot(gas1, plottype = "coef", ncomp=1:3, legendpos = "bottomleft",labels = "numbers", xlab = "nm")
```

```{r biomarker, echo = FALSE}
#https://openpub.fmach.it/retrieve/handle/10449/21657/4348/
#BiocManager::install("BioMark")
#install.packages("scatterplot3d")
library("BioMark")
library("scatterplot3d")
data("SpikePos")
scatterplot3d(SpikePos$annotation$rt, SpikePos$annotation$mz, sqrt(SpikePos$data[1,]), mar = c(4, 3, 0, 3) + 0.1, type = "h", highlight.3d = TRUE, angle = 110, box = FALSE, xlab = "Retention time (s)", ylab = "m/z", zlab = "sqrt(Intensity)")
simdata <- gen.data(ncontrol = 10, nvar = 800, group.diff = 1.5)
dim(simdata$X)
coldiffs <- sapply(1:100, function(i, x) colMeans(x[11:20, , i]) - colMeans(x[1:10, , i]), simdata$X)
rowMeans(coldiffs)[1:10]
mycov <- matrix(0, 800, 800)
mycov[row(mycov) <= 50 & col(mycov) <= 50] <- 0.3
mycov[row(mycov) > 50 & col(mycov) > 50] <- 0.7
diag(mycov) <- 1
simdata2 <- gen.data(ncontrol = 10, nvar = 800, group.diff = 1.5,cormat = mycov)
simdata3 <- gen.data(ncontrol = 10, nvar = ncol(SpikePos$data), group.diff = 1.5, cormat = cov(SpikePos$data[1:10, ]))
grp1.HC <- get.biom(X = SpikePos$data[1:20,], Y = SpikePos$class[1:20], fmethod = c("studentt", "pls", "vip"), type = "HC")
summary(grp1.HC)
selection(grp1.HC)
grp1.HCsel <- HCthresh(coef(grp1.HC)$studentt[[1]], plot = TRUE)
real.markers <- which(SpikePos$annotation$found.in.standards > 0)
grp1.troc <- ROC(1/coef(grp1.HC)$studentt[[1]], real.markers)
grp1.HC.troc <- roc.value(selection(grp1.HC)$studentt[[1]], real.markers, totalN = ncol(SpikePos$data))
plot(grp1.troc, type = "l", main = "Student t")
points(grp1.HC.troc, col = "red", pch = 19, cex = 1.5)
```

```{r self-organizing-maps, echo = FALSE}
#https://cran.r-project.org/web/packages/kohonen/kohonen.pdf
#install.packages("kohonen")
library(kohonen)
data(degelder)
mydata <- list(patterns = degelder$patterns,
CellVol = log(degelder$properties[,"cell.vol"]))
## custom distance function
require(Rcpp)
sourceCpp(system.file("Distances", "wcc.cpp", package = "kohonen"))
set.seed(7)
powsom <- supersom(data = mydata, grid = somgrid(6, 4, "hexagonal"),
dist.fcts = c("WCCd", "sumofsquares"),
keep.data = TRUE)
summary(powsom)
```

```{r patchwork, echo = FALSE}
#https://patchwork.data-imaginist.com/
#devtools::install_github("thomasp85/patchwork")
library(ggplot2)
library(patchwork)
data<-as.data.frame(data)
p1 <- ggplot(data) + geom_point(aes(data), hsp235)
p2 <- ggplot(data$hsp236)# + geom_boxplot(aes(data))
p1 + p2
```


```{r UpSetR, echo = FALSE}
#https://asntech.shinyapps.io/intervene/
#https://github.com/hms-dbmi/UpSetR
#install.packages("UpSetR")
#devtools::install_github("hms-dbmi/UpSetR")
#A view of UpSetR mimicking the plot published by Lex & Gehlenborg http://www.nature.com/nmeth/journal/v11/n8/abs/nmeth.3033.html
library(UpSetR)
mutations <- read.csv( system.file("extdata", "mutations.csv", package = "UpSetR"), header=T, sep = ",")
upset(mutations, sets = c("PTEN", "TP53", "EGFR", "PIK3R1", "RB1"), sets.bar.color = "#56B4E9", order.by = "freq", empty.intersections = "on")
upset(mutations, attribute.plots=list(gridrows = 100, ncols = 1, plots = list(list(plot=histogram, x="RB1",queries=T),list(plot = scatter_plot, y = "RB1", x = "cnt", queries = T))), sets = c("PTEN", "TP53", "EGFR", "PIK3R1", "RB1"), queries = list(list(query = intersects, params = list("TP53"), active = T), list(query = intersects, params = list("EGFR"))))
```

```{r patchwork, echo = FALSE}
#https://patchwork.data-imaginist.com/
#devtools::install_github("thomasp85/patchwork")
library(ggplot2)
library(patchwork)
data<-as.data.frame(data)
p1 <- ggplot(data) + geom_point(aes(data), hsp235)
p2 <- ggplot(data$hsp236)# + geom_boxplot(aes(data))
p1 + p2
```

```{r perturbationNetwork, echo = FALSE}
#Deciphering the Signaling Network Landscape of Breast Cancer Improves Drug Sensitivity Prediction https://www.biorxiv.org/content/10.1101/2020.01.21.907691v1
#https://github.com/saezlab/CNORode
#https://www.bioconductor.org/packages/release/bioc/vignettes/CNORode/inst/doc/CNORode-vignette.pdf
BiocManager::install("CNORode")
```

```{r diceR, echo = FALSE}
#https://cran.r-project.org/web/packages/diceR/vignettes/overview.html
install.packages("diceR")
library(glmnet)
```


```{r paradox, echo = FALSE}
#https://en.wikipedia.org/wiki/Lindley%27s_paradox
g1=49581
g2=48870
g2/g1
g2-g1
n=g1+g2
prior=0.5
#http://www.r-tutor.com/elementary-statistics/probability-distributions/binomial-distribution
dbinom(g1, size=n, prob=prior)
pbinom(g1, size=n, prob=prior)
#https://www.datascienceblog.net/post/basic-statistics/distributions/
dnorm(g1, mean=prior*n, sd=sqrt(prior*(1-prior)*n))
pnorm(g1, prior*n, sqrt(prior*(1-prior)*n))
dnorm(g1, prior*n, prior*(1-prior)*n)
pnorm(g2, prior*n, prior*(1-prior)*n)
dnorm(49581, mean=(0.5)*(49581+48870), sd=sqrt((1-0.5)*(0.5)*(49581+48870)))
dbinom(49581, size=49581+48870, prob=0.5)
```

```{r FDR, echo = FALSE}
#supplementary of the article https://www.tandfonline.com/doi/full/10.1080/00031305.2018.1529622 at  https://www.tandfonline.com/doi/suppl/10.1080/00031305.2018.1529622/suppl_file/utas_a_1529622_sm1508.zip
#shiny app here http://fpr-calc.ucl.ac.uk/
calc.FPR =  function(nsamp,pval,delta,sigma,prior) {
  df=2*(nsamp-1)
  tcrit=qt((1-pval/2),df,ncp=0)
  x0=tcrit
  y0=dt(x0,df,0)
  ncp1=delta/sdiff     #non-centrality paramater
  x1=x0  #tcrit
  y1=dt(x1,df,ncp=ncp1)
  p0=2*y0
  p1=y1
  LR=y1/(2*y0)
  FPR=((1-prior)*p0)/(((1-prior)*p0) + prior*p1)
  output=c(FPR,LR)
  return(output)
}
```


```{r perseusR, echo = FALSE}
#http://www.coxdocs.org/doku.php?id=perseus:user:activities:matrixprocessing:wgcna
#install.packages("BiocManager")
#install.packages("Rcpp")
#BiocManager::install("DESeq2")
#BiocManager::install("limma")
#BiocManager::install("edgeR")
#BiocManager::install(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
#install.packages(c("WGCNA"))#, "devtools"))
#devtools::install_github('jdrudolph/PerseusR')
#library(WGCNA)
devtools::install_github("IRkernel/IRkernel")
IRkernel::installspec()
library(PerseusR)
tmp <- tempfile(fileext = ".txt")
write('Column_1\tColumn_2\tColumn_3
#!{Description}\t\t
#!{Type}E\tE\tE
-1.860574\t-0.3910594\t0.2870352
NaN\t-0.4742951\t0.849998', file=tmp)
read.perseus(tmp)
#https://github.com/cox-labs/PerseusR/blob/master/vignettes/Using-Perseus-data-in-R.Rmd
my_list <- list(main = data.frame(A = 1:5, B = 6:10),
                annotRows = data.frame(is_control = c(TRUE, FALSE)),
                annotCols = data.frame(Names = letters[1:5]),
                descr = c('something',
                          'something else',
                          'yet another thing'))
tmp.file <- tempfile(fileext="txt")
write.perseus(my_list, con = tmp.file)
cat(readLines(tmp.file), sep = '\n')
# https://groups.google.com/d/msgid/perseus-list/eeb79ffc-a10d-48dc-ab1a-09d1ca279df7%40googlegroups.com?utm_medium=email&utm_source=footer
# some of protein intensities
hsp235 = c(31.87997, 31.47218, 31.54176, 31.04798, 31.19131, 31.3741, 31.07182, 31.07157, 31.07896, NA,NA,NA,NA,NA,NA, 27.1649, 26.83219,NA)
hsp236 = c(26.00793,27.41844, 28.28087,24.80331,27.18064, 27.44735, 27.95082, 29.01148, 28.52835, NA,NA,NA,NA,NA,NA, 27.0477, NA,NA)
x050 =c(NA,NA,NA,27.80058,28.14258,27.71777,27.75041,27.82857,27.56979, NA,NA,NA,28.10415,28.27142,28.28198,27.95155,28.07148,28.07969)
# overview
data<-cbind(hsp235, hsp236, x050)
# grouping
grp = rep(c("Treat", "Ctrl"), each = 9)
# display, could be nicer
library(ggplot2)
qplot(grp, hsp236)
# function to impute new values
rank.replace = function(x, const) {
  x.na = is.na(x)
  if (missing(const)) const = min(x, na.rm = TRUE)
  x[x.na] = const - runif(sum(x.na))
  return(x)
}
# Start testing

# hsp236 is around the detection floor,
# so not different using a parametric test
# set 23 as the ceiling of imputation
hsp236.rank = rank.replace(hsp236, 23)
wilcox.test(hsp236.rank ~ grp)
# set the minimal value as the ceiling
hsp236.rank = rank.replace(hsp236)
wilcox.test(hsp236.rank ~ grp)
# p-values are nearly the same, except randomness
# due to the stochastic process

# the imputation works well on hsp235 also
hsp235.rank = rank.replace(hsp235)
wilcox.test(hsp235.rank ~ grp)

# the imputation works well on x050 also
# which is not different between as far I can say
x050.rank = rank.replace(x050)
wilcox.test(x050.rank ~ grp)
# p-value will be instable, but not "significant" (I hate that term)

```

```{r TS, echo = FALSE}
#https://robjhyndman.com/hyndsight/tscv/
#install.packages('forecast', dependencies = TRUE)
library(forecast)
modelcv <- CVar(lynx, k=5, lambda=0.15)
print(modelcv)
```

```{r markerGene, echo = FALSE}
#https://github.com/PavlidisLab/markerGeneProfile
devtools::install_github('oganm/markerGeneProfile')
```

```{r topoFS, echo = FALSE}
#https://github.com/CamaraLab/RayleighSelection/blob/master/examples/plot_nerve_example.md
devtools::install_github("CamaraLab/RayleighSelection")
```

```{r fUps, echo = FALSE}
#https://bioinformatics.erc.monash.edu/apps/LFQ-Analyst/ Perseus-type, bpca, knn,  QRILC,  MLE, MinDet,  MinProb, min, zero
x<-as.matrix(c(NA, NA, NA))
apply(x,2, mean, na.rm = TRUE)
apply(x,2, median, na.rm = TRUE)
is.na(apply(x,2, mean, na.rm = TRUE))
is.nan(apply(x,2, median, na.rm = TRUE))
#https://twitter.com/tangming2005/status/1198782278782070784
x<- list(a=c(1,2,3), b= c(3,4,5), abc = c(6,7,8))
x$abc
(1/3)*3==1#TRUE
#https://0.30000000000000004.com/
(0.1+0.2)==0.3#FALSE
```

```{r TS, echo = FALSE}
#BiocManager::install("DESeq2")
library("DESeq2")
library("dplyr")
BiocManager::install("airway")
data("airway", package = "airway")
dds <- DESeqDataSet(se = airway, design = ~ cell + dex) %>% DESeq
deRes <- as.data.frame(results(dds))
#BiocManager::install("IHW")
library(IHW)
ihwRes <- ihw(pvalue ~ baseMean,  data = deRes, alpha = 0.1)
```


```{r data, echo = FALSE}
inpD <-"C:/Users/animeshs/Desktop/combined/txt/"
#inpF<-paste0(inpD,"proteinGroupsLog2LFQctrl.xlsx WSRTun.txt")
inpF<-paste0(inpD,"proteinGroups.txt")
data <- read.delim(inpF,sep="\t",header = T)
#data$T..Uniprot<-(sapply(strsplit(as.character(data$Protein.IDs),"[-;]"), "[", 1))
summary(data)
```

```{r QR, echo = FALSE}
#https://statisticaloddsandends.wordpress.com/2019/02/01/quantile-regression-in-r/
#install.packages('quantreg', dependencies = TRUE)
library(quantreg)
dataLog2<-log2(data[,grep("LFQ.",colnames(data))]+1)
rqfit <- rq(LFQ.intensity.ung_ub ~ LFQ.intensity.ung_phos_ub, data = dataLog2)
summary(rqfit)
plot(LFQ.intensity.ung_ub  ~ LFQ.intensity.ung_phos_ub, data = dataLog2, pch = 16, main = "LFQ.intensity.ung_ub  ~ LFQ.intensity.ung_phos_ub")
abline(lm(LFQ.intensity.ung_ub  ~ LFQ.intensity.ung_phos_ub, data = dataLog2), col = "red", lty = 2)
abline(rq(LFQ.intensity.ung_ub  ~ LFQ.intensity.ung_phos_ub, data = data), col = "blue", lty = 2)
legend("topright", legend = c("lm", "rq"), col = c("red", "blue"), lty = 2)
```

```{r bio, echo = FALSE}
#https://www.sciencedirect.com/science/article/pii/S1525157819303976
#BiocManager::install("GenomicRanges")
library("GenomicRanges")
GrANGE<-GRanges(seqnames=Rle(c("chr11")))
#BiocManager::install("SummarizedExperiment")
library("SummarizedExperiment")
#BiocManager::install("Biostrings")
library("Biostrings")
#BiocManager::install("GSEBase")
library("GSEBase")
#BiocManager::install("GenomicAlignments")
library("GenomicAlignments")
```

```{r bochum-advR}
sessionInfo()$basePkgs
#setRepositories(graphics=TRUE)
#getCRANmirrors()
#chooseCRANmirror(0)
#chooseBioCmirror()
rownames(installed.packages())#first connect to BioC to see the limma!
#pkgAvail<-available.packages()
#pkgAvail[grep("mma",pkgAvail[,"Package"]),1:2]
#pkgAvailNew<-new.packages()
#pkgAvailNew[grep("mma",pkgAvailNew)]
#old.packages()#does it have a newer version and
#update.packages(ask=FALSE)#ask="graphics" or
#remove.packages(pkgs="limma")
#install.packages(c("gplots", "openxlsx", "pROC"))
#install.packages("BiocManager")
#BiocManager::install(c("limma", "affy"))
#?"function"
dblN<-function(x) 2*x
dblN(3)
facN<-function(x){
  if(x<2){return(x)}
  else{return(x*facN(x-1))}
}
facN(3)
#BiocManager::install("STRINGdb")
library("STRINGdb")
string_db <- STRINGdb$new(species=9606)#, version="10",score_threshold=0, input_directory="" )
library('openxlsx')
abundances<-openxlsx::read.xlsx("/home/animeshs/Desktop/data/HCC_19vs19_raw_abundances.xlsx")
nDE=10
stringABD<-function(df,nDE,pathF){
  abundancesDE<-df[df$`Anova.(p)`<0.05,]#$Accession
  abundancesDE<-abundancesDE[1:nDE,]
  dim(abundancesDE)
  return(abundancesDE)
}
chkStr<-stringABD(abundances,5,"")
chkStrSdb<-string_db$map(chkStr,"Accession",removeUnmappedRows = TRUE )
chkStrPlot<-string_db$plot_network(chkStr$STRING_id[1:10])
string_db$map(abundancesDE,removeUnmappedRows = TRUE )
string_db$plot_network(abundancesDE)
#topGO
#session2
cor(data,use=pairwise.complete)
#missingValues
#normalizeBetweenArrays
#median doesn't take care of variance, quantile does (check boxplot)
#LOESS (cyclic for all pairs, 3 - 4 times circle, permutation hell!, try average of all before)
#group-wise normalization can lead to assymetry in volcano-plot, LTS normalization
(table(is.na(abundances[,10:ncol(abundances)])))
abundancesNA<-abundances[,10:ncol(abundances)]
abundancesNA[abundancesNA==0]=NA
table(is.na(abundancesNA))
(table(is.na(abundancesNA)))
summary(abundancesNA)
summary(t(abundancesNA))#['NA\'s']
sum(complete.cases(as.matrix(abundancesNA)))
barplot(as.matrix(abundances[,10:ncol(abundances)]))
barplot(as.matrix(abundancesNA))
barplot(colSums)

library('limma',logical.return=TRUE,verbose=TRUE)
boxplot(abundancesNA)
abundancesNAlog2<-log2(abundancesNA)
boxplot(abundancesNAlog2)
abundancesNAlog2normalize<-normalizeBetweenArrays(abundancesNAlog2)
abundancesNAlog2normalize<-normalizeBetweenArrays(abundancesNAlog2,method="scale")
boxplot(abundancesNAlog2normalize)
#MA_plot.r
library('affy')
MAPlots <- function(X, log = FALSE,  labels = colnames(X), file, ...) {
  require(affy)

  MAPlot_single <- function(x1, x2, log = FALSE, ...) {
    if(log) {
      x1 <- log2(x1)
      x2 <- log2(x2)
    }
    M <- na.omit(x1 - x2)
    A <- na.omit((x1 + x2)/2)
    ma.plot(A = A, M = M, pch = 16, cex = 0.7, show.statistics = FALSE, ...)
  }

  pdf(file)
  for(i in 1:(ncol(X)-1)) {
    for (j in (i + 1):ncol(X)) {
        main = paste(labels[i], labels[j])
      MAPlot_single(X[,i], X[, j], log = log, main = main, ...)
    }
  }
  dev.off()
}
MAPlots(abundancesNAlog2normalize,log=FALSE,file="MAPnorm.pdf")
#help("limma")
#browseVignettes("limma")
#session3
#clustering, agglomorative not divisive
#distance, taxi-cab=>manhattan, 1- cor(X)=>p
#linkage, single->min(d) bw all pairs,
#heatmap with scale and calculated dist
abundances<-read.table("/home/animeshs/Downloads/proteinGroups.txt",sep="\t",row.names=1,header=T)
df<-abundances[,grep("LFQ.",colnames(abundances))]
cn<-strsplit(colnames(df), "_")
colnames(df)<-paste0(sapply(cn, "[", 3),sapply(cn, "[", 4))
log2df<-log2(df)
log2df[log2df==-Inf]<-0
summary(as.matrix(log2df))
library('limma',logical.return=TRUE,verbose=TRUE)
log2dfNormalize<-normalizeBetweenArrays(log2df,method="quantile") #na.omit()
boxplot(log2dfNormalize)
corDist<-as.dist((1-cor(log2dfNormalize,use="pairwise.complete.obs"))/2)
heatmap(log2dfNormalize)
library(gplots)
heatmap.2((log2dfNormalize),corDist)
heatmap(log2dfNormalize)
#basically image(t(df))
#PCA
#prcomp(df,scale=TRUE) #support N>>p unlike princomp
#biplot()#roation for protein, loading for sample
log2dfNormalize<-normalizeBetweenArrays(log2df,method="scale")
log2dfNormalize<-log2dfNormalize[-rowSums(log2dfNormalize)!=0,]
pca<-prcomp(t(log2dfNormalize),scale=TRUE)
biplot(pca)
sumrPCA<-summary(pca)
plot(pca$x[,1],pca$x[,2])
legend(pch=16,"topright",legend=colnames(log2dfNormalize))
#ROC
library('pROC')
colnames(log2dfNormalize)
valROC<-roc(control=log2dfNormalize[2,],cases=log2dfNormalize[1,])
plot(valROC)
#youden=>sp+se is max
#ROCR
#supports ML
```


```{r design}
#https://yihui.name/tinytex/
install.packages('tinytex')
tinytex::install_tinytex()
tinytex:::is_tinytex()
tinytex:::install_yihui_pkgs()
writeLines(c(
   '\\documentclass{article}',
   '\\begin{document}', '$$\\int_{a}^{b} x^2 dx$$', '\\end{document}'
 ), 'scratch.tex')
tinytex::pdflatex('scratch.tex')
```

```{r design}
#https://llrs.github.io/experDesign/
#devtools::install_github("llrs/experDesign")
library("experDesign")
metadata <- expand.grid(height = seq(60, 80, 5),
                        weight = seq(100, 300, 50),
                        sex = c("Male","Female"))
head(metadata, 15)
d <- design(metadata, 24)
batch_names(d)
r <- replicates(metadata, 24, 5)
r
```

```{r clust-trans}
#setwd("F:\\mgf\\")
#data<-scan("F://mgf//171010_Ip_Hela_ugi.raw.intensity0.charge0-comet-human.txt")
data<-read.table("F://mgf//171010_Ip_Hela_ugi.raw.intensity0.charge0-comet-human.txt",header=T,sep="\t",skip=1,row.names=NULL)
summary(data)
mzd=data$charge-data$exp_neutral_mass
hist(mzd)
aft<-fft(mzd)
aft<-fft(fft(aft), inverse = TRUE)/length(aft)
plot(aft)
absaft<-abs(aft)
plot(absaft)
```


```{r clust-NA}
#https://cran.r-project.org/web/packages/biclustermd/index.html
#devtools::install_github("jreisner/biclustermd")
library(biclustermd)
plot(dataSelSTAT)
bc<-biclustermd(dataSelSTAT)
data_selr0asNA<-data_selr
data_selr0asNA[data_selr0asNA==0]<-NA
summary(data_selr0asNA)
bc<-biclustermd(data_selr0asNA)
autoplot(bc)
rep_dat_bc <- rep_biclustermd(data_selr0asNA, nrep = 50, col_clusters = 4, row_clusters = 4)
plot(rep_dat_bc$rep_sse)
autoplot(rep_dat_bc$best_bc)
```

```{r pepLFQ}
#https://github.com/statOmics/MSqRobSumPaper/blob/master/analyses/DEP/analysis.r
devtools::install_github("statOmics/MSqRob@MSqRob0.7.6")
#https://github.com/statOmics/MSqRob/blob/master/vignettes/MSqRob.Rmd
library(MSqRob)
library(Biobase)
library(MSnbase)
library(limma)
file_peptides_txt <- "L:/promec/Qexactive/LARS/2019/oktober/Kristine Sonja/combined/txt/peptides.txt"
peptidesFranc <- import2MSnSet(file_peptides_txt, filetype = "MaxQuant", remove_pattern = TRUE)
head(fData(peptidesFranc))
pData(peptidesFranc)
runs <- sampleNames(peptidesFranc)
runs
colnames(exprs(peptidesFranc))
genotype <- factor(c(rep("WT",9),rep("WT2",9),rep("KO",9)), levels=c("WT","WT2","KO"))
genotype
n <- nchar(runs)
biorep <- as.factor(paste0("b_",rep(1:9,each=3)))
biorep
exp_annotation <- data.frame(run=runs, genotype=genotype, biorep=biorep)
exp_annotation
peptidesFranc2 <- preprocess_MaxQuant(peptidesFranc, accession="Proteins", exp_annotation=exp_annotation, logtransform=TRUE, base=2, normalisation="quantiles", smallestUniqueGroups=TRUE, useful_properties=c("GI number","Protein.names","Sequence"), filter=c("Contaminant","Reverse"), remove_only_site=TRUE, file_proteinGroups=file_proteinGroups,  filter_symbol="+", minIdentified=2)
```

```{r voom}
#install.packages("BiocManager")
#BiocManager::install("limma")
#BiocManager::install("edgeR")
library(limma)
library(edgeR)
countTable = read.table("l:/promec/Animesh/Alessandro/count-table.tsv",header=TRUE,row.names=1)
condition = factor( c("WT","WT","AAG","AAG"))
des = model.matrix(~-1+condition)
colnames(des) = levels(condition)
cmat <- makeContrasts(WT - AAG, levels=des)
dge <- DGEList(counts=countTable)
dge <- calcNormFactors(dge)
v <- voom(dge,design=des)
fit <- lmFit(v,design=des)
fit <- contrasts.fit(fit, cmat)
fit <- eBayes(fit)
a <- decideTests(fit,adjust.method="fdr", p.value=0.05, lfc=0)
sma = summary(a)
dmm <- dim(countTable)
res <- topTable(fit,n=dmm[1],coef=1)
plot(res$logFC,-log10(res$adj.P.Val))
write.csv(res,file="L:/promec/Animesh/Alessandro/Voom_diffexp.csv")
```

```{r density-plot}
#https://github.com/LKremer/ggpointdensity
#devtools::install_github("LKremer/ggpointdensity")
library(ggplot2)
library(dplyr)
library(viridis)
library(ggpointdensity)
dat <- bind_rows(
  tibble(x = rnorm(7000, sd = 1),
         y = rnorm(7000, sd = 10),
         group = "foo"),
  tibble(x = rnorm(3000, mean = 1, sd = .5),
         y = rnorm(3000, mean = 7, sd = 5),
         group = "bar"))
ggplot(data = dat, mapping = aes(x = x, y = y)) +
  geom_pointdensity() +
  scale_color_viridis()
```

```{r CrossICC}
#https://github.com/bioinformatist/CrossICC#via-github-latest
devtools::install_github("bioinformatist/CrossICC")
library(CrossICC)
CrossICC.obj <- CrossICC(demo.platforms, skip.mfs = TRUE, max.iter = 100,
                         cross = "cluster", fdr.cutoff = 0.1,
                         ebayes.cutoff = 0.1, filter.cutoff = 0.1)
```

```{r MBQN-NA}
#https://github.com/arianeschad/MBQN/wiki
devtools::install_github("arianeschad/MBQN")
library("MBQN")
# mtx <- matrix(c(5,2,3,NA,4,1,4,2,3,4,6,NA),ncol=3)
set.seed(1234)
inpF<-"L:/promec/Qexactive/LARS/2019/spetember/Camilla Wolo/combined/txt/proteinGroups.txt"
data<-read.table(inpF,header=T,sep="\t",row.names = 1)
nri_max <- as.numeric(names(which.max(res$nri)))
df <- lapply(seq_len(ncol(featureAnnotations)),function(j) featureAnnotations[[j]][[nri_max]])
names(df)<- names(featureAnnotations)

# truncate long name strings
df$proteinName <-  paste(strtrim(df$proteinName,80),"...")
df$proteinDescription <- paste(strtrim(df$proteinDescription,80),"...")

colnames(mtx) <- gsub("LFQ intensity","",colnames(mtx))
mbqn.mtx <- mbqn(mtx,FUN = median)
qn.mtx <- mbqn(mtx,FUN = NULL)

# Boxplot of QN intensity features, highlight RI/NRI Features
if(length(ylim)==0) {
  ylim <- c(floor(min(range(mbqn.mtx, na.rm = TRUE))),ceiling(max(range(mbqn.mtx, na.rm = TRUE))))
  ylim.qn <- c(floor(min(range(qn.mtx, na.rm = TRUE))),ceiling(max(range(mbqn.mtx, na.rm = TRUE))))
}
#colnames(qn.mtx) <- colnames(mbqn.mtx) <- ix

plot.new()
mbqnBoxplot(mtx = qn.mtx,main = paste("QN"),
            ylab = "LFQ intensity",
            ylim = ylim, xlab = "",las =2,
            irow = c(as.numeric(names(res$nri))), y.intersp = 0.5)
plot.new()

# select a qn feature:
is.full.feature <- which((apply(is.na(mtx),1,sum))==0)[1]
df <- data.frame(QN.feature = qn.mtx[is.full.feature,])
names(df) <- paste("QN feature", is.full.feature)
mbqnBoxplot(mtx = mbqn.mtx, main = "MBQN with QN-feature",
            irow = c(as.numeric(names(res$nri)),is.full.feature),
            xlab= "", las =2,
            ylab = "LFQ intensity",
            vals = df,
            ylim = ylim, y.intersp = 0.5)

# QN of data and balance only NRI/RI features
plot.new()
df <- data.frame(qn.mtx[as.numeric(names(res$nri)),])
if(ncol(df)==1) df <- t(df)
rownames(df) <- paste("QN feature",names(res$nri))
df2 <- data.frame(mtx[as.numeric(names(res$nri)),])
if(ncol(df2)==1) df2 <- t(df2)
rownames(df2) <- paste("unnormal. feature",names(res$nri))
colnames(df) <- colnames(df2)
df <- rbind(df,df2)
df <- as.data.frame(t(df))

mtx.nri <- mbqnNRI(mtx,FUN = median,low_thr = 0.5, verbose = FALSE)
mbqnBoxplot(mtx = mtx.nri,
            irow = as.numeric(names(res$nri)),
            ylim = ylim.qn, xlab= "", las=2,
            ylab = "LFQ intensity",
            vals = df,lwd = 1.,
            main = "QN with RI/NRI balanced",
            cex.axis = 1, cex.lab = .9, cex = .9, y.intersp = 0.5)
# dev.off()
```

```{r lionessR-NA}
#https://cran.r-project.org/web/packages/biclustermd/index.html
devtools::install_github("mararie/lionessR")
library(lionessR)
plot(dataSelSTAT)
bc<-biclustermd(dataSelSTAT)
data_selr0asNA<-data_selr
data_selr0asNA[data_selr0asNA==0]<-NA
summary(data_selr0asNA)
bc<-biclustermd(data_selr0asNA)
autoplot(bc)
rep_dat_bc <- rep_biclustermd(data_selr0asNA, nrep = 50, col_clusters = 4, row_clusters = 4)
plot(rep_dat_bc$rep_sse)
autoplot(rep_dat_bc$best_bc)
```

```{r KnowSeq}
#https://cran.r-project.org/web/packages/biclustermd/index.html
BiocManager::install("KnowSeq")
```

```{r clust-NA}
#https://bioconductor.org/packages/release/bioc/vignettes/MetaVolcanoR/inst/doc/MetaVolcano.html
BiocManager::install("MetaVolcanoR")
library(MetaVolcanoR)
data(diffexplist)
class(diffexplist)
meta_degs_rem <- rem_mv(diffexp=diffexplist,
            pcriteria="pvalue",
            foldchangecol='Log2FC',
            genenamecol='Symbol',
            geneidcol=NULL,
            collaps=FALSE,
            llcol='CI.L',
            rlcol='CI.R',
            vcol=NULL,
            cvar=TRUE,
            metathr=0.01,
            jobname="MetaVolcano",
            outputfolder=".",
            draw='HTML',
            ncores=1)

head(meta_degs_rem@metaresult, 3)
meta_degs_rem@MetaVolcano
draw_forest(remres=meta_degs_rem,
        gene="MMP9",
        genecol="Symbol",
        foldchangecol="Log2FC",
        llcol="CI.L",
        rlcol="CI.R",
        jobname="MetaVolcano",
        outputfolder=".",
        draw="HTML")
meta_degs_vote <- votecount_mv(diffexp=diffexplist,
                   pcriteria='pvalue',
                   foldchangecol='Log2FC',
                   genenamecol='Symbol',
                   geneidcol=NULL,
                   pvalue=0.05,
                   foldchange=0,
                   metathr=0.01,
                   collaps=FALSE,
                   jobname="MetaVolcano",
                   outputfolder=".",
                   draw='HTML')

head(meta_degs_vote@metaresult, 3)
##   Symbol deg_1 deg_2 deg_3 deg_4 deg_5 ndeg ddeg idx        degvcount
## 1  ABCC3     1     1     1     1     1    5    5  25   2.Up-regulated
## 2  ABHD5    -1    -1    -1    -1    -1    5   -5 -25 0.Down-regulated
## 3  ACACB    -1    -1    -1    -1    -1    5   -5 -25 0.Down-regulated
meta_degs_vote@degfreq
meta_degs_vote@MetaVolcano
meta_degs_comb <- combining_mv(diffexp=diffexplist,
                   pcriteria='pvalue',
                   foldchangecol='Log2FC',
                   genenamecol='Symbol',
                   geneidcol=NULL,
                   metafc='Mean',
                   metathr=0.01,
                   collaps=TRUE,
                   jobname="MetaVolcano",
                   outputfolder=".",
                   draw='HTML')

head(meta_degs_comb@metaresult, 3)
##   Symbol        metap     metafc       idx
## 1   MMP9 9.002947e-15  1.9693517  27.66076
## 2 ACVR1C 3.548802e-20 -1.2544105 -24.39818
## 3    ANG 5.674270e-26 -0.9364936 -23.64280
meta_degs_comb@MetaVolcano
```

```{r permutation-filtering}
#https://bioconductor.org/packages/release/bioc/vignettes/PERFect/inst/doc/MethodIllustration.html
devtools::install_github("cxquy91/PERFect")
library(PERFect)
library(ggplot2)
library(knitr)
library(kableExtra)
set.seed(12341)
```

```{r permutation-filtering}
#https://bioconductor.org/packages/release/bioc/vignettes/MSstatsSampleSize/inst/doc/MSstatsSampleSize.html
BiocManager::install("MSstatsSampleSize")
# OV_SRM_train <- read.csv(file = "OV_SRM_train.csv")
# # assign the column 'Protein' as row names
# rownames(OV_SRM_train) <- OV_SRM_train$Protein
# # remove the column 'Protein
# OV_SRM_train <- OV_SRM_train[, colnames(OV_SRM_train)!="Protein"]
head(OV_SRM_train)
variance_estimation <- estimateVar(data = OV_SRM_train,
                                   annotation = OV_SRM_train_annotation)
#>  Preparing variance analysis...
#>  Variance analysis completed.

# the mean protein abundance in each condition
head(variance_estimation$mu)
meanSDplot(variance_estimation)
simulated_datasets <- simulateDataset(data = OV_SRM_train,
                                      annotation = OV_SRM_train_annotation,
                                      num_simulations = 10, # simulate 10 times
                                      expected_FC = "data",
                                      list_diff_proteins =  NULL,
                                      select_simulated_proteins = "proportion",
                                      protein_proportion = 1.0,
                                      protein_number = 1000,
                                      samples_per_group = 50, # 50 samples per condition
                                      simulate_validation = FALSE,
                                      valid_samples_per_group = 50)
simulated_datasets$num_proteins
#> [1] 67

# a vector with the number of simulated samples in each condition
simulated_datasets$num_samples
#>        control ovarian cancer
#>             50             50

# the list of simulated protein abundance matrices
# Each element of the list represents one simulation
head(simulated_datasets$simulation_train_Xs[[1]]) # first simulation
unique(OV_SRM_train_annotation$Condition)
#> [1] control        ovarian cancer
#> Levels: benign ovarian cancer control
expected_FC <- c(1, 1.5)
names(expected_FC) <- c("control", "ovarian cancer")
set.seed(1212)
# Here I randomly select some proteins as differential to show how the function works
# The user should prepare this list of differential proteins by themselves
diff_proteins <- sample(rownames(OV_SRM_train), 20)
simualted_datasets_predefined_FC <- simulateDataset(data = OV_SRM_train,
                                      annotation = OV_SRM_train_annotation,
                                      num_simulations = 10, # simulate 10 times
                                      expected_FC = expected_FC,
                                      list_diff_proteins =  diff_proteins,
                                      select_simulated_proteins = "proportion",
                                      protein_proportion = 1.0,
                                      protein_number = 1000,
                                      samples_per_group = 50, # 50 samples per condition
                                      simulate_validation = FALSE,
                                      valid_samples_per_group = 50)
#
#### sample size classification ####
# simulate different sample sizes
# 1) 10 biological replicats per group
# 1) 25 biological replicats per group
# 2) 50 biological replicats per group
# 3) 100 biological replicats per group
# 4) 200 biological replicats per group
list_samples_per_group <- c(10, 25, 50, 100, 200)

# save the simulation results under each sample size
multiple_sample_sizes <- list()

for(i in seq_along(list_samples_per_group)){
    # run simulation for each sample size
    simulated_datasets <- simulateDataset(data = OV_SRM_train,
                                      annotation = OV_SRM_train_annotation,
                                      num_simulations = 10, # simulate 10 times
                                      expected_FC = "data",
                                      list_diff_proteins =  NULL,
                                      select_simulated_proteins = "proportion",
                                      protein_proportion = 1.0,
                                      protein_number = 1000,
                                      samples_per_group = list_samples_per_group[i],
                                      simulate_valid = FALSE,
                                      valid_samples_per_group = 50)

    # run classification performance estimation for each sample size
    res <- designSampleSizeClassification(simulations = simualted_datasets,
                                          parallel = TRUE)

    # save results
    multiple_sample_sizes[[i]] <- res
}

## make the plots
designSampleSizeClassificationPlots(multiple_sample_sizes,
                                    list_samples_per_group,
                                    ylimUp_predictive_accuracy = 0.8,
                                    ylimDown_predictive_accuracy = 0.6)
designSampleSizePCAplot(simulated_datasets)

```

```{r MSstats}
devtools::install_github("MeenaChoi/MSstats")
#https://bioconductor.org/packages/release/bioc/vignettes/MSstatsSampleSize/inst/doc/MSstatsSampleSize.html
BiocManager::install("MSstatsSampleSize")
```

```{r MMUPHin}
BiocManager::install("MMUPHin")
fit_adjust_batch <- adjust_batch(feature_abd = CRC_abd,
                                 batch = "studyID",
                                 covariates = "study_condition",
                                 data = CRC_meta,
                                 control = list(verbose = FALSE))
CRC_abd_adj <- fit_adjust_batch$feature_abd_adj
fit_lm_meta <- lm_meta(feature_abd = CRC_abd,
                       batch = "studyID",
                       exposure = "study_condition",
                       covariates = c("gender", "age", "BMI"),
                       data = CRC_meta,
```

```{r proDA-NA}
#https://github.com/const-ae/proDA
devtools::install_github("const-ae/proDA")
library(proDA)
intensity_colnames <- grep("^LFQ\\.intensity\\.", colnames(data), value=TRUE)
head(intensity_colnames)
abundance_matrix <- as.matrix(data[, intensity_colnames])
colnames(abundance_matrix) <- sub("^LFQ\\.intensity\\.", "", intensity_colnames)
rownames(abundance_matrix) <- data$Protein.IDs
abundance_matrix[46:48, 1:6]
abundance_matrix[abundance_matrix == 0] <- NA
abundance_matrix <- log2(abundance_matrix)
abundance_matrix[46:48, 1:6]
barplot(colSums(is.na(abundance_matrix)),
        ylab = "# missing values",
        xlab = "Sample 1 to 36")
boxplot(abundance_matrix,
        ylab = "Intensity Distribution",
        xlab = "Sample 1 to 36")
normalized_abundance_matrix <- median_normalization(abundance_matrix)
da <- dist_approx(normalized_abundance_matrix)
sel <- c(1:3,  # CG1407
         4:6,  # CG59163
         7:9)# CG6618

plot_mat <- as.matrix(da$mean)[sel, sel]
# Remove diagonal elements, so that the colorscale is not distorted
plot_mat[diag(9) == 1] <- NA
# 95% conf interval is approx `sd * 1.96`
uncertainty <- matrix(paste0(" � ",round(as.matrix(da$sd * 1.96)[sel, sel], 1)), nrow=9)
pheatmap::pheatmap(plot_mat,
                   cluster_rows = FALSE, cluster_cols = FALSE,
                   display_numbers= uncertainty,
                   number_color = "black")
sample_info_df <- data.frame(name = colnames(normalized_abundance_matrix),
                             stringsAsFactors = FALSE)
sample_info_df$condition <- substr(sample_info_df$name, 1, nchar(sample_info_df$name)  - 3)
sample_info_df$replicate <- as.numeric(
  substr(sample_info_df$name, nchar(sample_info_df$name)  - 1, 20)
)
sample_info_df
fit <- proDA(normalized_abundance_matrix, design = ~ condition,
             col_data = sample_info_df, reference_level = "S2R")
fit
fit$feature_parameters
pheatmap::pheatmap(dist_approx(fit[1:20, 1:3], by_sample = FALSE)$mean)
test_res <- test_diff(fit, "conditionCG1407")
test_res
#conditionCG1407 - (conditionCG6017 + conditionCG5880) / 2 would test for the difference between CG1407 and the average of CG6017 and CG5880
```

```{r ReactomeGSA}
#https://github.com/reactome/ReactomeGSA/blob/master/vignettes/using-reactomegsa.Rmd
devtools::install_github("reactome/ReactomeGSA")
library(ReactomeGSA)
devtools::install_github("reactome/ReactomeGSA.data")
library(ReactomeGSA.data)
data("griss_melanoma_proteomics")
class(griss_melanoma_proteomics)
head(griss_melanoma_proteomics$samples)
# Create a new request object using 'Camera' for the gene set analysis
my_request <-ReactomeAnalysisRequest(method = "Camera")
my_request
# set the maximum number of allowed missing values to 50%
my_request <- set_parameters(request = my_request, max_missing_values = 0.5)
my_request
my_request <- add_dataset(request = my_request,
                          expression_values = griss_melanoma_proteomics,
                          name = "Proteomics",
                          type = "proteomics_int",
                          comparison_factor = "condition",
                          comparison_group_1 = "MOCK",
                          comparison_group_2 = "MCM",
                          additional_factors = c("cell.type", "patient.id"))
my_request
result <- perform_reactome_analysis(request = my_request)
proteomics_fc <- get_result(result, type = "fold_changes", name = "Proteomics")
head(proteomics_fc)
combined_pathways <- pathways(result)
head(combined_pathways)
```

```{r scPCA}
#https://github.com/PhilBoileau/scPCA/blob/master/vignettes/scpca_intro.Rmd
remotes::install_github("PhilBoileau/scPCA")
library(scPCA)
set.seed(1742)
data(toy_df)
pca_sim <- prcomp(toy_df[, 1:30])
library(tibble)
df <- as_tibble(list("PC1" = pca_sim$x[, 1],
                     "PC2" = pca_sim$x[, 2],
                     "label" = as.character(toy_df[, 31])))
library(ggplot2)
p_pca <- ggplot(df, aes(x = PC1, y = PC2, colour = label)) +
  ggtitle("PCA on Simulated Data") +
  geom_point(alpha = 0.5) +
  theme_minimal()
p_pca

cpca_sim <- scPCA(target = toy_df[, 1:30],
                  background = background_df,
                  penalties = 0,
                  n_centers = 4)
library(dplyr)
cpca_df <- cpca_sim$x %>%
  as_tibble() %>%
  mutate(label = toy_df[, 31] %>% as.character)
colnames(cpca_df) <- c("cPC1", "cPC2", "label")
# plot the results
p_cpca <- ggplot(cpca_df, aes(x = cPC1, y = cPC2, colour = label)) +
  geom_point(alpha = 0.5) +
  ggtitle("cPCA of Simulated Data") +
  theme_minimal()
p_cpca

scpca_sim <- scPCA(target = toy_df[, 1:30],
                   background = background_df,
                   n_centers = 4)
scpca_df <- scpca_sim$x %>%
  as_tibble() %>%
  mutate(label = toy_df[, 31] %>% as.character)
colnames(scpca_df) <- c("scPC1", "scPC2", "label")
p_scpca <- ggplot(scpca_df, aes(x = scPC1, y = scPC2, colour = label)) +
  geom_point(alpha = 0.5) +
  theme_minimal()
p_scpca
load_diff_df <- bind_rows(
  cpca_sim$rotation %>% as.data.frame,
  scpca_sim$rotation %>% as.data.frame) %>%
  mutate(
    sparse = c(rep("0", 30), rep("1", 30)),
    coef = rep(1:30, 2)
  )
colnames(load_diff_df) <- c("comp1", "comp2", "sparse", "coef")
p1 <- load_diff_df %>%
  ggplot(aes(y = comp1, x = coef, fill = sparse)) +
  geom_bar(stat = "identity") +
  xlab("") +
  ylab("") +
  ylim(-1, 1) +
  ggtitle("First Component") +
  scale_fill_discrete(name = "Method", labels = c("cPCA", "scPCA")) +
  theme_minimal()
p2 <- load_diff_df %>%
  ggplot(aes(y = comp2, x = coef, fill = sparse)) +
  geom_bar(stat = "identity") +
  xlab("") +
  ylab("") +
  ylim(-1, 1) +
  ggtitle("Second Component") +
  scale_fill_discrete(name = "Method", labels = c("cPCA", "scPCA")) +
  theme_minimal()
library(ggpubr)
# build full plot via ggpubr
annotate_figure(ggarrange(p1, p2, nrow = 1, ncol = 2,common.legend = TRUE, legend = "right"), top = "Leading Loadings Vectors Comparison",left = "Loading Weights", bottom ="Variable Index")
```

```{r signatureSearch}
#https://bioconductor.org/packages/release/bioc/vignettes/signatureSearch/inst/doc/signatureSearch.html
devtools::install_github("yduan004/signatureSearch")
library(signatureSearch)
#dependency 'gCMAP' is not available
```

```{r waddR}
#https://bioconductor.org/packages/release/bioc/vignettes/waddR/inst/doc/wasserstein_singlecell.html
devtools::install_github("goncalves-lab/waddR")
library("waddR")

set.seed(24)
x <- rnorm(100, mean=0, sd=1)
y <- rnorm(100, mean=2, sd=1)
wasserstein_metric(x, y)
#> [1] 2.028542
wasserstein_metric(x, y)**2
#> [1] 4.114983
squared_wass_approx(x, y)
squared_wass_decomp(x, y)


url.base <- "https://github.com/goncalves-lab/waddR-data/blob/master/data/"
sce.blood.url <- paste0(url.base, "sce_blood.RDa?raw=true")
sce.decidua.url <- paste0(url.base, "sce_decidua.RDa?raw=true")

getCachedPath <- function(url, rname){
    bfc <- BiocFileCache() # fire up cache
    res <- bfcquery(bfc, url, field="fpath", exact=TRUE)
    if (bfccount(res) == 0L)
        cachedFilePath <- bfcadd(bfc, rname=rname, fpath=url)
    else
        cachedFilePath <- bfcpath(bfc, res[["rid"]])
    cachedFilePath
}

load(getCachedPath(sce.blood.url, "sce.blood"))
load(getCachedPath(sce.decidua.url, "sce.decidua"))
wsres <- wasserstein.sc(sce.blood, sce.decidua, "OS")
head(wsres, n=10L)

```

```{r signatureSearch}
#https://bioconductor.org/packages/release/bioc/vignettes/signatureSearch/inst/doc/signatureSearch.html
devtools::install_github("yduan004/signatureSearch")
library(signatureSearch)
#dependency 'gCMAP' is not available
```

```{r controlling false discoveries}
#https://www.biorxiv.org/content/10.1101/458786v1
#https://bioconductor.org/packages/release/data/experiment/vignettes/benchmarkfdrData2019/inst/doc/benchmarkfdrData2019.html#4_exploratory_analysis

devtools::install_github("yduan004/signatureSearch")
library(signatureSearch)
#dependency 'gCMAP' is not available
```



```{r gene-set enrichment with regularized regression}
#https://usethis.r-lib.org/articles/articles/usethis-setup.html
#usethis::edit_r_environ()
#Sys.getenv("GITHUB_PAT")
#https://github.com/TaoDFang/gerr
#library(devtools)
#install_github("TaoDFang/gerr")
library("gerr")
#https://yulab-smu.github.io/clusterProfiler-book/chapter3.html#input-data
#BiocManager::install("clusterProfiler")
#BiocManager::install("GSEABase")
library(clusterProfiler)
#http://data.wikipathways.org/current/gmt/
wp2gene <- read.gmt("L:/promec/Animesh/Lisa/wikipathways-20191010-gmt-Homo_sapiens.gmt")
library(magrittr)
wp2gene <- wp2gene %>% tidyr::separate(ont, c("name","version","wpid","org"), "%")
wpid2gene <- wp2gene %>% dplyr::select(wpid, gene) #TERM2GENE
wpid2name <- wp2gene %>% dplyr::select(wpid, name) #TERM2NAME
gene=c("4312",  "8318"  ,"10874", "55143" ,"55388" ,"991")
ewp <- enricher(gene, TERM2GENE = wpid2gene, TERM2NAME = wpid2name)
head(ewp)
ewp2 <- GSEA(gene, TERM2GENE = wpid2gene, TERM2NAME = wpid2name, verbose=FALSE)
head(ewp2)
install.packages("msigdbr")
library("msigdbr")
msigdbr_show_species()
m_df = msigdbr(species = "Homo sapiens")
head(m_df)
#https://bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html
BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
select(org.Hs.eg.db, Rkeys(org.Hs.egUNIPROT)[1:5], "ENTREZID", "UNIPROT")
select(org.Hs.eg.db, gene, "UNIPROT", "ENTREZID")
```

```{r kernel, echo = FALSE}
#https://bookdown.org/yihui/rmarkdown/
setRepositories(graphics = getOption("menu.graphics"),ind = NULL, addURLs = character())
#install.packages("devtools")
#install.packages('IRkernel')
IRkernel::installspec()
#https://rmarkdown.rstudio.com/authoring_shiny.html
```

```{r pClean}
#https://github.com/AimeeD90/pClean_release
install.packages('digest', repos='http://cran.us.r-project.org')
devtools::install_github("AimeeD90/pClean_release")
#remotes::install_github("AimeeD90/pClean_release")
library(pClean)
mgffile<-system.file("extdata/", "tte.frac1.mgf",package="pClean")
pCleanGear(mgf=mgffile,outdir="pClean",mem=2,cpu=0,mionFilter=TRUE,labelMethod="iTRAQ8plex",repFilter=TRUE,labelFilter=TRUE,low=TRUE,high=TRUE,isoReduction=TRUE,chargeDeconv=TRUE,largerThanPrecursor=TRUE,ionsMerge=TRUE,network=TRUE,debug=FALSE)
mgffile<-system.file("extdata/", "120426_Jurkat_highLC_Frac1.mgf",package="pClean")

pCleanGear(mgf=mgffile,outdir="jurkat/result",mem=2,cpu=0,mionFilter=TRUE,isoReduction=TRUE,chargeDeconv=TRUE,largerThanPrecursor=TRUE,ionsMerge=TRUE,network=TRUE,debug=FALSE)

```

```{r imputeMQstyle}
## https://datascienceplus.com/proteomics-data-analysis-2-3-data-filtering-and-missing-value-imputation/ Data imputation function
impute_data = function(df, width = 0.3, downshift = 1.8) {
  # df = data frame containing filtered
  # Assumes missing data (in df) follows a narrowed and downshifted normal distribution

  LOG2.names = grep("^LOG2", names(df), value = TRUE)
  impute.names = sub("^LOG2", "impute", LOG2.names)

  # Create new columns indicating whether the values are imputed
  df[impute.names] = lapply(LOG2.names, function(x) !is.finite(df[, x]))

  # Imputation
  set.seed(1)
  df[LOG2.names] = lapply(LOG2.names,
                          function(x) {
                            temp = df[[x]]
                            temp[!is.finite(temp)] = NA

                            temp.sd = width * sd(temp[df$KEEP], na.rm = TRUE)   # shrink sd width
                            temp.mean = mean(temp[df$KEEP], na.rm = TRUE) -
                              downshift * sd(temp[df$KEEP], na.rm = TRUE)   # shift mean of imputed values

                            n.missing = sum(is.na(temp))
                            temp[is.na(temp)] = rnorm(n.missing, mean = temp.mean, sd = temp.sd)
                            return(temp)
                          })
  return(df)
}


## Apply imputation
df.FNI = impute_data(df.FN)
```

```{r ggfortify}
install.packages('ggfortify')
library('ggfortify')
autoplot(as.matrix(randu))
```

```{r lme4}
install.packages('gganimate')
library('lme4')
autoplot(as.matrix(randu))
```

```{r multivariance}
install.packages('multivariance')
library('multivariance')
autoplot(as.matrix(randu))
```


```{r ggpubr}
usethis::browse_github_pat()
devtools::install_github("kassambara/ggpubr")
```

```{r compMS}
#https://link.springer.com/chapter/10.1007/978-3-030-05318-5_9
#https://github.com/automl/auto-sklearn via reticulate
#http://www.deeplearningbook.org/contents/monte_carlo.html
#https://github.com/ColtoCaro/compositionalMS/issues/1
devtools::install_github('coltocaro/compMS')
#https://willfondrie.com/2019/02/an-intuitive-look-at-the-xcorr-score-function-in-proteomics/
library(compMS)
RES <- compBayes(sampleDat)

View(RES[[1]])
View(RES[[2]])
View(RES[[4]])
View(RES[[5]])
View(RES[[6]])

catterPlot(RES, byCond = TRUE, avgCond = TRUE)

precisionPlot(RES, avgCond = TRUE)

```

```{r umapr}
#https://github.com/ropenscilabs/umapr#basic-use
devtools::install_github("ropenscilabs/umapr")
library(umapr)
library(tidyverse)

# select only numeric columns
df <- as.matrix(iris[ , 1:4])

# run UMAP algorithm
embedding <- umap(df)
embedding %>%
  mutate(Species = iris$Species) %>%
  ggplot(aes(UMAP1, UMAP2, color = Species)) + geom_point()
run_umap_shiny(embedding)
```

```{r tfp-install}
#https://blogs.rstudio.com/tensorflow/posts/2019-06-25-dynamic_linear_models_tfprobability/
install.packages("devtools",INSTALL_opts = "--no-multiarch")#https://stackoverflow.com/questions/40644971/error-installing-reporters-and-reportersjars
install.packages("reticulate",INSTALL_opts = "--no-multiarch")
devtools::install_github("rstudio/tfprobability",INSTALL_opts = "--no-multiarch")
```

```{r tfp-data}
library(tensorflow)
library(tfprobability)
#install.packages("tidyverse")
library(tidyverse)
library(zeallot)
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)

#https://raw.githubusercontent.com/rstudio/tensorflow-blog/master/docs/posts/2019-06-25-dynamic_linear_models_tfprobability/data/capm.txt
df <- read_table("capm.txt",col_types = list(X1 = col_date(format = "%Y.%m"))) %>%rename(month = X1)
df %>% glimpse()
df %>% gather(key = "symbol", value = "return", -month) %>%
  ggplot(aes(x = month, y = return, color = symbol)) +
  geom_line() +
  facet_grid(rows = vars(symbol), scales = "free")
```

```{r tfp-explore}
ibm <- df$IBM - df$RKFREE
# market excess returns
x <- df$MARKET - df$RKFREE

fit <- lm(ibm ~ x)
summary(fit)
ts <- ibm %>% matrix()
# forecast 12 months
n_forecast_steps <- 12
ts_train <- ts[1:(length(ts) - n_forecast_steps), 1, drop = FALSE]

# make sure we work with float32 here
ts_train <- tf$cast(ts_train, tf$float32)
ts <- tf$cast(ts, tf$float32)
linreg <- ts %>%
  sts_dynamic_linear_regression(
    design_matrix = cbind(rep(1, length(x)), x) %>% tf$cast(tf$float32)
  )
optimizer <- tf$compat$v1$train$AdamOptimizer(0.1)
model <- ts %>%
  sts_dynamic_linear_regression(design_matrix = cbind(rep(1, length(x)), x) %>% tf$cast(tf$float32))

# only train on the training set!
loss_and_dists <- ts_train %>% sts_build_factored_variational_loss(model = model)
variational_loss <- loss_and_dists[[1]]

train_op <- optimizer$minimize(variational_loss)


fit_vi <-
  function(ts,
           ts_train,
           model,
           n_iterations,
           n_param_samples,
           n_forecast_steps,
           n_forecast_samples) {
    loss_and_dists <-
      ts_train %>% sts_build_factored_variational_loss(model = model)
    variational_loss <- loss_and_dists[[1]]
    train_op <- optimizer$minimize(variational_loss)

    with (tf$Session() %as% sess,  {
      sess$run(tf$compat$v1$global_variables_initializer())
      for (step in 1:n_iterations) {
        res <- sess$run(train_op)
        loss <- sess$run(variational_loss)
        if (step %% 1 == 0)
          cat("Loss: ", as.numeric(loss), "\n")
      }
      variational_distributions <- loss_and_dists[[2]]
      posterior_samples <-
        Map(
          function(d)
            d %>% tfd_sample(n_param_samples),
          variational_distributions %>% reticulate::py_to_r() %>% unname()
        )
      forecast_dists <-
        ts_train %>% sts_forecast(model, posterior_samples, n_forecast_steps)
      fc_means <- forecast_dists %>% tfd_mean()
      fc_sds <- forecast_dists %>% tfd_stddev()

      c(posterior_samples,
        fc_means,
        fc_sds) %<-%
        sess$run(list(posterior_samples,
                      fc_means,
                      fc_sds))
    })

    list(variational_distributions,
         posterior_samples,
         fc_means[, 1],
         fc_sds[, 1])
  }


# call fit_vi defined above
# number of VI steps
n_iterations <- 300
# sample size for posterior samples
n_param_samples <- 50
# sample size to draw from the forecast distribution
n_forecast_samples <- 50
c(
  param_distributions,
  param_samples,
  fc_means,
  fc_sds,
  smoothed_means,
  smoothed_covs,
  filtered_means,
  filtered_covs
) %<-% fit_vi(
  ts,
  ts_train,
  model,
  n_iterations,
  n_param_samples,
  n_forecast_steps,
  n_forecast_samples
)
```

```{r Everything-Is-Correlated}
#https://www.gwern.net/Everything
#https://lindeloev.github.io/tests-as-linear/
# Load packages for data handling and plotting
library(tidyverse)
library(patchwork)
library(broom)

# Reproducible "random" results
set.seed(40)

# Generate normal data with known parameters
rnorm_fixed = function(N, mu = 0, sd = 1)
  scale(rnorm(N)) * sd + mu

# Plot style.
theme_axis = function(P,
                      jitter = FALSE,
                      xlim = c(-0.5, 2),
                      ylim = c(-0.5, 2),
                      legend.position = NULL) {
  P = P + theme_bw(15) +
    geom_segment(
      x = -1000, xend = 1000,
      y = 0, yend = 0,
      lty = 2, color = 'dark gray', lwd = 0.5
    ) +
    geom_segment(
      x = 0, xend = 0,
      y = -1000, yend = 1000,
      lty = 2, color = 'dark gray', lwd = 0.5
    ) +
    coord_cartesian(xlim = xlim, ylim = ylim) +
    theme(
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.border = element_blank(),
      panel.grid = element_blank(),
      legend.position = legend.position
    )

  # Return jittered or non-jittered plot?
  if (jitter) {
    P + geom_jitter(width = 0.1, size = 2)
  }
  else {
    P + geom_point(size = 2)
  }
}
# Wide format (sort of)
#y = rnorm_fixed(50, mu=0.3, sd=2)  # Almost zero mean.
y = c(rnorm(15), exp(rnorm(15)), runif(20, min = -3, max = 0))  # Almost zero mean, not normal
x = rnorm_fixed(50, mu = 0, sd = 1)  # Used in correlation where this is on x-axis
y2 = rnorm_fixed(50, mu = 0.5, sd = 1.5)  # Used in two means

# Long format data with indicator
value = c(y, y2)
group = rep(c('y1', 'y2'), each = 50)

```


```{r dimensioN, echo = FALSE}
#http://m-clark.github.io/posts/2019-05-14-shrinkage-in-mixed-models/
N=1000
#d<-runif(N)
d<-rep(0,N)
dd<-d
for (n in seq(1:N)) {i=runif(n);d[n]=sum(i);dd[n]=sqrt(sum(i*i))}
hist(d,breaks=N)
plot(d)
plot(dd)
#plot(d,dd)
hist(dd)#,breaks=N)
```

```{r rand-1-10, echo = FALSE}
#https://torvaney.github.io/projects/human-rng
#install.packages("tidyverse")
library(tidyverse)

probabilities <-
  read_csv("https://git.io/fjoZ2") %>%
  count(outcome = round(pick_a_random_number_from_1_10)) %>%
  filter(!is.na(outcome),
         outcome != 0) %>%
  mutate(p = n / sum(n))

probabilities %>%
  ggplot(aes(x = outcome, y = p)) +
  geom_col(aes(fill = as.factor(outcome))) +
  scale_x_continuous(breaks = 1:10) +
  scale_y_continuous(labels = scales::percent_format(),
                     breaks = seq(0, 1, 0.05)) +
  scale_fill_discrete(h = c(120, 360)) +
  theme_minimal(base_family = "Roboto") +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) +
  labs(title = '"1-10"',
       subtitle = "RNG distribution",
       x = "",
       y = NULL,
       caption = "Source: https://www.reddit.com/r/dataisbeautiful/comments/acow6y/asking_over_8500_students_to_pick_a_random_number/")


variables <-
  crossing(from = probabilities$outcome,
           to   = probabilities$outcome) %>%
  mutate(name = glue::glue("x({from},{to})"),
         ix = row_number())

variables

fill_array <- function(indices,
                       weights,
                       dimensions = c(1, max(variables$ix))) {
  init <- array(0, dim = dimensions)

  if (length(weights) == 1) {
    weights <- rep_len(1, length(indices))
  }

  reduce2(indices, weights, function(a, i, v) {
    a[1, i] <- v
    a
  }, .init = init)
}

constrain_uniform_output <-
  probabilities %>%
  pmap(function(outcome, p, ...) {
    x <-
      variables %>%
      filter(to == outcome) %>%
      left_join(probabilities, by = c("from" = "outcome"))

    fill_array(x$ix, x$p)
  })


one_hot <- partial(fill_array, weights = 1)

constrain_original_conserved <-
  probabilities %>%
  pmap(function(outcome, p, ...) {
    variables %>%
      filter(from == outcome) %>%
      pull(ix) %>%
      one_hot()
  })

maximise_original_distribution_reuse <-
  probabilities %>%
  pmap(function(outcome, p, ...) {
    variables %>%
      filter(from == outcome,
             to == outcome) %>%
      pull(ix) %>%
      one_hot()
  })

objective <- do.call(rbind, maximise_original_distribution_reuse) %>% colSums()


# Make results reproducible...
set.seed(23756434)

#install.packages("lpSolve")
solved <- lpSolve::lp(
  direction    = "max",
  objective.in = objective,
  const.mat    = do.call(rbind, c(constrain_original_conserved, constrain_uniform_output)),
  const.dir    = c(rep_len("==", length(constrain_original_conserved)),
                   rep_len("==", length(constrain_uniform_output))),
  const.rhs    = c(rep_len(1, length(constrain_original_conserved)),
                   rep_len(1 / nrow(probabilities), length(constrain_uniform_output)))
)

balanced_probabilities <-
  variables %>%
  mutate(p = solved$solution) %>%
  left_join(probabilities,
            by = c("from" = "outcome"),
            suffix = c("_redistributed", "_original"))

#install.packages("gganimate")
#install.packages("gifski")gifski_renderer
#install.packages("png")
library(png)
library(gifski)
library(gganimate)

redistribute_anim <-
  bind_rows(balanced_probabilities %>%
            mutate(key   = from,
                   state = "Before"),
            balanced_probabilities %>%
            mutate(key   = to,
                   state = "After")) %>%
  ggplot(aes(x = key, y = p_redistributed * p_original)) +
  geom_col(aes(fill = as.factor(from)),
           position = position_stack()) +
  scale_x_continuous(breaks = 1:10) +
  scale_y_continuous(labels = scales::percent_format(),
                     breaks = seq(0, 1, 0.05)) +
  scale_fill_discrete(h = c(120, 360)) +
  theme_minimal(base_family = "Roboto") +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) +
  labs(title = 'Balancing RNG distribution"',
       subtitle = "{closest_state}",
       x = "",
       y = NULL) +
  transition_states(
    state,
    transition_length = 4,
    state_length = 3
  ) +
  ease_aes('cubic-in-out')

animate(
  redistribute_anim,
  start_pause = 8,
  end_pause = 8
)

balanced_probabilities %>%
  ggplot(aes(x = from, y = to)) +
  geom_tile(aes(alpha = p_redistributed, fill = as.factor(from))) +
  geom_text(aes(label = ifelse(p_redistributed == 0, "", scales::percent(p_redistributed, 2)))) +
  scale_alpha_continuous(limits = c(0, 1), range = c(0, 1)) +
  scale_fill_discrete(h = c(120, 360)) +
  scale_x_continuous(breaks = 1:10) +
  scale_y_continuous(breaks = 1:10) +
  theme_minimal(base_family = "Roboto") +
  theme(panel.grid.minor = element_blank(),
        panel.grid.major = element_line(linetype = "dotted"),
        legend.position = "none") +
  labs(title = "Probability mass redistribution",
       x = "Original number",
       y = "Redistributed number")

probabilities %>%
  transmute(number = outcome,
            probability = scales::percent(p))


```

```{r compMS, echo = FALSE}
install.packages('rlang')
library(devtools)
install_github('coltocaro/compMS')
setRepositories(graphics = getOption("menu.graphics"),ind = NULL, addURLs = character())
library(compMS)
```


```{r tfp, echo = FALSE}
#https://blogs.rstudio.com/tensorflow/posts/2019-06-25-dynamic_linear_models_tfprobability/
#install.packages("devtools")
#devtools::install_github("rstudio/tfprobability")
library(tensorflow)
#tensorflow::install_tensorflow(version = "1.14")
library(tfprobability)
install.packages("tidyverse")
library(tidyverse)
library(zeallot)
df <- read_table("~/Documents/capm.txt",col_types = list(X1 = col_date(format = "%Y.%m"))) %>%  rename(month = X1)
df %>% glimpse()
df %>% gather(key = "symbol", value = "return", -month) %>%
  ggplot(aes(x = month, y = return, color = symbol)) +
  geom_line() +
  facet_grid(rows = vars(symbol), scales = "free")
ibm <- df$IBM - df$RKFREE
# market excess returns
x <- df$MARKET - df$RKFREE

fit <- lm(ibm ~ x)
summary(fit)
ts <- ibm %>% matrix()
# forecast 12 months
n_forecast_steps <- 12
ts_train <- ts[1:(length(ts) - n_forecast_steps), 1, drop = FALSE]

# make sure we work with float32 here
ts_train <- tf$cast(ts_train, tf$float32)
ts <- tf$cast(ts, tf$float32)
linreg <- ts %>%
  sts_dynamic_linear_regression(
    design_matrix = cbind(rep(1, length(x)), x) %>% tf$cast(tf$float32)
  )

optimizer <- tf$compat$v1$train$AdamOptimizer(0.1)
# only train on the training set!
loss_and_dists <- ts_train %>% sts_build_factored_variational_loss(model = model)
variational_loss <- loss_and_dists[[1]]

train_op <- optimizer$minimize(variational_loss)

```

```{r shiny, echo = FALSE}
#https://rmarkdown.rstudio.com/authoring_shiny.html
#install.packages('shiny')
library(shiny)
dN_shiny <- dataNorm
#ctrl-shift-K
#rmarkdown::run
#shiny::renderUI
```

```{r plotSVG}
library(ggplot2)
fileP<-"L:/promec/Animesh/api5000/"
fileS<-list.files(path=fileP, pattern="*.txt", full.names=TRUE, recursive=FALSE)
for(i in fileS){
  print(i)
  data <- read.table(i,sep="\t", header=F)
  print(summary(data))
  plot(data,type = "l")  #print(ggplot(data)+aes(data$V1,data$V2))
  ggsave(file=paste0(i,".svg"), plot=plot(data,type = "l"), width=6, height=6)
}
```

```{r ANOVA,echo=F}
pathD<-"F:/promec/USERS/MarianneNymark/181009/PDv2p3/181009_newprep_Charlotte_Alb3b-14_II"
inpF<-file.path(pathD,"181009_newprep_Charlotte_Alb3b-14_II-(1)_Proteins.txt")
data<-read.table(inpF,header=T,sep="\t",row.names = 3)
#summary(data)

inpL<-"F:/promec/USERS/MarianneNymark/181009/PDv2p3/181009_newprep_Charlotte_Alb3b-14_II/Groups.txt"
label<-read.table(inpL,header=T,sep="\t")
#colnames(label)
#summary(label)

y<-log2(as.matrix(data[32:46]))
#summary(y)
#hist(y)
row.names(y)<-row.names.data.frame(data)
y[is.na(y)]<-0
colnames(y)=sub("Abundances.Normalized.F","",colnames(y))
colnames(y)=sub(".Sample","",colnames(y))
#summary(y)

replicate<-as.factor(label$Replicate)
class<-as.factor(label$Group)

dataNorm<-y
set.seed(1)
dataNorm[dataNorm==0]<-rnorm(1,mean=mean(y),sd=sd(y))
#summary(dataNorm)

#TukeyHSD(aov(dataNorm["B7G7S4",]~class),"class", ordered = TRUE)[["class"]][10:12]

#chkANOVA<-apply(dataNorm,1,function(x){TukeyHSD(aov(x~class),"class")})
#chkANOVAnames<-t(sapply(row.names(dataNorm),function(x){chkANOVA[[x]]$`class`[10:12]}))
#chkANOVAnames<-apply(chkANOVAnames,2,function(x){p.adjust(x,"BH")})
#colnames(chkANOVAnames)<-c("Alb3b-16-Alb3b-14","Alb3b-14-WT", "Alb3b-16-WT")
#Uniprot<-sapply(strsplit(row.names(chkANOVAnames),";"), `[`, 1)
#write.csv(cbind(chkANOVAnames,Uniprot),file.path(pathD,"chkANOVAnames.csv"))
```



```{r slider, echo=FALSE}

inputPanel(
  sliderInput("bins", "#bins:", min = 1, max = 100, value = 30),
  textInput("dens", "Density:", "auto",value = 0.6),
  selectInput("expression", label = "Sample:",choices = colnames(dN_shiny), selected = colnames(dN_shiny)[1]))
renderText({paste("Inputs:", input$bins,input$dens,input$expression)})
```

```{r plot, echo = FALSE}
renderPlot({
  hist(dN_shiny[,as.numeric(which(colnames(dN_shiny) == input$expression))],breaks = as.numeric(input$bins),probability = TRUE,col="orange")
  lines(density(dN_shiny[,as.numeric(which(colnames(dN_shiny) == input$expression))], adjust = as.numeric(input$dens)),col="blue")
  })

```



```{r SiB-Workshop - Day 4 – deep-learning - test - diabetes-data}
fileP<-"/home/animeshs/Downloads/"
fileN<-"diabetes.csv"
yy<-read.csv(paste0(fileP, fileN),header=T)
summary(yy[,9])
#diab[,9]=as.numeric(diab[,9]-1)
plot(yy,col=yy$Outcome,main="diabetes")

yyt=as.matrix(yy)
#yyt[,9]=as.factor(yyt[,9])
library(ggfortify)
log.yyt=log(yyt[,1:8]+1)
yyt.pca=prcomp(log.yyt,center=TRUE,scale.=TRUE)
autoplot(yyt.pca,data=yyt,colour='Outcome',main="dataset")

dimnames(yyt)=NULL
summary(yyt)


library(keras)
#install_keras()
use_session_with_seed(2)
ind=sample(2,nrow(yyt),replace=TRUE,prob=c(0.75,0.25))

yyt.training=yyt[ind==1,1:8]
yyt.test=yyt[ind==2,1:8]

yyt.trainingtarget=yyt[ind==1,9]
yyt.testtarget=yyt[ind==2,9]

yyt.trainLabels=to_categorical(yyt.trainingtarget)
yyt.testLabels=to_categorical(yyt.testtarget)
```

```{r SiB-Workshop - Day 4 – deep-learning - test - diabetes-data - run}
model=keras_model_sequential()
model %>%
    layer_dense(input_shape=c(8),units=8,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
#    layer_dense(input_shape=c(6),units=6) %>%
#    layer_dense(input_shape=c(4),units=4) %>%
    layer_dense(units=2,activation='softmax',kernel_initializer="glorot_normal",use_bias=TRUE)
summary(model)

model %>% compile(loss='categorical_crossentropy',optimizer='adam',metrics='accuracy')
history=model %>% fit(yyt.training,yyt.trainLabels,epochs=100,batch_size=nrow(yyt.training),validation_split=0.2)
#history=model %>% fit(yyt.training,yyt.trainLabels,epochs=100,batch_size=5,validation_split=0.2)

plot(history)
predicted.classes=model %>% predict_classes(yyt.test)
table(yyt.testtarget,predicted.classes)
```

```{r read - lym-data}
fileP<-"/home/animeshs/Downloads/"
fileN<-"Sel66.txt"
lym<-read.table(paste0(fileP, fileN),row.names = 1, header=T)
fileC<-"Code.txt"
code<-read.table(paste0(fileP, fileC),row.names = 1, header=T)
summary(lym)
library(quantable)
y<-lym
y=robustscale(y)
y$data[is.na(y$data)]<-0
names(y$data)=sub("X","",names(y$data))
colnames(y$data)
yy<-rbind(y$data,code$Code)
yyt<-t(yy)
colnames(yyt) <- gsub(";", "_", colnames(yyt))
colnames(yyt) <- gsub("-", "__", colnames(yyt))
summary(yyt)
#yyt[,67]=as.numeric(yyt[,67]-1)
colnames(yyt)[67] <- "class"
summary(yyt)
plot(yyt[,67])
```

```{r SiB-Workshop - Day 4 – tree - lym}
library("rpart")
library("rpart.plot")
library("randomForest")
set.seed(100)
yyt=as.data.frame(yyt)
colnames(yyt)[67] <- "class"
yyt[,67]=as.factor(yyt[,67])
ind=sample(2,nrow(yyt),replace=TRUE,prob=c(0.80,0.20))
yyt.training=yyt[ind==1,]
yyt.test=yyt[ind==2,]

tree=rpart(data=yyt.training,class~.,method="class",control=rpart.control(minsplit=10,minbucket=5),parms=list(split="information"))
rpart.plot(tree,main="Classification tree for the yyt data (using 80% of data as training set)",extra=101)

#library(ggplot2)
#qplot(PTBP2,GALNT2,data=yyt,colour=class,size=I(3))
```


```{r SiB-Workshop - Day 4 – tree - lym - pred}
predictions=predict(tree,newdata=yyt.training,type="class")
actuals=yyt.training$class
table(actuals,predictions)

predictions=predict(tree,newdata=yyt.test,type="class")
actuals=yyt.test$class
confusion.matrix=table(actuals,predictions)
print(confusion.matrix)

accuracy=sum(diag(confusion.matrix))/sum(confusion.matrix)
print(accuracy)

tree=rpart(data=yyt,class~.,method="class",control=rpart.control(minsplit=1,minbucket=1,cp=0.000001),parms=list(split="information"))
rpart.plot(tree,main="Biggest Tree",extra=101)

printcp(tree)

plotcp(tree)

ptree=prune(tree,cp=2.0e-02)
rpart.plot(ptree,main="Pruned Tree",extra=101)
#qplot(ALDH1B1,PTBP2,data=yyt,colour=class,size=I(3))
```

```{r SiB-Workshop - Day 4 – randomtree - lym - pred}
library(randomForest)
set.seed(100)
#yyt=as.data.frame(yyt)
random_forest=randomForest(data=yyt.training,class~.,impurity='gini',ntree=200,replace=TRUE)
print(random_forest)

plot(random_forest)
legend("top",cex=0.8,legend=colnames(random_forest$err.rate),lty=c(1,2,3),col=c(1,2,3),horiz=T)

random_forest=randomForest(data=yyt.training,class~.,impurity='gini',ntree=25,replace=TRUE)

predictions=predict(random_forest,newdata=yyt.training,type="class")
actuals=yyt.training$class
table(actuals,predictions)

predictions=predict(random_forest,newdata=yyt.test,type="class")
actuals=yyt.test$class
confusion.matrix=table(actuals,predictions)
print(confusion.matrix)

accuracy=sum(diag(confusion.matrix))/sum(confusion.matrix)
print(accuracy)

sort(importance(random_forest))
varImpPlot(random_forest)
#qplot(RCN1,GALNT2,data=yyt,colour=class,size=I(3))
```

```{r SiB-Workshop - Day 4 – tree}
#install.packages("rpart")
#install.packages("rpart.plot")
#install.packages("randomForest")
library("rpart")
library("rpart.plot")
library("randomForest")
data(iris)
set.seed(2)
ind=sample(2,nrow(iris),replace=TRUE,prob=c(0.80,0.20))
iris.training=iris[ind==1,]
iris.test=iris[ind==2,]
tree=rpart(data=iris.training,Species~Sepal.Width+Sepal.Length+Petal.Length+Petal.Width,method="class",control=rpart.control(minsplit=10,minbucket=5),parms=list(split="information"))
rpart.plot(tree,main="Classification tree for the iris data (using 80% of data as training set)",extra=101)

library(ggplot2)
qplot(Petal.Length,Petal.Width,data=iris,colour=Species,size=I(3))
predictions=predict(tree,newdata=iris.training,type="class")
actuals=iris.training$Species
table(actuals,predictions)

predictions=predict(tree,newdata=iris.test,type="class")
actuals=iris.test$Species
confusion.matrix=table(actuals,predictions)
print(confusion.matrix)

accuracy=sum(diag(confusion.matrix))/sum(confusion.matrix)
print(accuracy)

tree=rpart(data=iris,Species~Sepal.Width+Sepal.Length+Petal.Length+Petal.Width,method="class",control=rpart.control(minsplit=1,minbucket=1,cp=0.000001),parms=list(split="information"))
rpart.plot(tree,main="Biggest Tree",extra=101)

printcp(tree)

plotcp(tree)

ptree=prune(tree,cp=2.0e-02)
rpart.plot(ptree,main="Pruned Tree",extra=101)

library(randomForest)

random_forest=randomForest(data=iris.training,Species~Sepal.Width+Sepal.Length+Petal.Length+Petal.Width,impurity='gini',ntree=200,replace=TRUE)
print(random_forest)

plot(random_forest)
legend("top",cex=0.8,legend=colnames(random_forest$err.rate),lty=c(1,2,3),col=c(1,2,3),horiz=T)

random_forest=randomForest(data=iris.training,Species~Sepal.Width+Sepal.Length+Petal.Length+Petal.Width,impurity='gini',ntree=25,replace=TRUE)

predictions=predict(random_forest,newdata=iris.training,type="class")
actuals=iris.training$Species
table(actuals,predictions)

predictions=predict(random_forest,newdata=iris.test,type="class")
actuals=iris.test$Species
confusion.matrix=table(actuals,predictions)
print(confusion.matrix)

accuracy=sum(diag(confusion.matrix))/sum(confusion.matrix)
print(accuracy)

importance(random_forest)
varImpPlot(random_forest)

```


```{r SiB-Workshop - Day 3 – deep-learning - lym}
fileP<-"/home/animeshs/Downloads/"
fileN<-"Sel66.txt"
lym<-read.table(paste0(fileP, fileN),row.names = 1, header=T)
fileC<-"Code.txt"
code<-read.table(paste0(fileP, fileC),row.names = 1, header=T)
summary(lym)
library(quantable)
y<-lym
y=robustscale(y)
y$data[is.na(y$data)]<-0
names(y$data)=sub("X","",names(y$data))
colnames(y$data)
yy<-rbind(y$data,code$Code)

yyt<-t(yy)
summary(yyt)
yyt[,67]=as.numeric(yyt[,67]-1)
summary(yyt)
plot(yyt[,67])
yyt=as.matrix(yyt)
dimnames(yyt)=NULL

library(keras)
#install_keras()
use_session_with_seed(3)
set.seed(2)
ind=sample(2,nrow(yyt),replace=TRUE,prob=c(0.80,0.20))

yyt.training=yyt[ind==1,1:66]
yyt.test=yyt[ind==2,1:66]

yyt.trainingtarget=yyt[ind==1,67]
yyt.testtarget=yyt[ind==2,67]

yyt.trainLabels=to_categorical(yyt.trainingtarget)
yyt.testLabels=to_categorical(yyt.testtarget)
model=keras_model_sequential()
model %>%
    layer_dense(input_shape=c(66),units=33,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
    layer_dense(units=3,activation='softmax',kernel_initializer="glorot_normal",use_bias=TRUE)
summary(model)

model %>% compile(loss='categorical_crossentropy',optimizer='adam',metrics='accuracy')
history=model %>% fit(yyt.training,yyt.trainLabels,epochs=100,batch_size=5,validation_split=0.2)

plot(history)
predicted.classes=model %>% predict_classes(yyt.test)
table(yyt.testtarget,predicted.classes)
```

```{r SiB-Workshop - Day 3 – deep-learning}
#install.packages("devtools")
#devtools::install_github("rstudio/keras")
library(keras)
#install_keras()
use_session_with_seed(3)
data(iris)
head(iris, 3)
summary(iris)
plot(iris)
#install.packages("ggplot2")
#install.packages("ggfortify")
library("ggfortify")
log.iris=log(iris[,1:4])
iris.pca=prcomp(log.iris,center=TRUE,scale.=TRUE)
library("ggplot2")
autoplot(iris.pca,data=iris,colour='Species',main="PCA of the iris dataset")

plot(iris$Sepal.Length,iris$Sepal.Width,pch=21,bg=c("red","green3","blue")[unclass(iris$Species)],xlab="Sepal Length",ylab="Sepal Width")

plot(iris$Petal.Length,iris$Petal.Width,pch=21,bg=c("red","green3","blue")[unclass(iris$Species)],xlab="Petal Length",ylab="Petal Width")

data(iris)
iris[,5]=as.numeric(iris[,5])-1
iris=as.matrix(iris)
dimnames(iris)=NULL

set.seed(2)
ind=sample(2,nrow(iris),replace=TRUE,prob=c(0.80,0.20))

iris.training=iris[ind==1,1:4]
iris.test=iris[ind==2,1:4]

iris.trainingtarget=iris[ind==1,5]
iris.testtarget=iris[ind==2,5]

iris.trainLabels=to_categorical(iris.trainingtarget)
iris.testLabels=to_categorical(iris.testtarget)
model=keras_model_sequential()
model %>%
    layer_dense(input_shape=c(4),units=8,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
    layer_dense(units=3,activation='softmax',kernel_initializer="glorot_normal",use_bias=TRUE)
summary(model)

model %>% compile(loss='categorical_crossentropy',optimizer='adam',metrics='accuracy')
history=model %>% fit(iris.training,iris.trainLabels,epochs=100,batch_size=5,validation_split=0.2)

plot(history)

predicted.classes=model %>% predict_classes(iris.test)
table(iris.testtarget,predicted.classes)

score=model %>% evaluate(iris.test,iris.testLabels)
print(score)
```

```{r SiB-Workshop - Day 3 – deep-learning - test}


model=keras_model_sequential()

model %>%
    layer_dense(input_shape=c(4),units=28,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
    layer_dense(units=3,activation='softmax',kernel_initializer="glorot_normal",use_bias=TRUE)

model %>% compile(loss='categorical_crossentropy',optimizer='adam',metrics='accuracy')

model %>% fit(iris.training,iris.trainLabels,epochs=200,batch_size=5,validation_split=0.2)

score=model %>% evaluate(iris.test,iris.testLabels)

print(score)

model=keras_model_sequential()
model %>%
    layer_dense(input_shape=c(4),units=28,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
    layer_dense(units=5,activation='relu',kernel_initializer="glorot_normal",use_bias=TRUE) %>%
    layer_dense(units=3,activation='softmax',kernel_initializer="glorot_normal",use_bias=TRUE)
model %>% compile(loss='categorical_crossentropy',optimizer='adam',metrics='accuracy')
model %>% fit(iris.training,iris.trainLabels,epochs=200,batch_size=5,validation_split=0.2)
score=model %>% evaluate(iris.test,iris.testLabels)
print(score)
```



```{r SiB-Workshop - Day 3 – clust}
?hclust
?kmeans
mat <- matrix(data = rnorm(30, mean= 100,sd=10), nrow = 15, ncol = 2)
mat.dist<-as.matrix(dist(mat))
heatmap(mat.dist)
heatmap(mat.dist,Colv=NA, Rowv=NA, scale="none")
colorScale <- colorRampPalette(c("blue","green","yellow","red","darkred"))(1000)

heatmap(mat.dist,Colv=NA, Rowv=NA,scale="none",col=colorScale)

fileP<-"/home/animeshs/Downloads/"
fileN<-"Sel66.txt"
inputFile <- paste0(fileP, fileN)
lym<-read.table(inputFile,row.names = 1, header=T)
mat.dist<-as.matrix(dist(t(lym)))
heatmap(mat.dist)
cl<- kmeans(lym, 10, iter.max=20)
plot(cl$centers)
cah <- hclust(dist(cl$centers))#,"complete")#, graph=FALSE, nb.clust=-1)
plot(cah)


distE<- dist(mat)
distC<- dist(mat,method="manhattan")
mat.distE<-as.matrix(dist(mat))
mat.distC<-as.matrix(dist(mat,method="manhattan"))
heatmap(mat.distE,Colv=NA, Rowv=NA,scale="none",col=colorScale)
heatmap(mat.distC,Colv=NA, Rowv=NA,scale="none",col=colorScale)
hE<-hclust(distE,"complete")
hC<-hclust(distC,"complete")
plot(hE)
plot(hC)

df<-data.frame(mat)
kmeans(df,3)
cl.1 <- kmeans(df, 3, iter.max = 1)
plot(df, col = cl.1$cluster)
points(cl.1$centers, col = 1:5, pch = 8)

cl.1000 <- kmeans(df, 3, iter.max = 1000)
plot(df, col = cl.1000$cluster)
points(cl.1000$centers, col = 1:5, pch = 8)

x<- rbind(matrix(rnorm(70000, sd = 0.3), ncol = 2),matrix(rnorm(70000, mean = 1, sd = 0.3),ncol = 2))
colnames(x) <- c("x", "y")
cl<- kmeans(x, 1000, iter.max=20)
plot(cl$centers)
cah <- hclust(dist(cl$centers))#,"complete")#, graph=FALSE, nb.clust=-1)
plot(cah)

fileP<-"/home/animeshs/Downloads/"
fileN<-"Sel66.txt"
inputFile <- paste0(fileP, fileN)
lym<-read.table(inputFile,row.names = 1)
cl<- kmeans(lym, 10, iter.max=20)
plot(cl$centers)
cah <- hclust(dist(cl$centers))#,"complete")#, graph=FALSE, nb.clust=-1)
plot(cah)

clustering_data<- rxImport(inData = inputFile)
rxGetVarInfo(clustering_data)

z<-rxKmeans(~1_19912 + ~9_1702, data =clustering_data, numClusters = 3, maxIterations=100)

lym<-read.table(inputFile,row.names = 1,header = T)
summary(lym)
clustering_data<-data.frame(lym)
#clustering_data<- rxImport(inData = "/home/animeshs/Downloads/dataClustering.csv")
rxGetVarInfo(clustering_data)
z<-rxKmeans(~X9_1702 + X8_16846, data =clustering_data, numClusters = 3, maxIterations=100)
z<-rxKmeans(as.formula(paste("~",paste(names(clustering_data),collapse="+"))),data = clustering_data, numClusters = 3, maxIterations=100)
#plot(clustering_data, col = z$cluster)
points(z$centers, col = 1:5, pch = 8)

```

```{r SiB-Workshop - Day 2 – mclus}
#install.packages("mclust")
library("mclust")
?mclustBIC
?Mclust
fileP<-"/home/animeshs/Downloads/"
fileN<-"Sel66.txt"
inputFile <- paste0(fileP, fileN)
lym<-read.table(inputFile,row.names = 1,header=T)
summary(lym)
lym[is.na(lym)]=0
BIC <- mclustBIC(lym)
plot(BIC)
summary(BIC)
mod1 <- Mclust(lym, x = BIC)
summary(mod1, parameters = TRUE)
plot(mod1, what = "classification")
```

```{r SiB-Workshop - Day 2 – pca}
pcaD<-prcomp(lym, center = TRUE, scale. = FALSE)
summary(pcaD)
plot(pcaD$x)
```

```{r SiB-Workshop - Day 2 – lda}
library(MASS)
data(iris)
head(iris, 3)
train <- sample(1:150, 75)
r <- lda(formula = Species ~ .,data = iris,prior = c(1,1,1)/3,subset = train)
r$prior
r$counts
#means for each covariate
r$means
#with 3 classes we have at most two linear discriminants
r$scaling
#the singular values (svd) that gives the ratio of the between- and within-group standard deviations on the linear discriminan variables.
r$svd
# amount of the between-group variance that is explained by eaclinear discriminant
prop = r$svd^2/sum(r$svd^2)
head(prop$class)
head(r2$posterior, 3)
plda = predict(object = r, newdata = iris[-train, ])
```

```{r SiB-Workshop - Day 2 – RevoScaleR}
#<pre>export RSTUDIO_WHICH_R=/usr/bin/Revo64</pre>
#export R_LIBS_SITE=/opt/microsoft/rclient/3.4.3/libraries/RServer
#sudo ln -s /usr/lib/x86_64-linux-gnu/libpng16.so.16.36.0 /usr/lib/x86_64-linux-gnu/libpng12.so.0

   inputFileFlight <- paste0("/home/animeshs/Downloads/", "Flight_Delays_Sample.csv")
   inputFileWeather <- paste0("/home/animeshs/Downloads/", "Weather_Sample.csv")

#Create a temporary directory to store the intermediate XDF files.

   outFileFlight  <- "/home/animeshs/Downloads/flight.xdf"
   outFileWeather <- "/home/animeshs/Downloads/weather.xdf"
   outFileOrigin <-  "/home/animeshs/Downloads/originData.xdf"
   outFileDest   <-  "/home/animeshs/Downloads/destData.xdf"
   outFileFinal  <-  "/home/animeshs/Downloads/finalData.xdf"

#Import the flight data.
    flight_mrs <- rxImport(
      inData = inputFileFlight, outFile = outFileFlight,
      missingValueString = "M", stringsAsFactors = FALSE,
      # Remove columns that are possible target leakers from the flight data.
      varsToDrop = c("DepDelay", "DepDel15", "ArrDelay", "Cancelled", "Year"),
      # Define "Carrier" as categorical.
      colInfo = list(Carrier = list(type = "factor")),
      # Round down scheduled departure time to full hour.
      transforms = list(CRSDepTime = floor(CRSDepTime/100)),
      overwrite = TRUE
    )

#Review the first six rows of flight data.
    head(flight_mrs)

#Summarize the flight data.
    rxSummary(~., data = flight_mrs, blocksPerRead = 2)

#Import the weather data.
    xform <- function(dataList) {
      # Create a function to normalize some numerical features.
      featureNames <- c(
        "Visibility",
        "DryBulbCelsius",
        "DewPointCelsius",
        "RelativeHumidity",
        "WindSpeed",
        "Altimeter"
      )
      dataList[featureNames] <- lapply(dataList[featureNames], scale)
      return(dataList)
    }

    weather_mrs <- rxImport(
      inData = inputFileWeather, outFile = outFileWeather,
      missingValueString = "M", stringsAsFactors = FALSE,
      # Eliminate some features due to redundance.
      varsToDrop = c("Year", "Timezone",
                     "DryBulbFarenheit", "DewPointFarenheit"),
      # Create a new column "DestAirportID" in weather data.
      transforms = list(DestAirportID = AirportID),
      # Apply the normalization function.
      transformFunc = xform,
      transformVars = c(
        "Visibility",
        "DryBulbCelsius",
        "DewPointCelsius",
        "RelativeHumidity",
        "WindSpeed",
        "Altimeter"
      ),
      overwrite = TRUE
    )

#Review the variable information for the weather data.
    rxGetVarInfo(weather_mrs)


#Step 2: Pre-process Data
#Prepare for a merge by renaming some columns in the weather data.
    newVarInfo <- list(
      AdjustedMonth = list(newName = "Month"),
      AdjustedDay = list(newName = "DayofMonth"),
      AirportID = list(newName = "OriginAirportID"),
      AdjustedHour = list(newName = "CRSDepTime")
    )
    rxSetVarInfo(varInfo = newVarInfo, data = weather_mrs)

#Concatenate/Merge flight records and weather data.
##Join flight records and weather data at origin of the flight `OriginAirportID`.
      originData_mrs <- rxMerge(
        inData1 = flight_mrs, inData2 = weather_mrs, outFile = outFileOrigin,
        type = "inner", autoSort = TRUE,
        matchVars = c("Month", "DayofMonth", "OriginAirportID", "CRSDepTime"),
        varsToDrop2 = "DestAirportID",
        overwrite = TRUE
      )

##Join flight records and weather data using the destination of the flight `DestAirportID`.
      destData_mrs <- rxMerge(
        inData1 = originData_mrs, inData2 = weather_mrs, outFile = outFileDest,
        type = "inner", autoSort = TRUE,
        matchVars = c("Month", "DayofMonth", "DestAirportID", "CRSDepTime"),
        varsToDrop2 = c("OriginAirportID"),
        duplicateVarExt = c("Origin", "Destination"),
        overwrite = TRUE
      )

##Call the rxFactors() function to convert `OriginAirportID` and `DestAirportID` as categorical.
      rxFactors(inData = destData_mrs, outFile = outFileFinal, sortLevels = TRUE,
                factorInfo = c("OriginAirportID", "DestAirportID"),
                overwrite = TRUE)
rxGetInfo(outFileFinal)
rxGetInfo(outFileFinal,getVarInfo=TRUE)
```

```{r SiB-Workshop - Day 2 - Example 2 – Basic Regression}
data <- read.table("/home/animeshs/Downloads/class.txt")
summary(data)
pairs(data)
model <- lm( Height ~ Age , data = data)
summary(model)
lm_class_basicR<-lm(formula= Height~Weight, data = data[,-1])
summary(lm_class_basicR)

class_data<-rxImport(inData = "/home/animeshs/Downloads/class.txt")
lm_class<-rxLinMod(formula= Height~Weight, data =class_data[,-1])
summary(lm_class)
summary(lm_class_basicR)


big_data<-rxImport(inData = outFileFinal)
lm_class_big<-rxLinMod(formula= WindSpeed.Destination~Altimeter.Destination, data =big_data)
summary(lm_class_big)
#scatter(~WindSpeed.Destination,~Altimeter.Destination,data=outFileFinal)
rxHistogram(~WindSpeed.Destination,data=outFileFinal)

lm_class_big_basicR<-lm(WindSpeed.Destination~Altimeter.Destination, data =big_data)
summary(lm_class_big_basicR)
lm_class_gender<-rxLinMod(formula= Height~Age+Gender, data =recodedDF2[,-1])
summary(lm_class_gender)
#scatter(~WindSpeed.Destination,~Altimeter.Destination,data=outFileFinal)
rxHistogram(~WindSpeed.Destination,data=outFileFinal)

recodedDF2 <- rxFactors(inData = class_data, sortLevels = TRUE,factorInfo = c("Gender"))
rxGetVarInfo(recodedDF2)
lm_class_gender<-rxLinMod(formula= Height~Age+Gender,data =recodedDF2[,-1])
summary(lm_class_gender)
```

```{r cheeseTest}
cheese_data<-rxImport(inData = "/home/animeshs/Downloads/cheese.txt")
rxGetVarInfo(cheese_data)
lm_taste<-rxLinMod(formula= taste~Acetic, data =cheese_data[,-1])
summary(lm_taste)
lm_taste<-rxLinMod(formula= taste~Lactic, data =cheese_data[,-1])
summary(lm_taste)
lm_taste<-rxLinMod(formula= taste~H2S, data =cheese_data[,-1])
summary(lm_taste)
lm_taste<-rxLinMod(formula= taste~Case, data =cheese_data[,-1])
summary(lm_taste)
lm_taste<-rxLinMod(formula= taste~Acetic*Lactic, data =cheese_data[,-1])
summary(lm_taste)
lm_taste<-rxLinMod(formula= taste~Acetic+Lactic, data =cheese_data[,-1])
summary(lm_taste)
head(cheese_data)
rxHistogram(~Case,data=cheese_data)
recodedDF2 <- rxFactors(inData = cheese_data, sortLevels = TRUE,factorInfo = c("Case"))
rxGetVarInfo(recodedDF2)
lm_taste_case<-rxLinMod(formula= taste~Acetic+Lactic+Case, data =recodedDF2[,-1])
summary(lm_taste_case)
rxHistogram(~taste,data=cheese_data)
rxHistogram(~H2S,data=cheese_data)
cheese_data_logH2S<-rxDataStep(inData=cheese_data,transforms = list(logH2S = log(cheese_data[,5])),overwrite = TRUE)
hist(log(cheese_data[,5]))
lm_taste_case<-rxLinMod(formula= taste~H2S, data =recodedDF2[,-1])
summary(lm_taste_case)
lm_taste_case<-lm(formula= taste~log(H2S), data =recodedDF2[,-1])
summary(lm_taste_case)
```

```{r logit}
class_data_basic<-read.table("/home/animeshs/Downloads/class.txt")
logitmodel_basic<-glm(Gender~Height,family=binomial,data=class_data_basic)
summary(logitmodel_basic)
class_data<-rxImport(inData = "/home/animeshs/Downloads/class.txt")
recodedDF <- rxFactors(inData = class_data, sortLevels = TRUE,factorInfo = c("Gender"))
rxGetVarInfo(recodedDF)
logitmodel<-rxLogit(Gender~Height,data=recodedDF[,-1])
summary(logitmodel)
rxHistogram(~Height,data=recodedDF[,-1])
```

```{r logit-brfss}
#brfss_data<-rxImport(inData = "/home/animeshs/LLCP2013.XPT")
brfss<-read.csv("/home/animeshs/Downloads/LLCP2013_sampled.csv")
brfss$has_plan <- brfss$HLTHPLN1 == 1
brfss$X.RACE
summary(glm(has_plan ~ as.factor(brfss$X.RACE), data=brfss,family=binomial))
recodedDF2 <-brfss
recodedDF2 <- rxFactors(inData = brfss, sortLevels = TRUE,factorInfo = c("X.RACE"))
str(recodedDF2$X.RACE)
recodedDF2$HLTHPLN1_has<- recodedDF2$HLTHPLN1 == 1
logitmodel_brfss<-rxLogit(has_plan~X.RACE,data=recodedDF2[,-1])
logitmodel_brfss<-rxLogit(HLTHPLN1_has~X.RACE,data=recodedDF2[,-1])
summary(logitmodel_brfss)
levels(as.factor(brfss$X.RACE))
levels(recodedDF2$X.RACE)

brfss_data<-rxImport(inData = "/home/animeshs/Downloads/LLCP2013_sampled.csv")
rxGetVarInfo(brfss_data)
recodedDF2 <- rxFactors(inData = brfss_data, sortLevels = TRUE,factorInfo = c("X.RACE"))
recodedDF2$HLTHPLN1_has<- recodedDF2$HLTHPLN1 == 1
recodedDF2$has_plan<- recodedDF2$HLTHPLN1 == 1
str(recodedDF2$X.RACE)
str(recodedDF2$has_plan)
rxGetVarInfo(recodedDF2)
rxHistogram(~X.RACE,data=recodedDF2[,-1])
rxHistogram(~HLTHPLN1,data=recodedDF2[,-1])
rxHistogram(~HLTHPLN1_has,data=recodedDF2[,-1])
#complete.cases(recodedDF2)
logitmodel_brfss<-rxLogit(HLTHPLN1_has~X.RACE,data=recodedDF2[,-1])
#logitmodel_brfss<-rxLogit(HHLTHPLN1_has~X.RACE,data=recodedDF2[,-1],family=binomial())
summary(logitmodel_brfss)
logitmodel_brfss<-rxLogit(has_plan~X.RACE,data=recodedDF2[,-1])
#logitmodel_brfss<-rxLogit(HHLTHPLN1_has~X.RACE,data=recodedDF2[,-1],family=binomial())
summary(logitmodel_brfss)
valP<-(glm(has_plan ~ as.factor(brfss$X.RACE), data=brfss,family=binomial))
valP[[7]]$tol
pv<-c(0.00346, 0.94744, 0.97384, 0.98888, 0.18799, 0.05449, 0.27669)
p.adjust(pv, method = "hommel", n = length(pv))
install.packages("caret")
library("caret")

```

```{r Revox64}
#library("RevoScaleR")
data<-rxImport(inData='/home/animeshs/Downloads/mortality.csv')
rxGetInfo(data,getVarInfo=TRUE,numRows=3)
dataStep<-rxImport(inData='/home/animeshs/Downloads/mortality.csv',outFile='/home/animeshs/Downloads/mortalityDS.txt',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850)
rxGetInfo(dataStep,getVarInfo=TRUE)
dataStep<-rxImport(inData='/home/animeshs/Downloads/mortality.csv',outFile='/home/animeshs/Downloads/mortalityDS.gz',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850,transforms = list(expression = cut(ccExp, breaks = c(0, 6500, 13000),labels = c("Low exp", "High exp"))))
dataStep<-rxImport(inData='/home/animeshs/Downloads/mortality.csv',outFile='/home/animeshs/Downloads/mortalityDS.gz',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850,transforms = list(expression = floor(ccExp/100)))
rxHistogram(~score,data=dataStep)
rxHistogram(~expression,data=dataStep)
dataStep<-rxImport(inData='/home/animeshs/Downloads/mortality.csv',outFile='/home/animeshs/Downloads/mortalityDS.gz',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850,transforms = list(expression = floor(ccExp/100)))
dataStep<-rxDataStep(inData='/home/animeshs/Downloads/mortality.csv',outFile='/home/animeshs/Downloads/mortalityDS.gz',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850,transforms = list(expression = floor(ccExp/100)))

datacsv <- rxImport("/home/animeshs/Downloads/mortality.csv")
dataExampleNew1<-rxDataStep(inData=dataStep,outFile='/home/animeshs/Downloads/mortalityDS.gz',varsToDrop=c("year"),overwrite=TRUE, rowSelection=score<850,transforms = list(expression = floor(ccExp/100)))
dataExampleNew1<-rxDataStep(inData=dataStep,transforms = list(expression = floor(ccExp/100)))
dataExampleNew2<-rxDataStep(inData=dataStep,transforms = list(expression = floor(ccExp/100)))

dataFD <- rxImport("/home/animeshs/Downloads/Flight_Delays_Sample.csv")
dataWS <- rxImport("/home/animeshs/Downloads/Weather_Sample.csv")
rxGetInfo(dataFD,getVarInfo=TRUE)
rxGetInfo(dataWS,getVarInfo=TRUE)
dataWSdesport<-rxDataStep(inData=dataWS,transforms = list(OriginAirportID = AirportID))
rxGetInfo(dataWSdesport,getVarInfo=TRUE)
dataWSdesport<-rxDataStep(inData=dataWS,transforms = list(OriginAirportID = AirportID))
WDmFD<-rxMerge (inData1=dataWSdesport,inData2= dataFD,type="inner",matchVars=c("OriginAirportID"))


```

```{r SiB-Workshop - Day 1 - Example 1 – Basic Histogram}
library(shiny)
ui<- fluidPage(
titlePanel("Workshop - Example 1 – Basic Histogram"),
sidebarLayout(
sidebarPanel(
numericInput(inputId="n", label="Number of observations", value=1000)
),
mainPanel(plotOutput("plot"))
)
)
server<-function(input, output) {
data <- reactive({
x <- rnorm(input$n)
x
})
output$plot <- renderPlot({
hist(data(), 50,main="", xlab="x")
})
}
shinyApp(ui,server)
```


```{r SiBday1}
x <- runif(50); y <- 2*x + 0.5 + rnorm(50)/5
groups <- ifelse( y<1, 1, 2 )
par(las=1)
plot(x, y, col=c("red", "blue")[groups], pch=c(1,2)[groups])
title("Scatterplot of x vs y")
abline( lm( y ~ x) )
abline( h=1, lty=2 )
legend( x="topleft", legend=c("Group 1", "Group 2"),
fill=c("red","blue") )
text( 0,2, paste("Correlation = ", round(cor(x,y),2)), pos=4)
rug(x)
```

```{r SiBgoogleVis}
install.packages("googleVis")
library(googleVis)
data_survival<-read.csv("~/Documents/survival.csv", header=TRUE)
MCH<-gvisMotionChart(data,idvar = "",timevar = "",xvar=" ",yvar="",colorvar="",sizevar="",options = list())
MCH<-gvisMotionChart(data,idvar = "",timevar = "",xvar=" ",yvar="",colorvar="",sizevar="",options = list())
plot(gvisTable(data_survival))

df=data.frame(country=c("US", "GB", "BR"),
              val1=c(10,13,14),
              val2=c(23,12,32))
```

```{r SiB}
library(googleVis)
data_map<-read.csv( "~/Documents/map.csv", header=TRUE,sep= "\t")
map<-gvisGeoChart(data_map,locationvar="Country",colorvar="mortality")
plot(map)
```
```{r SiBdataTable}
#excel limit by 60K rows
#R by 2GB lines*columns
memory.limit()
data("esoph")
object.size(esoph)
install.packages("SASxport")
library(SASxport)
brfss<-read.xport("~/LLCP2013.XPT")
object.size(brfss)
summary(brfss)
install.packages("data.table")
library(data.table)
brfss_dt<-data.table(brfss)
object.size(brfss_dt)
summary(brfss_dt)
brfss_dt<-data.table("~/LLCP2013.XPT")
brfss_dt$V1
object.size(brfss_dt)
summary(brfss_dt)
brfss_sample<-sample(t(brfss),50)
install.packages("oddsratio")
library(oddsratio)
library(epitools)
oddsratio(as.factor(brfss$X.HCVU651),as.factor(brfss$X.RFCHOL))
rows_to_select <- sample(1:nrow(brfss), 500, replace=F)
brfss_sample <- brfss[rows_to_select,]
oddsratio(as.factor(brfss_sample$X.HCVU651),as.factor(brfss_sample$X.RFCHOL))

```

```{r SiBbenchmark}
df <- data.frame(group=factor(sample(c("g1","g2"), 10, replace=TRUE)),mortality=runif(10))


library(microbenchmark)
library(ggplot2)
#install.packages("dplyr")
library(plyr)
library(dplyr)
library(reshape2)
library(data.table)
#install.packages('tidyverse')
library(tidyverse)

dt<- data.table(df)
setkey(dt, mortality)

setDT(df)[ , .(mean_mortality =mean(mortality)), by = group]


splitmean <- function(df) {
s <- split( df, df$group)
sapply( s, function(x)
mean(x$mortality) )
}
splitmean(df)


m1 <- microbenchmark(
by( df$mortality, df$group, mean),
aggregate(mortality~ group, df, mean ),
splitmean(df),
ddply( df, .(group), function(x) mean(x$mortality) ),
dcast( melt(df), variable ~ group, mean),
#dt[, mean(mortality), by = group],
summarize( group_by(df, group), m = mean(mortality) ),
summarize( group_by(dt, group), m = mean(mortality) )
)
print(m1, signif = 3)
autoplot(m1)
```


```{r SiBpack}
install.packages("epitools")
install.packages("taRifx")
install.packages("data.table")
install.packages("reshape")
install.packages("dplyr")
install.packages("plyr")
#install.packages("utils")
install.packages("microbenchmark")

install.packages("ggplot2")

install.packages("ggfortify")
```

```{r peptideDistribChk}
lPep=100
nPep=10000
nTot=lPep*nPep
data<-runif(nTot)
#hist(sample(data,100000,replace=T),breaks=nPep)
sPep=rnorm(lPep)
n=1
i=1
while(n<=lPep){
  print(n)
  print(i)
  sPep[c(seq(n,n+i-1))]=sample(data,i,replace=T)
  n=n+i
  i=i+1
}
hist(sPep,breaks=lPep)
summary(sPep)
```

```{r setup}
library(r2d3)
bars <- c(10, 20, 30)
```

```{r VennDetail}
#https://bioconductor.org/packages/release/bioc/vignettes/VennDetail/inst/doc/VennDetail.html
#install.packages('BiocManager')
BiocManager::install("VennDetail")
library(VennDetail)
data(T2DM)
ven <- venndetail(list(Cortex = T2DM$Cortex$Entrez, SCN = T2DM$SCN$Entrez,Glom = T2DM$Glom$Entrez))
plot(ven, type = "vennpie")
```

```{r proBatch}
#https://github.com/symbioticMe/proBatch
#needs R version 3.6
bioc_deps <- c("GO.db", "impute", "preprocessCore", "pvca","sva" )
cran_deps <- c("corrplot", "data.table", "ggplot2", "ggfortify","lazyeval", "pheatmap", "reshape2", "rlang",
               "tibble", "dplyr", "tidyr", "wesanderson","WGCNA")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(bioc_deps)
install.packages(cran_deps)

install.packages("devtools")
install.packages("processx")
install.packages("dplyr")
install.packages("fs")
library(devtools)
install_github("symbioticMe/proBatch", build_vignettes = TRUE)

bioc_deps <- c("GO.db", "impute", "preprocessCore", "pvca","sva" )
cran_deps <- c("corrplot", "data.table", "ggplot2", "ggfortify","lazyeval", "pheatmap", "reshape2", "rlang" "tibble", "dplyr", "tidyr" "wesanderson","WGCNA")
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager") BiocManager::install(bioc_deps) install.packages(cran_deps)
BiocManager::install("proBatch")
#install.packages("devtools") devtools::install_github("symbioticMe/proBatch", build_vignettes = TRUE)
require(dplyr) require(tibble) require(ggplot2)
```

```{r PrInCE}
#https://bioconductor.org/packages/release/bioc/vignettes/PrInCE/inst/doc/intro-to-prince.html
BiocManager::install("PrInCE")
library(PrInCE)
data(scott)
PrInCE(scott, gold_standard)

library(r2d3)
bars <- c(10, 20, 30)
```

```{r PoTRA}
#https://bioconductor.org/packages/release/bioc/vignettes/PoTRA/inst/doc/PoTRA.html
BiocManager::install("PoTRA")
library(PoTRA)
library(repmis)
options(warn=-1)
library(BiocGenerics)
library(graph)
library(graphite)
library(igraph)
source_data("https://github.com/GenomicsPrograms/example_data/raw/master/PoTRA-vignette.RData")
humanKEGG <- pathways("hsapiens", "kegg")
Pathway.database = humanKEGG
results.KEGG <- PoTRA.corN(mydata=mydata, genelist=genelist, Num.sample.normal=113, Num.sample.case=113, Pathway.database=Pathway.database[1:15], PR.quantile=PR.quantile)
names(results.KEGG)
head(results.KEGG$Fishertest.p.value)

```
```{r PCAtools}
#https://bioconductor.org/packages/release/bioc/vignettes/PCAtools/inst/doc/PCAtools.html
devtools::install_github('kevinblighe/PCAtools')
library(PCAtools)
  p <- pca(x, metadata = metadata, removeVar = 0.1)
```

```{r pathwayPCA}
#https://github.com/gabrielodom/pathwayPCA
#install.packages("BiocManager")
BiocManager::install("pathwayPCA")

```

```{r animalcules}
#https://bioconductor.org/packages/release/bioc/vignettes/animalcules/inst/doc/animalcules.html
BiocManager::install("animalcules")
library(animalcules)

```

```{r AMARETTO}
#https://bioconductor.org/packages/release/bioc/vignettes/AMARETTO/inst/doc/amaretto.pdf
#https://github.com/gevaertlab/AMARETTO
BiocManager::install("AMARETTO")

```

```{r VCFArray}
#https://bioconductor.org/packages/release/bioc/vignettes/VCFArray/inst/doc/VCFArray.html
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
#The development version is also available to download from Github.
install.packages("remotes")
BiocManager::install("Bioconductor/VCFArray")
library(VCFArray)
```


```{r survtype}
#https://bioconductor.org/packages/release/bioc/vignettes/survtype/inst/doc/survtype.html
BiocManager::install("survtype")
library(survtype)
data(lung)
lung.survtype <- Surv.survtype(lung, time = "time", status = "status")
plot.survtype(lung.survtype, pval = TRUE)
```

```{r SubCellBarCode}
#https://bioconductor.org/packages/release/bioc/vignettes/SubCellBarCode/inst/doc/SubCellBarCode.html
BiocManager::install("SubCellBarCode")
library(SubCellBarCode)
head(markerProteins)
```

```{r StructuralVariantAnnotation}
#https://bioconductor.org/packages/release/bioc/vignettes/StructuralVariantAnnotation/inst/doc/vignettes.html
BiocManager::install("StructuralVariantAnnotation")
suppressPackageStartupMessages(require(StructuralVariantAnnotation))
suppressPackageStartupMessages(require(VariantAnnotation))
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- VariantAnnotation::readVcf(vcf.file, "hg19")
gr <- breakpointRanges(vcf)
partner(gr)

```

```{r SMAD}
#https://bioconductor.org/packages/release/bioc/vignettes/SMAD/inst/doc/quickstart.html
#BiocManager::install("SMAD")
library(SMAD)
data("TestDatInput")
head(TestDatInput)

scoreCompPASS <- CompPASS(TestDatInput)
head(scoreCompPASS)

scoreHG <- HG(TestDatInput)
head(scoreHG)

```

```{r RepViz}
#https://bioconductor.org/packages/release/bioc/vignettes/RepViz/inst/doc/RepViz.html
BiocManager::install("RepViz")
file.copy(from = list.files(system.file("extdata", package = "RepViz"), full.names = TRUE),to = tempdir())
setwd(tempdir())
region <- GRanges("chr12:110938000-110940000")
```

```{r qckitfastq}
#https://bioconductor.org/packages/release/bioc/vignettes/qckitfastq/inst/doc/vignette-qckitfastq.pdf
#BiocManager::install("qckitfastq")
library(qckitfastq)
infile <- system.file("extdata", "10^5_reads_test.fq.gz", package = "qckitfastq") fseq <- seqTools::fastqq(infile)
read_len <- read_length(fseq)
kable(head(read_len)) %>% kable_styling()
```

```{r projectR}
#https://bioconductor.org/packages/release/bioc/vignettes/projectR/inst/doc/projectR.pdf
BiocManager::install("projectR")
library(projectR)
projectR(data, loadings, dataNames=NULL, loadingsNames=NULL, NP = NULL, full = false)
```

```{r NLME}
library(nlme)
data(Loblolly)
fm1 <- nlsList(SSasymp, Loblolly)
fm1
fm2 <- nlme(fm1, random = Asym ~ 1)
fm2
q()
### Helical Valley Function
### Page 362 Dennis + Schnabel

require(stats); require(graphics)

theta <- function(x1,x2) (atan(x2/x1) + (if(x1 <= 0) pi else 0))/ (2*pi)
## but this is easier :
theta <- function(x1,x2) atan2(x2, x1)/(2*pi)

f <- function(x) {
    f1 <- 10*(x[3] - 10*theta(x[1],x[2]))
    f2 <- 10*(sqrt(x[1]^2+x[2]^2)-1)
    f3 <- x[3]
    return(f1^2+f2^2+f3^2)
}

## explore surface {at x3 = 0}
x <- seq(-1, 2, length.out=50)
y <- seq(-1, 1, length.out=50)
z <- apply(as.matrix(expand.grid(x, y)), 1, function(x) f(c(x, 0)))
contour(x, y, matrix(log10(z), 50, 50))
str(nlm.f <- nlm(f, c(-1,0,0), hessian = TRUE))
points(rbind(nlm.f$estim[1:2]), col = "red", pch = 20)

### the Rosenbrock banana valley function

fR <- function(x)
{
    x1 <- x[1]; x2 <- x[2]
    100*(x2 - x1*x1)^2 + (1-x1)^2
}

## explore surface
fx <- function(x)
{   ## `vectorized' version of fR()
    x1 <- x[,1]; x2 <- x[,2]
    100*(x2 - x1*x1)^2 + (1-x1)^2
}
x <- seq(-2, 2, length.out=100)
y <- seq(-0.5, 1.5, length.out=100)
z <- fx(expand.grid(x, y))
op <- par(mfrow = c(2,1), mar = 0.1 + c(3,3,0,0))
contour(x, y, matrix(log10(z), length(x)))

str(nlm.f2 <- nlm(fR, c(-1.2, 1), hessian = TRUE))
points(rbind(nlm.f2$estim[1:2]), col = "red", pch = 20)

## Zoom in :
rect(0.9, 0.9, 1.1, 1.1, border = "orange", lwd = 2)
x <- y <- seq(0.9, 1.1, length.out=100)
z <- fx(expand.grid(x, y))
contour(x, y, matrix(log10(z), length(x)))
mtext("zoomed in");box(col = "orange")
points(rbind(nlm.f2$estim[1:2]), col = "red", pch = 20)
par(op)


fg <- function(x)
{
    gr <- function(x1, x2) {
        c(-400*x1*(x2 - x1*x1)-2*(1-x1), 200*(x2 - x1*x1))
    }
    x1 <- x[1]; x2 <- x[2]
    res<- 100*(x2 - x1*x1)^2 + (1-x1)^2
    attr(res, "gradient") <- gr(x1, x2)
    return(res)
}

nlm(fg, c(-1.2, 1), hessian = TRUE)

## or use deriv to find the derivatives

fd <- deriv(~ 100*(x2 - x1*x1)^2 + (1-x1)^2, c("x1", "x2"))
fdd <- function(x1, x2) {}
body(fdd) <- fd
nlm(function(x) fdd(x[1], x[2]), c(-1.2,1), hessian = TRUE)


fgh <- function(x)
{
    gr <- function(x1, x2)
        c(-400*x1*(x2 - x1*x1) - 2*(1-x1), 200*(x2 - x1*x1))
    h <- function(x1, x2) {
        a11 <- 2 - 400*x2 + 1200*x1*x1
        a21 <- -400*x1
        matrix(c(a11, a21, a21, 200), 2, 2)
    }
    x1 <- x[1]; x2 <- x[2]
    res<- 100*(x2 - x1*x1)^2 + (1-x1)^2
    attr(res, "gradient") <- gr(x1, x2)
    attr(res, "hessian") <- h(x1, x2)
    return(res)
}

nlm(fgh, c(-1.2,1), hessian = TRUE)
```


```{d3 data=bars, options=list(color = 'orange')}
svg.selectAll('rect')
  .data(data)
  .enter()
    .append('rect')
      .attr('width', function(d) { return d * 10; })
      .attr('height', '20px')
      .attr('y', function(d, i) { return i * 22; })
      .attr('fill', options.color);
```

```{r data, echo = FALSE}
scriptD <- 'C:\\Users\\animeshs\\Desktop\\scripts\\'
inpD <-'L:\\promec\\Elite\\LARS\\2014\\desember\\christiano\\'
data <- read.delim(paste0(inpD,"proteinGroups.txt"),row.names=1,sep="\t",header = T)
summary(data)
decoyPrefix="REV"
contaminantPrefix="CON"
dataC="LFQ.intensity."
library(nlme)

options(digits=4) # avoid rounding differences

Ovary[c(1,272), 2] <- NA
fm1 <- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare), na.action=na.exclude)
fitted(fm1)
residuals(fm1)
summary(fm1)

Orthodont[100:102, 2] <- NA
fm2 <- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1,
           na.action=na.exclude)
fitted(fm2, 0:1)
fitted(fm2)
residuals(fm2, 0:1)
round(residuals(fm2), 2)
summary(fm2)

Soybean[1:5, "Time"] <- NA
fm3 <- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean,
            weights = varPower(), na.action=na.exclude)
fitted(fm3)
residuals(fm3)
summary(fm3)
```

```{r ROTS, echo = FALSE}
#install.packages("BiocManager")
#BiocManager::install("ROTS", version = "3.8")
BiocManager::install("ROTS")
dataNormImpCom[is.na(dataNormImpCom)]=5
summary(dataNormImpCom)
library(ROTS)
data(upsSpikeIn)
input = upsSpikeIn
groups = c(rep(0,3), rep(1,3))
groups
results = ROTS(data = input, groups = groups , B = 100 , K = 500 , seed = 1234)
names(results)
summary(results, fdr = 0.05)
plot(results, fdr = 0.2, type = "volcano")
#plot(results, fdr = 0.05, type = "heatmap")
```

```{r reticulate, echo = FALSE}
#https://rviews.rstudio.com/2019/03/18/the-reticulate-package-solves-the-hardest-problem-in-data-science-people/
install.packages('mlbench') #provides the data set
library(mlbench) #provides the data set
data("BreastCancer")
#convert to numeric for models and remove na values for this example
install.packages('xgboost')
library(xgboost)

model_set <- sapply(BreastCancer[complete.cases(BreastCancer),-1], as.numeric)

#format target variable as 0, 1 instead of 1,2
model_set[,10]<-model_set[,10]-1

#Split into test and train sets
indices <- sample(1:nrow(model_set), size = 0.7 * nrow(model_set))

#Target variables
target<-unlist(model_set[indices,10])
test_target<-unlist(model_set[-indices,10])

#create unscaled data set for boosted tree models
unscale_train<-as.matrix(model_set[indices,-10])
unscale_test<-as.matrix(model_set[-indices,-10 ])

#create normalized data set for neural network
mean <- apply(model_set[indices,-10], 2, mean)
std <- apply(model_set[indices,-10], 2, sd)

train <- scale(model_set[indices,-10], center = mean, scale = std)
test <- scale(model_set[-indices,-10], center = mean, scale = std)

boost_model<-xgboost(data = unscale_train,label=target,booster="gbtree", nfold = 2,nrounds = 25, verbose = FALSE, objective = "binary:logistic", eval_metric = "auc", nthread = 4)

install.packages('dplyr')
library(dplyr)

install.packages('keras')
library(keras)
y_target<-to_categorical(target,2)

tf_nn <- keras_model_sequential() %>%
  layer_dense(units = 12,
              activation = 'relu',
              input_shape = dim(train)[[2]]) %>%
  layer_dropout(rate = 0.4) %>%
  layer_dense(units = 12,
              activation = 'relu')%>%
  layer_dropout(rate = 0.3) %>%
  layer_dense(units = 2,
              activation = 'softmax')


tf_nn %>% compile(
  optimizer = optimizer_rmsprop(),
  loss = "categorical_crossentropy",
  metrics = c("accuracy")
)

history<-tf_nn %>% fit(
  x=train,
  y=y_target,
  epochs = 7,
  batch_size = 12
)

```

```{r stan, echo = FALSE}
library('rstan')
stan(paste0(scriptD,'school8.stan'))
```


```{r tmp, echo = FALSE}
frac $\frac{1}{n}$
memory.size(TRUE)
memory.limit()
rm(list=ls())
```

```{r python, echo = FALSE}
#install.packages('reticulate')
#install.packages("reticulate")
#devtools::install_github("rstudio/reticulate")
#library('reticulate')
#Sys.which("python")
devtools::install_github("rstudio/reticulate")
```

```{r d3, echo = FALSE}
#install.packages('devtools')
#devtools::install_github("rstudio/r2d3")
library(r2d3)
r2d3(data=c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20), script = "barchart.js")
a=c(c(1,2) c(2,1))
dim(a)<-c(2,2)
(a)*t(a)
cov(a)
```



```{r shiny, echo = FALSE}
#https://rmarkdown.rstudio.com/authoring_shiny.html
#install.packages('shiny')
library(shiny)
dN_shiny <- dataNorm
#ctrl-shift-K
#rmarkdown::run
#shiny::renderUI
```

```{r slider, echo=FALSE}

inputPanel(
  sliderInput("bins", "#bins:", min = 1, max = 100, value = 30),
  textInput("dens", "Density:", "auto",value = 0.6),
  selectInput("expression", label = "Sample:",choices = colnames(dN_shiny), selected = colnames(dN_shiny)[1]))
renderText({paste("Inputs:", input$bins,input$dens,input$expression)})
```

```{r plot, echo = FALSE}
renderPlot({
  hist(dN_shiny[,as.numeric(which(colnames(dN_shiny) == input$expression))],breaks = as.numeric(input$bins),probability = TRUE,col="orange")
  lines(density(dN_shiny[,as.numeric(which(colnames(dN_shiny) == input$expression))], adjust = as.numeric(input$dens)),col="blue")
  })

```

```{r UWOT, echo = FALSE}
#devtools::load_all()
#install.packages('devtools')
#library('devtools')
#install_github("jlmelville/uwot")
library()
iris_umap <- umap(iris, n_neighbors = 50, learning_rate = 0.5, init = "random")

# Load mnist from somewhere, e.g.
# devtools::install_github("jlmelville/snedata")
# mnist <- snedata::download_mnist()
mnist_umap <- umap(mnist, n_neighbors = 15, min_dist = 0.001, verbose = TRUE)

# Use a specific number of threads
mnist_umap <- umap(mnist, n_neighbors = 15, min_dist = 0.001, verbose = TRUE, n_threads = 8)

# Use a different metric
mnist_umap_cosine <- umap(mnist ,n_neighbors = 15, metric = "cosine", min_dist = 0.001, verbose = TRUE, n_threads = 8)

# Supervised dimension reduction
mnist_umap_s <- umap(mnist, n_neighbors = 15, min_dist = 0.001, verbose = TRUE, n_threads = 8,
                     y = mnist$Label, target_weight = 0.5)

# Add new points to an existing embedding
mnist_train <- head(mnist, 60000)
mnist_test <- tail(mnist, 10000)

# You must set ret_model = TRUE to return extra data we need
# coordinates are in mnist_train_umap$embedding
mnist_train_umap <- umap(mnist_train, verbose = TRUE, ret_model = TRUE)
mnist_test_umap <- umap_transform(mnist_test, mnist_train_umap, verbose = TRUE)

# Save the nearest neighbor data
mnist_nn <- umap(mnist, ret_nn = TRUE)
# coordinates are now in mnist_nn$embedding

# Re-use the nearest neighor data and save a lot of time
mnist_nn_spca <- umap(mnist, nn_method = mnist_nn$nn, init = spca)

# No problem to have ret_nn = TRUE and ret_model = TRUE at the same time

# Calculate Petal and Sepal neighbors separately (uses intersection of the resulting sets):
iris_umap <- umap(iris, metric = list("euclidean" = c("Sepal.Length", "Sepal.Width"),
                                      "euclidean" = c("Petal.Length", "Petal.Width")))
# Can also use individual factor columns
iris_umap <- umap(iris, metric = list("euclidean" = c("Sepal.Length", "Sepal.Width"),
                                      "euclidean" = c("Petal.Length", "Petal.Width"),
                                      "categorical" = "Species"))

# MNIST with PCA reduction to 50 dimensions can speed up calculation without
# affecting results much
mnist_umap <- umap(mnist, pca = 50)

```


```{r clusterProfiler, echo = FALSE}
#BiocManager::install("STRINGdb")
library(STRINGdb)
string_db <- STRINGdb$new( version="11", species=9606,score_threshold=0, input_directory="" )
UniprotStrings<-as.data.frame(Uniprot)
example1_mapped <- string_db$map( UniprotStrings, "Uniprot", removeUnmappedRows = TRUE )
hits<-example1_mapped$STRING_id
enrichmentGO <- string_db$get_enrichment( hits, category = "Process", methodMT = "fdr", iea = TRUE )
enrichmentKEGG <- string_db$get_enrichment( hits, category = "KEGG", methodMT = "fdr", iea = TRUE )
head(enrichmentGO, n=7)
head(enrichmentKEGG, n=7)
```



```{r clusterProfiler, echo = FALSE}
install.packages('BiocManager')
BiocManager::install('goseq')
library(goseq)
supportedOrganisms()
#https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html
#source("https://bioconductor.org/biocLite.R")
## biocLite("BiocUpgrade") ## you may need this
#biocLite("clusterProfiler")
#biocLite("org.Hs.eg.db")
library("org.Hs.eg.db")
#install.packages("colorspace")
#devtools::install_github('cran/colorspace')
library("clusterProfiler")
Uniprot=data[data$`MCCAR Biol Rep 25 WSRT``NB4 Biol Rep 22 WSRT`<0.5,1]
dataSub=subset(data,`NB4 Biol Rep 22 WSRT`<0.3 & `MCCAR Biol Rep 25 WSRT`<0.3)
Uniprot<-sapply(strsplit(dataSub$`T: Majority protein IDs`,";"), `[`, 1)
enrichGO(gene=Uniprot,OrgDb=org.Hs.eg.db,keyType= 'UNIPROT',ont= "CC",pAdjustMethod = "BH",pvalueCutoff  = 0.01,qvalueCutoff  = 0.05)
UniprotEG<-bitr(Uniprot, fromType="UNIPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db")
UniprotKEGG<-bitr(Uniprot, fromType="UNIPROT", toType="KEGG", OrgDb="org.Hs.eg.db")
UniprotKEGG<-bitr_kegg(Uniprot, fromType='uniprot', toType='kegg', organism='hsa')
kk <- enrichKEGG(gene=UniprotEG$ENTREZID)
kk@result[["Description"]]
browseKEGG(kk,kk@result[["ID"]][1])
```


```{r installs}
install.packages(c("matrixStats", "Hmisc", "splines", "foreach", "doParallel", "fastcluster", "dynamicTreeCut", "survival"))
source("http://bioconductor.org/biocLite.R")
biocLite(c("GO.db", "preprocessCore", "impute"))
orgCodes = c("Hs", "Mm", "Rn", "Pf", "Sc", "Dm", "Bt", "Ce", "Cf", "Dr", "Gg");
orgExtensions = c(rep(".eg", 4), ".sgd", rep(".eg", 6));
packageNames = paste("org.", orgCodes, orgExtensions, ".db", sep="");

biocLite(c("GO.db", "KEGG.db", "topGO", packageNames, "hgu133a.db", "hgu95av2.db", "annotate", "hgu133plus2.db", "SNPlocs.Hsapiens.dbSNP.20100427", "minet", "OrderedList"))
install.packages("BiocManager")
BiocManager::install("WGCNA")
library(WGCNA);
allowWGCNAThreads()
```


```{r data}
femData <- read.csv("https://raw.githubusercontent.com/iamciera/10wgcna/master/examples/LiverFemale3600.csv")
names(femData)

#This is just melting the data without the first 8 columns or something
datExpr0 <- as.data.frame(t(femData[, -c(1:8)]))
names(datExpr0) = femData$substanceBXH
rownames(datExpr0) = names(femData)[-c(1:8)]

head(datExpr0[,1:8])

datExpr0 = as.data.frame(t(femData[, -c(1:8)]));
gsg = goodSamplesGenes(datExpr0, verbose = 3)
gsg$allOK
install.packages('flashClust')
library(flashClust)
sampleTree = flashClust(dist(datExpr0), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

net = blockwiseModules(datExpr0, power = 6,
                       TOMType = "unsigned", minModuleSize = 30,
                       reassignThreshold = 0, mergeCutHeight = 0.25,
                       numericLabels = TRUE, pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "femaleMouseTOM",
                       verbose = 3)
#https://jolars.github.io/eulerr/articles/venn-diagrams.html
install.packages('eulerr')
library(eulerr)
s4 <- list(a = c(1, 2, 3),
           b = c(1, 2),
           c = c(1, 4),
           e = c(5))
plot(venn(s4))
plot(euler(s4, shape = "ellipse"), quantities = TRUE)

#https://github.com/jolars/eulerr.co/blob/master/server.R

library(ggplot2)

#heatmap(data$Difference)
p <- ggplot(data,aes(Difference,X.Log.P.value.))
p<-p + geom_tile(aes(fill=X.Log.P.value.)) + scale_fill_gradient(low="white", high="darkblue") + xlab("") + ylab("")
f=paste(file,proc.time()[3],".jpg")
ggsave(filename=f, plot=p)
print(p)
data <- read.delim("Y:/felles/Voin/===Methodology paper===/Supplementary table Ttest BothSided Sample.txt",row.names=22,sep="\t",header = T)
data <- read.delim("Supplementary table Ttest BothSided",row.names=22,sep="\t",header = T)
summary(data)
```

```{r xplot}

library('ggplot2')
data[1,]
Significance=data$X.Log.P.value.>-log10(0.05)&abs(data$Difference)>log2(1.5)
sum(Significance)
dsub <- subset(data, data$X.Log.P.value.==max(data$X.Log.P.value.)|data$Difference==max(abs(data$Difference)))
dsub$Gene.names
plot(data$Difference,data$X.Log.P.value.)
qplot(Difference,X.Log.P.value.,data=data,color=X.Log.P.value.>-log10(0.05)&abs(Difference)>log2(1.5))
g = ggplot(data,aes(Difference,X.Log.P.value.))
gps<-g + geom_point(aes(color=Significance)) + theme_bw(base_size=10) + geom_text(data=dsub,aes(label=Gene.names),hjust=0, vjust=0) + xlab("Log2 Fold Change")  + ylab("-Log10 P-value") + ggtitle("Differentially expressed proteins") + scale_size_area()
p=paste(file,proc.time()[3],".jpg")
ggsave(filename=p, plot=gps)
```



```{r, echo=FALSE}
plot(log2(data$A549.Cis.1/100),log2(data$A549.Cis.2/100),col="#FF00FF",cex=0.5,pch=16,lty=1)
```

```{r sign-test}

set.seed(2016)
bio <- 3
prot <- nrow(data)
wilcox.test(data)
dataa549cis = t(data[,grepl( "^A549.Cis",names(data))])
dataa549cis[is.nan(dataa549cis)] <- NA
dataa549cis = t(c(-1,2,3,4,50))
results <- apply(dataa549cis, 1, function(dataa549cis) {
  wilcox.test(dataa549cis)$p.value})
results


results <- apply(dat, 1, function(dat) {
  wilcox.test(x = dat[1:x])$p.value})


results <- apply(data, 1, function(data) {
  wilcox.test(x = data[,grepl( "^A549.Cis",names(data))])$p.value})

results <- apply(data, 1, function(data) {
  wilcox.test(x = log2(data[,grepl( "^A549.Cis",names(data))])$p.value}))
results <- apply(data, 1, function(data) {
  wilcox.test(x=log2(data$A549.Cis.1/100))$p.value})
cbind(data, pvals = results)

hist(p.adjust(results,method="BH"))
hist(p.adjust(results,method="BH"))
hist(p.adjust(results,method="holm"))
?p.adjust
hist(results)
min(results)
data=read.delim("C:/Users//animeshs/Google Drive/wilcox_sgn_rnk_wiki.txt",row.names=1)
wilcox.test(data$x2,data$x1,paired = TRUE, alternative = "less")
wilcox.test(data$x2,data$x1,paired = TRUE, alternative = "greater")
wilcox.test(data$x2,data$x1,paired = TRUE)
wilcox.test(c(1,1,1,1,1))
0.5^4
wilcox.test((data$x2-data$x1))$pvalue
binom.test(3,3)
sum(data$sgn>0, na.rm=TRUE)
binom.test(1,3)
t.test(c(data$x1,data$x2),c(data$abs,data$abs))
t.test(extra ~ group, data = sleep)
wilcox.test(extra ~ group, data = sleep)


x <- 10; y <- 10; g <- 1000
mean(c(1,2,3))
set.seed(1969)
dat <- matrix(rnorm((x + y) * g), ncol = x + y)

results <- apply(dat, 1, function(dat) {
  wilcox.test(x = dat[1:x])$p.value})

cbind(dat, pvals = results)
hist(results,col="orange")
hist(p.adjust(results,method="BH"))

#write.csv2("Y:/felles/Voin/===Methodology paper===/Supplementary table WCSR_test.txt",results)
install.packages("rlm")
library(rlm)
?rlm
qqnorm(c(1,2,10,100))
?qqplot


install.packages("outliers")
library(outliers)
grubbs.test(c(10,20, 200))



```





```{r MSstat}
source("http://bioconductor.org/biocLite.R")
biocLite("MSstats")
library("MSstats")


```

```{r interactive}
#install.packages("shiny")
library(shiny)
runExample("01_hello")
```

```{r google}
install.packages("RGoogleAnalytics")
library("RGoogleAnalytics")
```

```{r googleVis}
#install.packages("googleVis")
#suppressPackageStartupMessages(library(googleVis))
#http://rpubs.com/gallery/googleVis
T <- gvisTable(Exports, options = list(width = 200, height = 280))
G <- gvisGeoChart(Exports, locationvar = "Country", colorvar = "Profit",
    options = list(width = 360, height = 280, dataMode = "regions"))
TG <- gvisMerge(T, G, horizontal = TRUE, tableOptions = "bgcolor=\"#CCCCCC\" cellspacing=10")

print(TG, "chart")
```

**check**
```{r Hurricane Andrew (1992) storm track with Google Maps}
AndrewMap <- gvisMap(Andrew, "LatLong", "Tip", options = list(showTip = TRUE,
    showLine = TRUE, enableScrollWheel = TRUE, mapType = "hybrid", useMapTypeControl = TRUE))

print(AndrewMap, "chart")
```

**check**
```{r fig.width=7, fig.height=6}
## Table with embedded links
PopTable <- gvisTable(Population, options = list(width = 600, height = 300,
    page = "enable"))

print(PopTable, "chart")
```


```{r data}
data <- read.delim("Y:/felles/PROTEOMICS and XRAY/Results/Kristian/a-GEIR/Figurer/Bakgrunnsmateriale/Table 1 og figur 3/20160417_tabell fra Perseus. Slettet RPS10p5.txt")
data <- read.delim("L:/Results//TObermann/data.txt")
summary(data)
d1<-read.delim('Y:/felles/PROTEOMICS and XRAY/Ani/misccb/d1.txt')
d2<-read.delim('Y:/felles/PROTEOMICS and XRAY/Ani/misccb/d2.txt')
summary(d1)
summary(d2)
d<-merge(d1,d2,by="ID",all=T)
summary(d)
library(plyr)
install.packages('plyr')
d<-merge(d1,d2)
d3<-d1
summary(d)
d<-merge(d1,d3,by="ID",all=T)
install.packages("profvis")

```


```{r ColumnSel}
IP0h<-data[, grep("^X.IP..0.h.....IP..PBS.....$", colnames(data))]
summary(IP0h)
heatmap(na.omit(as.matrix(IP0h)))
mapply(t.test,IP0h[,])
```

```{r model}
library('nlm')
plot(log(Fnorm) ~ log(Concentration), data=data)
yp=(max(data$Fnorm)-data$Fnorm)/(max(data$Fnorm)-min(data$Fnorm))
yq=1-yp
glm.out = glm(cbind(yp,yq) ~ log(data$Concentration), family=binomial(logit))
lines(log(data$Concentration), glm.out$fitted, type="l", col="red")
summary(glm.out)
source("http://bioconductor.org/biocLite.R")
biocLite("clusterProfiler")
library("clusterProfiler")
data(gcSample)
x <- groupGO(gene=gcSample[[1]],organism="human",ont="CC",level=2,readable=TRUE)
head(summary(x))
x
id=read.table("ListOfTWLUniprotNIFEIDtsv.txt")
x <- groupGO(gene=(as.character(as.matrix(id))),organism="human",ont="CC",level=4,readable=TRUE)
head(summary(x))
x <- groupGO(gene=(as.character(as.matrix(id))),organism="human",ont="CC",level=4,readable=TRUE)
head(summary(x))
page(summary(x))
plot(x)
dline <- read.table("res_line.txt")
resdataap <- read.table("ap.txt")
resdataapip <- read.table("apip.txt")
resdatafl <- read.table("fl.txt")

conc=c(resdataap$ConcPm,resdataapip$ConcPm,resdatafl$ConcPm)
lethal=c(resdataap$Ap,resdataapip$Ap_Ip,resdatafl$Fl)



x <- seq(0, 2000, length=201)
yap <- (dline$AP[1]*x+dline$AP[2])
yapip <- (dline$AP_IP[1]*x+dline$AP_IP[2])
yfl <- (dline$FL[1]*x+dline$FL[2])


plot(conc,lethal)
lines(x, yap, type = "l", col="red")
lines(x, yapip, type = "l", col="green")
lines(x, yfl, type = "l", col="blue")


write.table((cbind(c(x),c(yap))), file = "ap_otp.txt", sep = "\t",col.names = FALSE, row.names = FALSE )


write.table((cbind(c(x),c(yapip))), file = "apip_otp.txt", sep = "\t",col.names = FALSE, row.names = FALSE )

write.table((cbind(c(x),c(yfl))), file = "fl_otp.txt", sep = "\t",col.names = FALSE, row.names = FALSE )

map <- read.table("maplot.txt")
matplot(map)

x <- seq(0, 2000, length=201)
yap <- (dline$AP[1]*x+dline$AP[2])
plot(x, yap, type = "l", col="red")


plot.new()
line(dline$AP[2],dline$AP[1])

lmfit <- lm(Ap~ConcPm, data=resdataap, na.action=na.omit)
summary(lmfit)
plot(resdataap$ConcPm,resdataap$Ap)
abline(coef(lmfit))

lmfit <- lm(Ap_Ip~ConcPm, data=resdataapip, na.action=na.omit)
summary(lmfit)
plot(resdataapip$ConcPm,resdataapip$Ap_Ip)
abline(coef(lmfit))

lmfit <- lm(Fl~ConcPm, data=resdatafl, na.action=na.omit)
summary(lmfit)
plot(resdatafl$ConcPm,resdatafl$Fl)
abline(coef(lmfit))




resdataap$ApT <- resdataap$ConcPm/resdataap$Ap
lmfit <- lm(Ap~ConcPm, data=resdataap, na.action=na.omit)
plot(resdataap$ConcPm, resdataap$ApT)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Ap~Bm*ConcPm/(Kd+ConcPm),data=resdataap, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resdataap$ConcPm, resdataap$Ap)
x <- seq(0, 2000, length=10)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(ConcPm=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")



lmfit <- lm(Fl~Conc, data=resdata, na.action=na.omit)
summary(lmfit)
plot(resdata$Conc,resdata$Fl)
abline(coef(lmfit))






resapc3$Pbtrans <- resapc3$Pf/resapc3$Pb
lmfit <- lm(Pbtrans~Pf, data=resapc3, na.action=na.omit)
plot(resapc3$Pf, resapc3$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resapc3, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resapc3$Pf, resapc3$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")



resfl$Pbtrans <- resfl$Pf/resfl$Pb
lmfit <- lm(Pbtrans~Pf, data=resfl, na.action=na.omit)
plot(resfl$Pf, resfl$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resfl, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resfl$Pf, resfl$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")




resflc3$Pbtrans <- resflc3$Pf/resflc3$Pb
lmfit <- lm(Pbtrans~Pf, data=resflc3, na.action=na.omit)
plot(resflc3$Pf, resflc3$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resflc3, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resflc3$Pf, resflc3$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")




resm347$Pbtrans <- resm347$Pf/resm347$Pb
lmfit <- lm(Pbtrans~Pf, data=resm347, na.action=na.omit)
plot(resm347$Pf, resm347$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resm347, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resm347$Pf, resm347$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")





resm356$Pbtrans <- resm356$Pf/resm356$Pb
lmfit <- lm(Pbtrans~Pf, data=resm356, na.action=na.omit)
plot(resm356$Pf, resm356$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resm356, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resm356$Pf, resm356$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")



resdm$Pbtrans <- resdm$Pf/resdm$Pb
lmfit <- lm(Pbtrans~Pf, data=resdm, na.action=na.omit)
plot(resdm$Pf, resdm$Pbtrans)
abline(coef(lmfit))
Bm <- 1/coef(lmfit)[2]
Kd <- Bm*coef(lmfit)[1]
Bm
Kd
nlsfit <- nls(Pb~Bm*Pf/(Kd+Pf),data=resdm, start=list(Kd=Kd, Bm=Bm))
summary(nlsfit)
plot(resdm$Pf, resdm$Pb)
x <- seq(0, 60, length=120)
y2 <- (coef(nlsfit)["Bm"]*x)/(coef(nlsfit)["Kd"]+x)
y2 <- predict(nlsfit,data.frame(conc=x))
lines(x, y2)
y1 <- (Bm*x)/(Kd+x)
lines(x, y1, lty="dotted", col="red")








t.test((resap$Pb/(resap$Pb+resap$Pf)),(resfl$Pb/(resfl$Pb+resfl$Pf)))
t.test((resap$Pb/(resap$Pb+resap$Pf)),(resm347$Pb/(resm347$Pb+resm347$Pf)))
t.test((resap$Pb/(resap$Pb+resap$Pf)),(resm356$Pb/(resm356$Pb+resm356$Pf)))
t.test((resap$Pb/(resap$Pb+resap$Pf)),(resdm$Pb/(resdm$Pb+resdm$Pf)))

t.test((resfl$Pb/(resfl$Pb+resfl$Pf)),(resm347$Pb/(resm347$Pb+resm347$Pf)))
t.test((resfl$Pb/(resfl$Pb+resfl$Pf)),(resm356$Pb/(resm356$Pb+resm356$Pf)))
t.test((resfl$Pb/(resfl$Pb+resfl$Pf)),(resdm$Pb/(resdm$Pb+resdm$Pf)))

t.test((resm347$Pb/(resm347$Pb+resm347$Pf)),(resm356$Pb/(resm356$Pb+resm356$Pf)))
t.test((resm347$Pb/(resm347$Pb+resm347$Pf)),(resdm$Pb/(resdm$Pb+resdm$Pf)))

t.test((resm356$Pb/(resm356$Pb+resm356$Pf)),(resdm$Pb/(resdm$Pb+resdm$Pf)))




names(lmfit)
summary(lmfit)
plot(lmfit)
class(lmfit)
coef(lmfit)



p = res1$WT
q = res1$WT_347
r = res1$WT_356
s = res1$WT_347_356
scores = data.frame(p,q,r,s)
boxplot(scores)
scores = stack(scores)
names(scores)
oneway.test(values ~ ind, data=scores, var.equal=T)
```


```{r VennDetail}
#https://bioconductor.org/packages/release/bioc/vignettes/VennDetail/inst/doc/VennDetail.html
#install.packages('BiocManager')
#BiocManager::install("VennDetail")
library(VennDetail)
#ven <- venndetail(list(dat=dataClean$Majority.protein.IDs,daf=df.prot$Majority.protein.IDs))
#plot(ven)
#head(dataNorm$LFQ.intensity.15+dataNorm$LFQ.intensity.12)
#ven <- venndetail(list(Red = dataNorm$LFQ.intensity.19+dataNorm$LFQ.intensity.26+dataNorm$LFQ.intensity.29, White = dataNorm$LFQ.intensity.15+dataNorm$LFQ.intensity.12+dataNorm$LFQ.intensity.30))
ven <- venndetail(list(Red = dataNormFilter$Red, White = dataNormFilter$White))
#ven <- venndetail(dataNorm)
plot(ven)
plot(ven, type = "vennpie")
```
#https://jokergoo.github.io/2020/05/31/word-cloud-as-heatmap-annotation/
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script>
$(document).ready(function(){
	$("pre").not(".r").prepend("<input class='switch_hljs' type='button' value='show/hide output' />");
	$(".switch_hljs").next().hide();
	$(".switch_hljs").click(function() {
		$(this).next().toggle();
	})
});
</script>

/* instruction set  addc, subc, loadc   -- (accumulator,constant)   add , sub , load , store  -- (accumulator,addresses)  jumpEQ, jumpLE,...      -- branch to locn by comparing						 accumulator contents to zero.   jump        -- unconditional branch to locn  ...Final assembler code is sequence of instr(op) or instr(op,arg), mixedwith label(V) statements. The sequence is obtained only by dfstraversal of ';' tree?  */% There are predicates to encode statement, arithm.expression, test.%encodestmt(+parseTree, +symbolTable{a.k.a. dictionary}, -assemblyCode)%encodeexpr(+parseTree, + symbolTable, -assemblyCode leaving value in register)%encodetest( , ,-variable L,-assembly code ending in "instr(jumpxx, L)" if xx is false on the accumulator)encodeexpr( name(Id),D,Code) :- lookup(Id,D,Locn),Code=instr(load,Locn).encodestmt( assign(name(X),Expr) , D , (Exprcode ; instr(store,Addr) )  ) :-    encodeexpr(Expr,D,Exprcode),      lookup(X,D,Addr).encodestmt( if(Test,Then,Else) , D ,             (Testcode ;              Thencode ;              instr(jump, L2) ;              label(L1) ;              Elsecode ;              label(L2) )   ):-    encodetest(Test,D,L1,Testcode),    encodestmt(Then,D,Thencode),    encodestmt(Else,D,Elsecode).%encodetest(+parseTree, +dict , +forward jump label, -assemblyCode)encodetest(test(Op,Arg1,Arg2), D, Label,             (Exprcode ;               instr(Jumpif,Label) )  ):-    encodeexpr(expr(-,Arg1,Arg2),D,Exprcode),    unlessop(Op,Jumpif).unlessop(=,jumpne). unlessop(<,jumpge).  %%and so on  
#! ===========================================
#! NEST Topology Module: A Case-Based Tutorial
#! ===========================================
#!
#! :Author: Hans Ekkehard Plesser
#! :Institution: Norwegian University of Life Sciences, Simula
#!               Research Laboratory, RIKEN Brain Sciences Institute
#! :Version: 0.2
#! :Date: 13 August 2009
#! :Copyright: The NEST Initiative (2009)
#! :License: Creative Commons Attribution License
#!
#! **NOTE:** The network generated by this script does generates
#! dyanamics in which the activity of the entire system, especially
#! Rp and Vp oscillates with approx 5 Hz. This is different from
#! the full model. Deviations are due to the different model type
#! and the elimination of a number of connections, with no changes
#! to the weights.
#! 
#! Introduction
#! ============
#! 
#! This tutorial shows you how to implement a simplified version of the
#! Hill-Tononi model of the early visual pathway using the NEST Topology
#! module.  The model is described in the paper
#! 
#!   S. L. Hill and G. Tononi.
#!   Modeling Sleep and Wakefulness in the Thalamocortical System.
#!   J Neurophysiology **93**:1671-1698 (2005).
#!   Freely available via `doi 10.1152/jn.00915.2004
#!   <http://dx.doi.org/10.1152/jn.00915.2004>`_.
#! 
#! We simplify the model somewhat both to keep this tutorial a bit
#! shorter, and because some details of the Hill-Tononi model are not
#! currently supported by NEST. Simplifications include:
#! 
#! 1. We use the ``iaf_cond_alpha`` neuron model, which is 
#!    simpler than the Hill-Tononi model.
#! 
#! #. As the ``iaf_cond_alpha`` neuron model only supports two
#!    synapses (labeled "ex" and "in"), we only include AMPA and
#!    GABA_A synapses.
#!
#! #. We ignore the secondary pathway (Ts, Rs, Vs), since it adds just
#!    more of the same from a technical point of view.
#!
#! #. Synaptic delays follow a Gaussian distribution in the HT
#!    model. This implies actually a Gaussian distributions clipped at
#!    some small, non-zero delay, since delays must be
#!    positive. Currently, there is a bug in the Topology module when
#!    using clipped Gaussian distribution. We therefore draw delays from a
#!    uniform distribution.
#!
#! #. Some further adaptations are given at the appropriate locations in 
#!    the script.
#!
#! This tutorial is divided in the following sections:
#!
#! Philosophy_
#!    Discusses the philosophy applied to model implementation in this
#!    tutorial
#!
#! Preparations_
#!    Neccessary steps to use NEST and the Topology Module
#!
#! `Configurable Parameters`_
#!    Define adjustable network parameters
#!
#! `Neuron Models`_
#!    Define the neuron models needed by the network model
#!
#! Populations_
#!    Create Populations
#!
#! `Synapse models`_
#!    Define the synapse models used in the network model
#!
#! Connections_
#!    Create Connections
#!
#! `Example simulation`_
#!    Perform a small simulation for illustration. This 
#!    section also discusses the setup for recording.

#! Philosophy
#! ==========

#! A network models has two essential components: *populations* and
#! *projections*.  We first use NEST's ``CopyModel()`` mechanism to
#! create specific models for all populations and subpopulations in
#! the network, and then create the populations using the Topology
#! modules ``CreateLayer()`` function.
#!
#! We use a two-stage process to create the connections, mainly
#! because the same configurations are required for a number of
#! projections: we first define dictionaries specifying the
#! connections, then apply these dictionaries later.
#!
#! The way in which we declare the network model here is an
#! example. You should not consider it the last word: we expect to see
#! a significant development in strategies and tools for network
#! descriptions in the future. The following contributions to CNS\*09
#! seem particularly interesting
#!
#! - Ralf Ansorg & Lars Schwabe. Declarative model description and
#!   code generation for hybrid individual- and population-based
#!   simulations of the early visual system (P57);
#! - Sharon Crook, R. Angus Silver, & Padraig Gleeson. Describing
#!   and exchanging models of neurons and neuronal networks with
#!   NeuroML (F1);
#! 
#! as well as the following paper which will apply in PLoS
#! Computational Biology shortly:
#!
#! - Eilen Nordlie, Marc-Oliver Gewaltig, & Hans Ekkehard Plesser.
#!   Towards reproducible descriptions of neuronal network models.

#! Preparations
#! ============

#! Ensure that we load NEST modules from the right place. You will not
#! need this if you installed NEST in the standard location
#! ``/usr/local`` or if your ``PYTHONPATH`` is set correctly.
import sys
sys.path = ["/Users/plesser/NEST/code/trunk/ins/lib/python2.5/site-packages"] + sys.path

#! Load pynest
import nest

#! Load NEST Topoplogy module, as of nest 1.9.r8375
import nest.topology as topo

#! Make sure we start with a clean slate, even if we re-run the script
#! in the same Python session. 
nest.ResetKernel()

#! Import math, we need Pi
import math

#! We want to plot below, too. We need to import pylab (not ``matplotlib.plt``),
#! since `pyreport <http://gael-varoquaux.info/computers/pyreport/>`_ otherwise 
#! does not capture plot output. 
import pylab

print """You may have to close figure windows manually, otherwise they may block the script."""

#! Configurable Parameters
#! =======================
#!
#! Here we define those parameters that we take to be
#! configurable. The choice of configurable parameters is obviously
#! arbitrary, and in practice one would have far more configurable
#! parameters. We restrict ourselves to:
#! 
#! - Network size in neurons ``N``, each layer is ``N x N``.
#! - Network size in subtended visual angle ``visSize``, in degree.
#! - Temporal frequency of drifting grating input ``f_dg``, in Hz.
#! - Spatial wavelength and direction of drifting grating input,
#!   ``lambda_dg`` and ``phi_dg``, in degree/radian.
#! - Background firing rate of retinal nodes and modulation amplitude,
#!   ``retDC`` and ``retAC``, in Hz.
#! - Simulation duration ``simtime``; actual simulation is split into
#!   intervals of ``sim_interval`` length, so that the network state
#!   can be visualized in those intervals. Times are in ms. 
Params = {'N'           :     40,
          'visSize'     :    8.0,
          'f_dg'        :    2.0,
          'lambda_dg'   :    2.0,
          'phi_dg'      :    0.0,
          'retDC'       :   30.0,
          'retAC'       :   30.0,
          'simtime'     : 100.0,
          'sim_interval':   5.0
          }

#! Neuron Models
#! =============
#!
#! We declare models in two steps:
#!
#! 1. We define a dictionary specifying the NEST neuron model to use
#!    as well as the parameters for that model.
#! #. We create three copies of this dictionary with parameters
#!    adjusted to the three model variants specified in Table~2 of
#!    Hill & Tononi (2005) (cortical excitatory, cortical inhibitory,
#!    thalamic)
#! 
#! In addition, we declare the models for the stimulation and
#! recording devices.
#!
#! The general neuron model
#! ------------------------
#!
#! We use the ``iaf_cond_alpha`` neuron, which is an
#! integrate-and-fire neuron with two conductance-based synapses which
#! have alpha-function time course.  Any input with positive weights
#! will automatically directed to the synapse labeled ``_ex``, any
#! with negative weights to the synapes labeled ``_in``.  We define
#! **all** parameters explicitly here, so that no information is
#! hidden in the model definition in NEST. ``V_m`` is the membrane
#! potential to which the model neurons will be initialized.
#! The model equations and parameters for the Hill-Tononi neuron model
#! are given on pp. 1677f and Tables 2 and 3 in that paper. Note some
#! peculiarities and adjustments:
#!
#! - Hill & Tononi specify their model in terms of the membrane time
#!   constant, while the ``iaf_cond_alpha`` model is based on the
#!   membrane capcitance. Interestingly, conducantces are unitless in
#!   the H&T model. We thus can use the time constant directly as
#!   membrane capacitance.
#! - The model includes sodium and potassium leak conductances. We
#!   combine these into a single one as follows:
#$   \begin{equation}-g_{NaL}(V-E_{Na}) - g_{KL}(V-E_K) 
#$      =
#$   -(g_{NaL}+g_{KL})\left(V-\frac{g_{NaL}E_{NaL}+g_{KL}E_K}{g_{NaL}g_{KL}}\right)
#$   \end{equation}
#! - We write the resulting expressions for g_L and E_L explicitly
#!   below, to avoid errors in copying from our pocket calculator.
#! - The paper gives a range of 1.0-1.85 for g_{KL}, we choose 1.5
#!   here.
#! - The Hill-Tononi model has no explicit reset or refractory
#!   time. We arbitrarily set V_reset and t_ref.
#! - The paper uses double exponential time courses for the synaptic
#!   conductances, with separate time constants for the rising and
#!   fallings flanks. Alpha functions have only a single time
#!   constant: we use twice the rising time constant given by Hill and
#!   Tononi.
#! - In the general model below, we use the values for the cortical
#!   excitatory cells as defaults. Values will then be adapted below.
#!
nest.CopyModel('iaf_cond_alpha', 'NeuronModel',
               params = {'C_m'       :  16.0,
                         'E_L'       : (0.2 * 30.0 + 1.5 * -90.0)/(0.2 + 1.5),
                         'g_L'       : 0.2 + 1.5, 
                         'E_ex'      :   0.0,
                         'E_in'      : -70.0,
                         'V_reset'   : -60.0,
                         'V_th'      : -51.0,
                         't_ref'     :   2.0,
                         'tau_syn_ex':   1.0,
                         'tau_syn_in':   2.0,
                         'I_e'       :   0.0,
                         'V_m'       : -70.0})

#! Adaptation of models for different populations
#! ----------------------------------------------

#! We must copy the `NeuronModel` dictionary explicitly, otherwise
#! Python would just create a reference.

#! Cortical excitatory cells 
#! .........................
#! Parameters are the same as above, so we need not adapt anything
nest.CopyModel('NeuronModel', 'CtxExNeuron')

#! Cortical inhibitory cells 
#! .........................
nest.CopyModel('NeuronModel', 'CtxInNeuron', 
               params = {'C_m'  :   8.0,
                         'V_th' : -53.0,
                         't_ref':   1.0})

#! Thalamic cells 
#! ..............
nest.CopyModel('NeuronModel', 'ThalamicNeuron', 
               params = {'C_m'  :   8.0,
                         'V_th' : -53.0,
                         't_ref':   1.0,
                         'E_in' : -80.0})

#! Input generating nodes
#! ----------------------

#! Input is generated by sinusoidally modulate Poisson generators,
#! organized in a square layer of retina nodes. These nodes require a
#! slightly more complicated initialization than all other elements of
#! the network:
#!
#! - Average firing rate ``DC``, firing rate modulation depth ``AC``, and
#!   temporal modulation frequency ``Freq`` are the same for all retinal
#!   nodes and are set directly below.
#! - The temporal phase ``Phi`` of each node depends on its position in
#!   the grating and can only be assigned after the retinal layer has
#!   been created. We therefore specify a function for initalizing the
#!   phase ``Phi``. This function will be called for each node.
def phiInit(pos, lam, alpha):
    '''Initializer function for phase of drifting grating nodes.

       pos  : position (x,y) of node, in degree
       lam  : wavelength of grating, in degree
       alpha: angle of grating in radian, zero is horizontal

       Returns number to be used as phase of AC Poisson generator.
    '''
    return 2.0 * math.pi / lam * (math.cos(alpha) * pos[0] + math.sin(alpha) * pos[1]) 

nest.CopyModel('smp_generator', 'RetinaNode',
               params = {'ac'    : Params['retAC'],
                         'dc'    : Params['retDC'],
                         'freq'  : Params['f_dg'],
                         'phi'   : 0.0})

#! Recording nodes
#! ---------------

#! We use the new ``multimeter`` device for recording from the model
#! neurons. At present, ``iaf_cond_alpha`` is one of few models
#! supporting ``multimeter`` recording.  Support for more models will
#! be added soon; until then, you need to use ``voltmeter`` to record
#! from other models.
#!
#! We configure multimeter to record membrane potential to membrane
#! potential at certain intervals to memory only. We record the GID of
#! the recorded neurons, but not the time.
nest.CopyModel('multimeter', 'RecordingNode',
               params = {'interval'   : Params['sim_interval'],
                         'record_from': ['V_m'],
                         'record_to'  : ['memory'],
                         'withgid'    : True,
                         'withpath'   : False,
                         'withtime'   : False})


#! Populations
#! ===========

#! We now create the neuron populations in the model, again in the
#! form of Python dictionaries. We define them in order from eye via
#! thalamus to cortex.
#!
#! We first define a dictionary defining common properties for all
#! populations
layerProps = {'rows'     : Params['N'], 
              'columns'  : Params['N'],
              'extent'   : [Params['visSize'], Params['visSize']],
              'edge_wrap': True}
#! This dictionary does not yet specify the elements to put into the
#! layer, since they will differ from layer to layer. We will add them
#! below by updating the ``'elements'`` dictionary entry for each
#! population.

#! Retina
#! ------
layerProps.update({'elements': 'RetinaNode'})
retina = topo.CreateLayer(layerProps)

#! Now set phases of retinal oscillators; we use a list comprehension instead
#! of a loop.
[nest.SetStatus([n], {"phi": phiInit(topo.GetPosition([n])[0], 
                                      Params["lambda_dg"],
                                      Params["phi_dg"])})
 for n in nest.GetLeaves(retina)[0]]

#! Thalamus
#! --------

#! We first introduce specific neuron models for the thalamic relay
#! cells and interneurons. These have identical properties, but by
#! treating them as different models, we can address them specifically
#! when building connections.
#!
#! We use a list comprehension to do the model copies.
[nest.CopyModel('ThalamicNeuron', SpecificModel) for SpecificModel in ('TpRelay', 'TpInter')]

#! Now we can create the layer, with one relay cell and one
#! interneuron per location:
layerProps.update({'elements': ['TpRelay', 'TpInter']})
Tp = topo.CreateLayer(layerProps)

#! Reticular nucleus
#! -----------------
#! We follow the same approach as above, even though we have only a
#! single neuron in each location.
[nest.CopyModel('ThalamicNeuron', SpecificModel) for SpecificModel in ('RpNeuron',)]
layerProps.update({'elements': 'RpNeuron'})
Rp = topo.CreateLayer(layerProps)

#! Primary visual cortex
#! ---------------------

#! We follow again the same approach. We differentiate neuron types
#! between layers and between pyramidal cells and interneurons. At
#! each location, there are two pyramidal cells and one interneuron in
#! each of layers 2-3, 4, and 5-6. Finally, we need to differentiate
#! between vertically and horizontally tuned populations. When creating
#! the populations, we create the vertically and the horizontally
#! tuned populations as separate populations.

#! We use list comprehesions to create all neuron types:
[nest.CopyModel('CtxExNeuron', layer+'pyr') for layer in ('L23','L4','L56')]
[nest.CopyModel('CtxInNeuron', layer+'in' ) for layer in ('L23','L4','L56')]

#! Now we can create the populations, suffixes h and v indicate tuning
layerProps.update({'elements': [['L23pyr', 2, 'L23in', 1],
                                ['L4pyr' , 2, 'L4in' , 1],
                                ['L56pyr', 2, 'L56in', 1]]})
Vp_h = topo.CreateLayer(layerProps)
Vp_v = topo.CreateLayer(layerProps)

#! Collect all populations
#! -----------------------

#! For reference purposes, e.g., printing, we collect all populations
#! in a tuple:
populations = (retina, Tp, Rp, Vp_h, Vp_v)

#! Inspection
#! ----------

#! We can now look at the network using `PrintNetwork`:
nest.PrintNetwork()

